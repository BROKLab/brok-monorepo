{
  "language": "Solidity",
  "sources": {
    "contracts/capTable/CapTable.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity ^0.8.4;\nimport \"./../ERC1400.sol\";\nimport \"hardhat/console.sol\";\nimport \"./CapTableRegistry.sol\";\n\ncontract CapTable is ERC1400 {\n    event CaptableChangedFagsystem(\n        string indexed orgnr,\n        address indexed oldFagsystem,\n        address indexed newFagsystem\n    );\n    event NewCapTable(string indexed orgnr, address indexed fagsystem);\n    CapTableRegistry internal _capTableRegistry;\n\n    constructor(\n        string memory name,\n        string memory orgnr,\n        uint256 granularity,\n        address[] memory controllers,\n        bytes32[] memory defaultPartitions,\n        address capTableRegistry\n    ) ERC1400(name, orgnr, granularity, controllers, defaultPartitions) {\n        emit NewCapTable(orgnr, msg.sender);\n        _capTableRegistry = CapTableRegistry(capTableRegistry);\n    }\n\n    function setCapTableRegistry(address capTableRegistryAddress)\n        external\n        onlyOwner\n    {\n        _capTableRegistry = CapTableRegistry(capTableRegistryAddress);\n    }\n\n    /* @dev Overwrites the current fagsystem with a new one\n     */\n    function updateFagsystem() external {\n        address oldFagsystem = _controllers[0];\n        address[] memory newFagsystemAsArray = new address[](1);\n        address newFagsystem = getFagsystem();\n        newFagsystemAsArray[0] = newFagsystem;\n        _setControllers(newFagsystemAsArray);\n        emit CaptableChangedFagsystem(getOrgnr(), oldFagsystem, newFagsystem);\n    }\n\n    /* @dev Get the current fagsystem for the cap table\n     */\n    function getFagsystem() public view returns (address) {\n        return _capTableRegistry.getFagsystemForCapTable(address(this));\n    }\n\n    function getFagsystemDid() public view returns (string memory) {\n        address fagsystem = getFagsystem();\n        return _capTableRegistry.getDidForFagsystem(fagsystem);\n    }\n\n    function getOrgnr() public view returns (string memory) {\n        return _symbol;\n    }\n\n    // function kapitalforhoyselse_nye_aksjer(\n    //     bytes32[] memory partition,\n    //     address[] memory to,\n    //     uint256[] memory value,\n    //     bytes memory data\n    // ) external onlyMinter isIssuableToken {\n    //     for (uint256 i = 0; i < to.length; i++) {\n    //         _issueByPartition(partition[i], msg.sender, to[i], value[i], data);\n    //     }\n    // }\n\n    // function splitt(\n    //     bytes32[] memory partition,\n    //     address[] memory to,\n    //     uint256[] memory value,\n    //     bytes memory data\n    // ) external {\n    //     for (uint256 i = 0; i < to.length; i++) {\n    //         // no new shareholders\n    //         require(_balances[to[i]] != uint256(0), \"No new shareholders\");\n    //         _issueByPartition(partition[i], msg.sender, to[i], value[i], data);\n    //     }\n    // }\n\n    // function kapitalnedsettelse_reduksjon_aksjer(\n    //     bytes32[] memory partition,\n    //     address[] memory from,\n    //     uint256[] memory value,\n    //     bytes memory data,\n    //     bytes memory operatorData\n    // ) external {\n    //     for (uint256 i = 0; i < from.length; i++) {\n    //         _redeemByPartition(\n    //             partition[i],\n    //             msg.sender,\n    //             from[i],\n    //             value[i],\n    //             data,\n    //             operatorData\n    //         );\n    //     }\n    // }\n\n    // function spleis(\n    //     bytes32[] memory partition,\n    //     address[] memory from,\n    //     uint256[] memory value,\n    //     bytes memory data,\n    //     bytes memory operatorData\n    // ) external {\n    //     for (uint256 i = 0; i < from.length; i++) {\n    //         _redeemByPartition(\n    //             partition[i],\n    //             msg.sender,\n    //             from[i],\n    //             value[i],\n    //             data,\n    //             operatorData\n    //         );\n    //     }\n    // }\n}\n"
    },
    "contracts/ERC1400.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\n/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./tools/ERC1820Client.sol\";\nimport \"./interface/ERC1820Implementer.sol\";\n\nimport \"./roles/MinterRole.sol\";\n\nimport \"./IERC1400.sol\";\n\n// Extensions\nimport \"./extensions/tokenExtensions/IERC1400TokensValidator.sol\";\nimport \"./extensions/tokenExtensions/IERC1400TokensChecker.sol\";\nimport \"./extensions/userExtensions/IERC1400TokensSender.sol\";\nimport \"./extensions/userExtensions/IERC1400TokensRecipient.sol\";\nimport \"./tools/DomainAware.sol\";\n\n\n/**\n * @title ERC1400\n * @dev ERC1400 logic\n */\ncontract ERC1400 is IERC20, IERC1400, Ownable, ERC1820Client, ERC1820Implementer, MinterRole, DomainAware {\n  using SafeMath for uint256;\n\n  // Token\n  string constant internal ERC1400_INTERFACE_NAME = \"ERC1400Token\";\n  string constant internal ERC20_INTERFACE_NAME = \"ERC20Token\";\n\n  // Token extensions\n  string constant internal ERC1400_TOKENS_CHECKER = \"ERC1400TokensChecker\";\n  string constant internal ERC1400_TOKENS_VALIDATOR = \"ERC1400TokensValidator\";\n\n  // User extensions\n  string constant internal ERC1400_TOKENS_SENDER = \"ERC1400TokensSender\";\n  string constant internal ERC1400_TOKENS_RECIPIENT = \"ERC1400TokensRecipient\";\n\n  /************************************* Token description ****************************************/\n  string internal _name;\n  string internal _symbol;\n  uint256 internal _granularity;\n  uint256 internal _totalSupply;\n  bool internal _migrated;\n  /************************************************************************************************/\n\n\n  /**************************************** Token behaviours **************************************/\n  // Indicate whether the token can still be controlled by operators or not anymore.\n  bool internal _isControllable;\n\n  // Indicate whether the token can still be issued by the issuer or not anymore.\n  bool internal _isIssuable;\n  /************************************************************************************************/\n\n\n  /********************************** ERC20 Token mappings ****************************************/\n  // Mapping from tokenHolder to balance.\n  mapping(address => uint256) internal _balances;\n\n  // Mapping from (tokenHolder, spender) to allowed value.\n  mapping (address => mapping (address => uint256)) internal _allowed;\n  /************************************************************************************************/\n\n\n  /**************************************** Documents *********************************************/\n  struct Doc {\n    string docURI;\n    bytes32 docHash;\n    uint256 timestamp;\n  }\n  // Mapping for documents.\n  mapping(bytes32 => Doc) internal _documents;\n  mapping(bytes32 => uint256) internal _indexOfDocHashes;\n  bytes32[] internal _docHashes;\n  /************************************************************************************************/\n\n\n  /*********************************** Partitions  mappings ***************************************/\n  // List of partitions.\n  bytes32[] internal _totalPartitions;\n\n  // Mapping from partition to their index.\n  mapping (bytes32 => uint256) internal _indexOfTotalPartitions;\n\n  // Mapping from partition to global balance of corresponding partition.\n  mapping (bytes32 => uint256) internal _totalSupplyByPartition;\n\n  // Mapping from tokenHolder to their partitions.\n  mapping (address => bytes32[]) internal _partitionsOf;\n\n  // Mapping from (tokenHolder, partition) to their index.\n  mapping (address => mapping (bytes32 => uint256)) internal _indexOfPartitionsOf;\n\n  // Mapping from (tokenHolder, partition) to balance of corresponding partition.\n  mapping (address => mapping (bytes32 => uint256)) internal _balanceOfByPartition;\n\n  // List of token default partitions (for ERC20 compatibility).\n  bytes32[] internal _defaultPartitions;\n  /************************************************************************************************/\n\n\n  /********************************* Global operators mappings ************************************/\n  // Mapping from (operator, tokenHolder) to authorized status. [TOKEN-HOLDER-SPECIFIC]\n  mapping(address => mapping(address => bool)) internal _authorizedOperator;\n\n  // Array of controllers. [GLOBAL - NOT TOKEN-HOLDER-SPECIFIC]\n  address[] internal _controllers;\n\n  // Mapping from operator to controller status. [GLOBAL - NOT TOKEN-HOLDER-SPECIFIC]\n  mapping(address => bool) internal _isController;\n  /************************************************************************************************/\n\n\n  /******************************** Partition operators mappings **********************************/\n  // Mapping from (partition, tokenHolder, spender) to allowed value. [TOKEN-HOLDER-SPECIFIC]\n  mapping(bytes32 => mapping (address => mapping (address => uint256))) internal _allowedByPartition;\n\n  // Mapping from (tokenHolder, partition, operator) to 'approved for partition' status. [TOKEN-HOLDER-SPECIFIC]\n  mapping (address => mapping (bytes32 => mapping (address => bool))) internal _authorizedOperatorByPartition;\n\n  // Mapping from partition to controllers for the partition. [NOT TOKEN-HOLDER-SPECIFIC]\n  mapping (bytes32 => address[]) internal _controllersByPartition;\n\n  // Mapping from (partition, operator) to PartitionController status. [NOT TOKEN-HOLDER-SPECIFIC]\n  mapping (bytes32 => mapping (address => bool)) internal _isControllerByPartition;\n  /************************************************************************************************/\n\n\n  /***************************************** Modifiers ********************************************/\n  /**\n   * @dev Modifier to verify if token is issuable.\n   */\n  modifier isIssuableToken() {\n    require(_isIssuable, \"55\"); // 0x55\tfunds locked (lockup period)\n    _;\n  }\n  /**\n   * @dev Modifier to make a function callable only when the contract is not migrated.\n   */\n  modifier isNotMigratedToken() {\n      require(!_migrated, \"54\"); // 0x54\ttransfers halted (contract paused)\n      _;\n  }\n  /**\n   * @dev Modifier to verifiy if sender is a minter.\n   */\n  modifier onlyMinter() override {\n      require(isMinter(msg.sender) || owner() == _msgSender());\n      _;\n  }\n  /************************************************************************************************/\n\n\n  /**************************** Events (additional - not mandatory) *******************************/\n  event ApprovalByPartition(bytes32 indexed partition, address indexed owner, address indexed spender, uint256 value);\n  /************************************************************************************************/\n\n\n  /**\n   * @dev Initialize ERC1400 + register the contract implementation in ERC1820Registry.\n   * @param name Name of the token.\n   * @param symbol Symbol of the token.\n   * @param granularity Granularity of the token.\n   * @param controllers Array of initial controllers.\n   * @param defaultPartitions Partitions chosen by default, when partition is\n   * not specified, like the case ERC20 tranfers.\n   */\n  constructor(\n    string memory name,\n    string memory symbol,\n    uint256 granularity,\n    address[] memory controllers,\n    bytes32[] memory defaultPartitions\n  )\n    public\n  {\n    _name = name;\n    _symbol = symbol;\n    _totalSupply = 0;\n    require(granularity >= 1); // Constructor Blocked - Token granularity can not be lower than 1\n    _granularity = granularity;\n\n    _setControllers(controllers);\n\n    _defaultPartitions = defaultPartitions;\n\n    _isControllable = true;\n    _isIssuable = true;\n\n    // Register contract in ERC1820 registry\n    ERC1820Client.setInterfaceImplementation(ERC1400_INTERFACE_NAME, address(this));\n    ERC1820Client.setInterfaceImplementation(ERC20_INTERFACE_NAME, address(this));\n\n    // Indicate token verifies ERC1400 and ERC20 interfaces\n    ERC1820Implementer._setInterface(ERC1400_INTERFACE_NAME); // For migration\n    ERC1820Implementer._setInterface(ERC20_INTERFACE_NAME); // For migration\n  }\n\n\n  /************************************************************************************************/\n  /****************************** EXTERNAL FUNCTIONS (ERC20 INTERFACE) ****************************/\n  /************************************************************************************************/\n\n\n  /**\n   * @dev Get the total number of issued tokens.\n   * @return Total supply of tokens currently in circulation.\n   */\n  function totalSupply() external override view returns (uint256) {\n    return _totalSupply;\n  }\n  /**\n   * @dev Get the balance of the account with address 'tokenHolder'.\n   * @param tokenHolder Address for which the balance is returned.\n   * @return Amount of token held by 'tokenHolder' in the token contract.\n   */\n  function balanceOf(address tokenHolder) external override view returns (uint256) {\n    return _balances[tokenHolder];\n  }\n  /**\n   * @dev Transfer token for a specified address.\n   * @param to The address to transfer to.\n   * @param value The value to be transferred.\n   * @return A boolean that indicates if the operation was successful.\n   */\n  function transfer(address to, uint256 value) external override returns (bool) {\n    _transferByDefaultPartitions(msg.sender, msg.sender, to, value, \"\");\n    return true;\n  }\n  /**\n   * @dev Check the value of tokens that an owner allowed to a spender.\n   * @param owner address The address which owns the funds.\n   * @param spender address The address which will spend the funds.\n   * @return A uint256 specifying the value of tokens still available for the spender.\n   */\n  function allowance(address owner, address spender) external override view returns (uint256) {\n    return _allowed[owner][spender];\n  }\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of 'msg.sender'.\n   * @param spender The address which will spend the funds.\n   * @param value The amount of tokens to be spent.\n   * @return A boolean that indicates if the operation was successful.\n   */\n  function approve(address spender, uint256 value) external override returns (bool) {\n    require(spender != address(0), \"56\"); // 0x56\tinvalid sender\n    _allowed[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n  /**\n   * @dev Transfer tokens from one address to another.\n   * @param from The address which you want to transfer tokens from.\n   * @param to The address which you want to transfer to.\n   * @param value The amount of tokens to be transferred.\n   * @return A boolean that indicates if the operation was successful.\n   */\n  function transferFrom(address from, address to, uint256 value) external override returns (bool) {\n    require( _isOperator(msg.sender, from)\n      || (value <= _allowed[from][msg.sender]), \"53\"); // 0x53\tinsufficient allowance\n\n    if(_allowed[from][msg.sender] >= value) {\n      _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n    } else {\n      _allowed[from][msg.sender] = 0;\n    }\n\n    _transferByDefaultPartitions(msg.sender, from, to, value, \"\");\n    return true;\n  }\n\n\n  /************************************************************************************************/\n  /****************************** EXTERNAL FUNCTIONS (ERC1400 INTERFACE) **************************/\n  /************************************************************************************************/\n\n\n  /************************************* Document Management **************************************/\n  /**\n   * @dev Access a document associated with the token.\n   * @param name Short name (represented as a bytes32) associated to the document.\n   * @return Requested document + document hash + document timestamp.\n   */\n  function getDocument(bytes32 name) external override view returns (string memory, bytes32, uint256) {\n    require(bytes(_documents[name].docURI).length != 0); // Action Blocked - Empty document\n    return (\n      _documents[name].docURI,\n      _documents[name].docHash,\n      _documents[name].timestamp\n    );\n  }\n  /**\n   * @dev Associate a document with the token.\n   * @param name Short name (represented as a bytes32) associated to the document.\n   * @param uri Document content.\n   * @param documentHash Hash of the document [optional parameter].\n   */\n  function setDocument(bytes32 name, string calldata uri, bytes32 documentHash) external override {\n    require(_isController[msg.sender]);\n    _documents[name] = Doc({\n      docURI: uri,\n      docHash: documentHash,\n      timestamp: block.timestamp\n    });\n\n    if (_indexOfDocHashes[documentHash] == 0) {\n      _docHashes.push(documentHash);\n      _indexOfDocHashes[documentHash] = _docHashes.length;\n    }\n\n    emit DocumentUpdated(name, uri, documentHash);\n  }\n\n  function removeDocument(bytes32 _name) external override {\n    require(_isController[msg.sender], \"Unauthorized\");\n    require(bytes(_documents[_name].docURI).length != 0, \"Document doesnt exist\"); // Action Blocked - Empty document\n\n    Doc memory data = _documents[_name];\n\n    uint256 index1 = _indexOfDocHashes[data.docHash];\n    require(index1 > 0, \"Invalid index\"); //Indexing starts at 1, 0 is not allowed\n\n    // move the last item into the index being vacated\n    bytes32 lastValue = _docHashes[_docHashes.length - 1];\n    _docHashes[index1 - 1] = lastValue; // adjust for 1-based indexing\n    _indexOfDocHashes[lastValue] = index1;\n\n    //_totalPartitions.length -= 1;\n    _docHashes.pop();\n    _indexOfDocHashes[data.docHash] = 0;\n\n    delete _documents[_name];\n\n    emit DocumentRemoved(_name, data.docURI, data.docHash);\n  }\n\n  function getAllDocuments() external override view returns (bytes32[] memory) {\n    return _docHashes;\n  }\n  /************************************************************************************************/\n\n\n  /************************************** Token Information ***************************************/\n  /**\n   * @dev Get balance of a tokenholder for a specific partition.\n   * @param partition Name of the partition.\n   * @param tokenHolder Address for which the balance is returned.\n   * @return Amount of token of partition 'partition' held by 'tokenHolder' in the token contract.\n   */\n  function balanceOfByPartition(bytes32 partition, address tokenHolder) external override view returns (uint256) {\n    return _balanceOfByPartition[tokenHolder][partition];\n  }\n  /**\n   * @dev Get partitions index of a tokenholder.\n   * @param tokenHolder Address for which the partitions index are returned.\n   * @return Array of partitions index of 'tokenHolder'.\n   */\n  function partitionsOf(address tokenHolder) external override view returns (bytes32[] memory) {\n    return _partitionsOf[tokenHolder];\n  }\n  /************************************************************************************************/\n\n\n  /****************************************** Transfers *******************************************/\n  /**\n   * @dev Transfer the amount of tokens from the address 'msg.sender' to the address 'to'.\n   * @param to Token recipient.\n   * @param value Number of tokens to transfer.\n   * @param data Information attached to the transfer, by the token holder.\n   */\n  function transferWithData(address to, uint256 value, bytes calldata data) external override {\n    _transferByDefaultPartitions(msg.sender, msg.sender, to, value, data);\n  }\n  /**\n   * @dev Transfer the amount of tokens on behalf of the address 'from' to the address 'to'.\n   * @param from Token holder (or 'address(0)' to set from to 'msg.sender').\n   * @param to Token recipient.\n   * @param value Number of tokens to transfer.\n   * @param data Information attached to the transfer, and intended for the token holder ('from').\n   */\n  function transferFromWithData(address from, address to, uint256 value, bytes calldata data) external override virtual {\n    require( _isOperator(msg.sender, from)\n      || (value <= _allowed[from][msg.sender]), \"53\"); // 0x53\tinsufficient allowance\n\n    if(_allowed[from][msg.sender] >= value) {\n      _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n    } else {\n      _allowed[from][msg.sender] = 0;\n    }\n\n    _transferByDefaultPartitions(msg.sender, from, to, value, data);\n  }\n  /************************************************************************************************/\n\n\n  /********************************** Partition Token Transfers ***********************************/\n  /**\n   * @dev Transfer tokens from a specific partition.\n   * @param partition Name of the partition.\n   * @param to Token recipient.\n   * @param value Number of tokens to transfer.\n   * @param data Information attached to the transfer, by the token holder.\n   * @return Destination partition.\n   */\n  function transferByPartition(\n    bytes32 partition,\n    address to,\n    uint256 value,\n    bytes calldata data\n  )\n    external\n    override\n    returns (bytes32)\n  {\n    return _transferByPartition(partition, msg.sender, msg.sender, to, value, data, \"\");\n  }\n\n  /**\n   * @dev Transfer tokens from a specific partition through an operator.\n   * @param partition Name of the partition.\n   * @param from Token holder.\n   * @param to Token recipient.\n   * @param value Number of tokens to transfer.\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\n   * @param operatorData Information attached to the transfer, by the operator.\n   * @return Destination partition.\n   */\n  function operatorTransferByPartition(\n    bytes32 partition,\n    address from,\n    address to,\n    uint256 value,\n    bytes calldata data,\n    bytes calldata operatorData\n  )\n    external\n    override\n    returns (bytes32)\n  {\n    //We want to check if the msg.sender is an authorized operator for `from`\n    //(msg.sender == from OR msg.sender is authorized by from OR msg.sender is a controller if this token is controlable)\n    //OR\n    //We want to check if msg.sender is an `allowed` operator/spender for `from`\n    require(_isOperatorForPartition(partition, msg.sender, from)\n      || (value <= _allowedByPartition[partition][from][msg.sender]), \"53\"); // 0x53\tinsufficient allowance\n\n    if(_allowedByPartition[partition][from][msg.sender] >= value) {\n      _allowedByPartition[partition][from][msg.sender] = _allowedByPartition[partition][from][msg.sender].sub(value);\n    } else {\n      _allowedByPartition[partition][from][msg.sender] = 0;\n    }\n\n    return _transferByPartition(partition, msg.sender, from, to, value, data, operatorData);\n  }\n  /************************************************************************************************/\n\n\n  /************************************* Controller Operation *************************************/\n  /**\n   * @dev Know if the token can be controlled by operators.\n   * If a token returns 'false' for 'isControllable()'' then it MUST always return 'false' in the future.\n   * @return bool 'true' if the token can still be controlled by operators, 'false' if it can't anymore.\n   */\n  function isControllable() external override view returns (bool) {\n    return _isControllable;\n  }\n  /************************************************************************************************/\n\n\n  /************************************* Operator Management **************************************/\n  /**\n   * @dev Set a third party operator address as an operator of 'msg.sender' to transfer\n   * and redeem tokens on its behalf.\n   * @param operator Address to set as an operator for 'msg.sender'.\n   */\n  function authorizeOperator(address operator) external override {\n    require(operator != msg.sender);\n    _authorizedOperator[operator][msg.sender] = true;\n    emit AuthorizedOperator(operator, msg.sender);\n  }\n  /**\n   * @dev Remove the right of the operator address to be an operator for 'msg.sender'\n   * and to transfer and redeem tokens on its behalf.\n   * @param operator Address to rescind as an operator for 'msg.sender'.\n   */\n  function revokeOperator(address operator) external override {\n    require(operator != msg.sender);\n    _authorizedOperator[operator][msg.sender] = false;\n    emit RevokedOperator(operator, msg.sender);\n  }\n  /**\n   * @dev Set 'operator' as an operator for 'msg.sender' for a given partition.\n   * @param partition Name of the partition.\n   * @param operator Address to set as an operator for 'msg.sender'.\n   */\n  function authorizeOperatorByPartition(bytes32 partition, address operator) external override {\n    _authorizedOperatorByPartition[msg.sender][partition][operator] = true;\n    emit AuthorizedOperatorByPartition(partition, operator, msg.sender);\n  }\n  /**\n   * @dev Remove the right of the operator address to be an operator on a given\n   * partition for 'msg.sender' and to transfer and redeem tokens on its behalf.\n   * @param partition Name of the partition.\n   * @param operator Address to rescind as an operator on given partition for 'msg.sender'.\n   */\n  function revokeOperatorByPartition(bytes32 partition, address operator) external override {\n    _authorizedOperatorByPartition[msg.sender][partition][operator] = false;\n    emit RevokedOperatorByPartition(partition, operator, msg.sender);\n  }\n  /************************************************************************************************/\n\n\n  /************************************* Operator Information *************************************/\n  /**\n   * @dev Indicate whether the operator address is an operator of the tokenHolder address.\n   * @param operator Address which may be an operator of tokenHolder.\n   * @param tokenHolder Address of a token holder which may have the operator address as an operator.\n   * @return 'true' if operator is an operator of 'tokenHolder' and 'false' otherwise.\n   */\n  function isOperator(address operator, address tokenHolder) external override view returns (bool) {\n    return _isOperator(operator, tokenHolder);\n  }\n  /**\n   * @dev Indicate whether the operator address is an operator of the tokenHolder\n   * address for the given partition.\n   * @param partition Name of the partition.\n   * @param operator Address which may be an operator of tokenHolder for the given partition.\n   * @param tokenHolder Address of a token holder which may have the operator address as an operator for the given partition.\n   * @return 'true' if 'operator' is an operator of 'tokenHolder' for partition 'partition' and 'false' otherwise.\n   */\n  function isOperatorForPartition(bytes32 partition, address operator, address tokenHolder) external override view returns (bool) {\n    return _isOperatorForPartition(partition, operator, tokenHolder);\n  }\n  /************************************************************************************************/\n\n\n  /**************************************** Token Issuance ****************************************/\n  /**\n   * @dev Know if new tokens can be issued in the future.\n   * @return bool 'true' if tokens can still be issued by the issuer, 'false' if they can't anymore.\n   */\n  function isIssuable() external override view returns (bool) {\n    return _isIssuable;\n  }\n  /**\n   * @dev Issue tokens from default partition.\n   * @param tokenHolder Address for which we want to issue tokens.\n   * @param value Number of tokens issued.\n   * @param data Information attached to the issuance, by the issuer.\n   */\n  function issue(address tokenHolder, uint256 value, bytes calldata data)\n    external\n    override\n    onlyMinter\n    isIssuableToken\n  {\n    require(_defaultPartitions.length != 0, \"55\"); // 0x55\tfunds locked (lockup period)\n\n    _issueByPartition(_defaultPartitions[0], msg.sender, tokenHolder, value, data);\n  }\n  /**\n   * @dev Issue tokens from a specific partition.\n   * @param partition Name of the partition.\n   * @param tokenHolder Address for which we want to issue tokens.\n   * @param value Number of tokens issued.\n   * @param data Information attached to the issuance, by the issuer.\n   */\n  function issueByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata data)\n    external\n    override\n    onlyMinter\n    isIssuableToken\n  {\n    _issueByPartition(partition, msg.sender, tokenHolder, value, data);\n  }\n  /************************************************************************************************/\n  \n\n  /*************************************** Token Redemption ***************************************/\n  /**\n   * @dev Redeem the amount of tokens from the address 'msg.sender'.\n   * @param value Number of tokens to redeem.\n   * @param data Information attached to the redemption, by the token holder.\n   */\n  function redeem(uint256 value, bytes calldata data)\n    external\n    override\n  {\n    _redeemByDefaultPartitions(msg.sender, msg.sender, value, data);\n  }\n  /**\n   * @dev Redeem the amount of tokens on behalf of the address from.\n   * @param from Token holder whose tokens will be redeemed (or address(0) to set from to msg.sender).\n   * @param value Number of tokens to redeem.\n   * @param data Information attached to the redemption.\n   */\n  function redeemFrom(address from, uint256 value, bytes calldata data)\n    external\n    override\n    virtual\n  {\n    require(_isOperator(msg.sender, from)\n      || (value <= _allowed[from][msg.sender]), \"53\"); // 0x53\tinsufficient allowance\n\n    if(_allowed[from][msg.sender] >= value) {\n      _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n    } else {\n      _allowed[from][msg.sender] = 0;\n    }\n\n    _redeemByDefaultPartitions(msg.sender, from, value, data);\n  }\n  /**\n   * @dev Redeem tokens of a specific partition.\n   * @param partition Name of the partition.\n   * @param value Number of tokens redeemed.\n   * @param data Information attached to the redemption, by the redeemer.\n   */\n  function redeemByPartition(bytes32 partition, uint256 value, bytes calldata data)\n    external\n    override\n  {\n    _redeemByPartition(partition, msg.sender, msg.sender, value, data, \"\");\n  }\n  /**\n   * @dev Redeem tokens of a specific partition.\n   * @param partition Name of the partition.\n   * @param tokenHolder Address for which we want to redeem tokens.\n   * @param value Number of tokens redeemed\n   * @param operatorData Information attached to the redemption, by the operator.\n   */\n  function operatorRedeemByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata operatorData)\n    external\n    override\n  {\n    require(_isOperatorForPartition(partition, msg.sender, tokenHolder) || value <= _allowedByPartition[partition][tokenHolder][msg.sender], \"58\"); // 0x58\tinvalid operator (transfer agent)\n\n    if(_allowedByPartition[partition][tokenHolder][msg.sender] >= value) {\n      _allowedByPartition[partition][tokenHolder][msg.sender] = _allowedByPartition[partition][tokenHolder][msg.sender].sub(value);\n    } else {\n      _allowedByPartition[partition][tokenHolder][msg.sender] = 0;\n    }\n\n    _redeemByPartition(partition, msg.sender, tokenHolder, value, \"\", operatorData);\n  }\n  /************************************************************************************************/\n\n\n  /************************************************************************************************/\n  /************************ EXTERNAL FUNCTIONS (ADDITIONAL - NOT MANDATORY) ***********************/\n  /************************************************************************************************/\n\n\n  /************************************ Token description *****************************************/\n  /**\n   * @dev Get the name of the token, e.g., \"MyToken\".\n   * @return Name of the token.\n   */\n  function name() external view returns(string memory) {\n    return _name;\n  }\n  /**\n   * @dev Get the symbol of the token, e.g., \"MYT\".\n   * @return Symbol of the token.\n   */\n  function symbol() external view returns(string memory) {\n    return _symbol;\n  }\n  /**\n   * @dev Get the number of decimals of the token.\n   * @return The number of decimals of the token. For retrocompatibility, decimals are forced to 18 in ERC1400.\n   */\n  function decimals() external pure returns(uint8) {\n    return uint8(18);\n  }\n  /**\n   * @dev Get the smallest part of the token that’s not divisible.\n   * @return The smallest non-divisible part of the token.\n   */\n  function granularity() external view returns(uint256) {\n    return _granularity;\n  }\n  /**\n   * @dev Get list of existing partitions.\n   * @return Array of all exisiting partitions.\n   */\n  function totalPartitions() external view returns (bytes32[] memory) {\n    return _totalPartitions;\n  }\n  /**\n   * @dev Get the total number of issued tokens for a given partition.\n   * @param partition Name of the partition.\n   * @return Total supply of tokens currently in circulation, for a given partition.\n   */\n  function totalSupplyByPartition(bytes32 partition) external view returns (uint256) {\n    return _totalSupplyByPartition[partition];\n  }\n  /************************************************************************************************/\n\n\n  /**************************************** Token behaviours **************************************/\n  /**\n   * @dev Definitely renounce the possibility to control tokens on behalf of tokenHolders.\n   * Once set to false, '_isControllable' can never be set to 'true' again.\n   */\n  function renounceControl() external onlyOwner {\n    _isControllable = false;\n  }\n  /**\n   * @dev Definitely renounce the possibility to issue new tokens.\n   * Once set to false, '_isIssuable' can never be set to 'true' again.\n   */\n  function renounceIssuance() external onlyOwner {\n    _isIssuable = false;\n  }\n  /************************************************************************************************/\n\n\n  /************************************ Token controllers *****************************************/\n  /**\n   * @dev Get the list of controllers as defined by the token contract.\n   * @return List of addresses of all the controllers.\n   */\n  function controllers() external view returns (address[] memory) {\n    return _controllers;\n  }\n  /**\n   * @dev Get controllers for a given partition.\n   * @param partition Name of the partition.\n   * @return Array of controllers for partition.\n   */\n  function controllersByPartition(bytes32 partition) external view returns (address[] memory) {\n    return _controllersByPartition[partition];\n  }\n  /**\n   * @dev Set list of token controllers.\n   * @param operators Controller addresses.\n   */\n  function setControllers(address[] calldata operators) external onlyOwner {\n    _setControllers(operators);\n  }\n  /**\n   * @dev Set list of token partition controllers.\n   * @param partition Name of the partition.\n   * @param operators Controller addresses.\n   */\n   function setPartitionControllers(bytes32 partition, address[] calldata operators) external onlyOwner {\n     _setPartitionControllers(partition, operators);\n   }\n  /************************************************************************************************/\n\n\n  /********************************* Token default partitions *************************************/\n  /**\n   * @dev Get default partitions to transfer from.\n   * Function used for ERC20 retrocompatibility.\n   * For example, a security token may return the bytes32(\"unrestricted\").\n   * @return Array of default partitions.\n   */\n  function getDefaultPartitions() external view returns (bytes32[] memory) {\n    return _defaultPartitions;\n  }\n  /**\n   * @dev Set default partitions to transfer from.\n   * Function used for ERC20 retrocompatibility.\n   * @param partitions partitions to use by default when not specified.\n   */\n  function setDefaultPartitions(bytes32[] calldata partitions) external onlyOwner {\n    _defaultPartitions = partitions;\n  }\n  /************************************************************************************************/\n\n\n  /******************************** Partition Token Allowances ************************************/\n  /**\n   * @dev Check the value of tokens that an owner allowed to a spender.\n   * @param partition Name of the partition.\n   * @param owner address The address which owns the funds.\n   * @param spender address The address which will spend the funds.\n   * @return A uint256 specifying the value of tokens still available for the spender.\n   */\n  function allowanceByPartition(bytes32 partition, address owner, address spender) external override view returns (uint256) {\n    return _allowedByPartition[partition][owner][spender];\n  }\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of 'msg.sender'.\n   * @param partition Name of the partition.\n   * @param spender The address which will spend the funds.\n   * @param value The amount of tokens to be spent.\n   * @return A boolean that indicates if the operation was successful.\n   */\n  function approveByPartition(bytes32 partition, address spender, uint256 value) external returns (bool) {\n    require(spender != address(0), \"56\"); // 0x56\tinvalid sender\n    _allowedByPartition[partition][msg.sender][spender] = value;\n    emit ApprovalByPartition(partition, msg.sender, spender, value);\n    return true;\n  }\n  /************************************************************************************************/\n\n  \n  /************************************** Token extension *****************************************/\n  /**\n   * @dev Set token extension contract address.\n   * The extension contract can for example verify \"ERC1400TokensValidator\" or \"ERC1400TokensChecker\" interfaces.\n   * If the extension is an \"ERC1400TokensValidator\", it will be called everytime a transfer is executed.\n   * @param extension Address of the extension contract.\n   * @param interfaceLabel Interface label of extension contract.\n   * @param removeOldExtensionRoles If set to 'true', the roles of the old extension(minter, controller) will be removed extension.\n   * @param addMinterRoleForExtension If set to 'true', the extension contract will be added as minter.\n   * @param addControllerRoleForExtension If set to 'true', the extension contract will be added as controller.\n   */\n  function setTokenExtension(address extension, string calldata interfaceLabel, bool removeOldExtensionRoles, bool addMinterRoleForExtension, bool addControllerRoleForExtension) external onlyOwner {\n    _setTokenExtension(extension, interfaceLabel, removeOldExtensionRoles, addMinterRoleForExtension, addControllerRoleForExtension);\n  }\n  /************************************************************************************************/\n\n  /************************************* Token migration ******************************************/\n  /**\n   * @dev Migrate contract.\n   *\n   * ===> CAUTION: DEFINITIVE ACTION\n   * \n   * This function shall be called once a new version of the smart contract has been created.\n   * Once this function is called:\n   *  - The address of the new smart contract is set in ERC1820 registry\n   *  - If the choice is definitive, the current smart contract is turned off and can never be used again\n   *\n   * @param newContractAddress Address of the new version of the smart contract.\n   * @param definitive If set to 'true' the contract is turned off definitely.\n   */\n  function migrate(address newContractAddress, bool definitive) external onlyOwner {\n    _migrate(newContractAddress, definitive);\n  }\n  /************************************************************************************************/\n\n\n  /************************************************************************************************/\n  /************************************* INTERNAL FUNCTIONS ***************************************/\n  /************************************************************************************************/\n\n\n  /**************************************** Token Transfers ***************************************/\n  /**\n   * @dev Perform the transfer of tokens.\n   * @param from Token holder.\n   * @param to Token recipient.\n   * @param value Number of tokens to transfer.\n   */\n  function _transferWithData(\n    address from,\n    address to,\n    uint256 value\n  )\n    internal\n    isNotMigratedToken\n  {\n    require(_isMultiple(value), \"50\"); // 0x50\ttransfer failure\n    require(to != address(0), \"57\"); // 0x57\tinvalid receiver\n    require(_balances[from] >= value, \"52\"); // 0x52\tinsufficient balance\n  \n    _balances[from] = _balances[from].sub(value);\n    _balances[to] = _balances[to].add(value);\n\n    emit Transfer(from, to, value); // ERC20 retrocompatibility \n  }\n  /**\n   * @dev Transfer tokens from a specific partition.\n   * @param fromPartition Partition of the tokens to transfer.\n   * @param operator The address performing the transfer.\n   * @param from Token holder.\n   * @param to Token recipient.\n   * @param value Number of tokens to transfer.\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\n   * @param operatorData Information attached to the transfer, by the operator (if any).\n   * @return Destination partition.\n   */\n  function _transferByPartition(\n    bytes32 fromPartition,\n    address operator,\n    address from,\n    address to,\n    uint256 value,\n    bytes memory data,\n    bytes memory operatorData\n  )\n    internal\n    returns (bytes32)\n  {\n    require(_balanceOfByPartition[from][fromPartition] >= value, \"52\"); // 0x52\tinsufficient balance\n\n    bytes32 toPartition = fromPartition;\n\n    if(operatorData.length != 0 && data.length >= 64) {\n      toPartition = _getDestinationPartition(fromPartition, data);\n    }\n\n    _callSenderExtension(fromPartition, operator, from, to, value, data, operatorData);\n    _callTokenExtension(fromPartition, operator, from, to, value, data, operatorData);\n\n    _removeTokenFromPartition(from, fromPartition, value);\n    _transferWithData(from, to, value);\n    _addTokenToPartition(to, toPartition, value);\n\n    _callRecipientExtension(toPartition, operator, from, to, value, data, operatorData);\n\n    emit TransferByPartition(fromPartition, operator, from, to, value, data, operatorData);\n\n    if(toPartition != fromPartition) {\n      emit ChangedPartition(fromPartition, toPartition, value);\n    }\n\n    return toPartition;\n  }\n  /**\n   * @dev Transfer tokens from default partitions.\n   * Function used for ERC20 retrocompatibility.\n   * @param operator The address performing the transfer.\n   * @param from Token holder.\n   * @param to Token recipient.\n   * @param value Number of tokens to transfer.\n   * @param data Information attached to the transfer, and intended for the token holder ('from') [CAN CONTAIN THE DESTINATION PARTITION].\n   */\n  function _transferByDefaultPartitions(\n    address operator,\n    address from,\n    address to,\n    uint256 value,\n    bytes memory data\n  )\n    internal\n  {\n    require(_defaultPartitions.length != 0, \"55\"); // // 0x55\tfunds locked (lockup period)\n\n    uint256 _remainingValue = value;\n    uint256 _localBalance;\n\n    for (uint i = 0; i < _defaultPartitions.length; i++) {\n      _localBalance = _balanceOfByPartition[from][_defaultPartitions[i]];\n      if(_remainingValue <= _localBalance) {\n        _transferByPartition(_defaultPartitions[i], operator, from, to, _remainingValue, data, \"\");\n        _remainingValue = 0;\n        break;\n      } else if (_localBalance != 0) {\n        _transferByPartition(_defaultPartitions[i], operator, from, to, _localBalance, data, \"\");\n        _remainingValue = _remainingValue - _localBalance;\n      }\n    }\n\n    require(_remainingValue == 0, \"52\"); // 0x52\tinsufficient balance\n  }\n  /**\n   * @dev Retrieve the destination partition from the 'data' field.\n   * By convention, a partition change is requested ONLY when 'data' starts\n   * with the flag: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n   * When the flag is detected, the destination tranche is extracted from the\n   * 32 bytes following the flag.\n   * @param fromPartition Partition of the tokens to transfer.\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\n   * @return toPartition Destination partition.\n   */\n  function _getDestinationPartition(bytes32 fromPartition, bytes memory data) internal pure returns(bytes32 toPartition) {\n    bytes32 changePartitionFlag = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    bytes32 flag;\n    assembly {\n      flag := mload(add(data, 32))\n    }\n    if(flag == changePartitionFlag) {\n      assembly {\n        toPartition := mload(add(data, 64))\n      }\n    } else {\n      toPartition = fromPartition;\n    }\n  }\n  /**\n   * @dev Remove a token from a specific partition.\n   * @param from Token holder.\n   * @param partition Name of the partition.\n   * @param value Number of tokens to transfer.\n   */\n  function _removeTokenFromPartition(address from, bytes32 partition, uint256 value) internal {\n    _balanceOfByPartition[from][partition] = _balanceOfByPartition[from][partition].sub(value);\n    _totalSupplyByPartition[partition] = _totalSupplyByPartition[partition].sub(value);\n\n    // If the total supply is zero, finds and deletes the partition.\n    if(_totalSupplyByPartition[partition] == 0) {\n      uint256 index1 = _indexOfTotalPartitions[partition];\n      require(index1 > 0, \"50\"); // 0x50\ttransfer failure\n\n      // move the last item into the index being vacated\n      bytes32 lastValue = _totalPartitions[_totalPartitions.length - 1];\n      _totalPartitions[index1 - 1] = lastValue; // adjust for 1-based indexing\n      _indexOfTotalPartitions[lastValue] = index1;\n\n      //_totalPartitions.length -= 1;\n      _totalPartitions.pop();\n      _indexOfTotalPartitions[partition] = 0;\n    }\n\n    // If the balance of the TokenHolder's partition is zero, finds and deletes the partition.\n    if(_balanceOfByPartition[from][partition] == 0) {\n      uint256 index2 = _indexOfPartitionsOf[from][partition];\n      require(index2 > 0, \"50\"); // 0x50\ttransfer failure\n\n      // move the last item into the index being vacated\n      bytes32 lastValue = _partitionsOf[from][_partitionsOf[from].length - 1];\n      _partitionsOf[from][index2 - 1] = lastValue;  // adjust for 1-based indexing\n      _indexOfPartitionsOf[from][lastValue] = index2;\n\n      //_partitionsOf[from].length -= 1;\n      _partitionsOf[from].pop();\n      _indexOfPartitionsOf[from][partition] = 0;\n    }\n  }\n  /**\n   * @dev Add a token to a specific partition.\n   * @param to Token recipient.\n   * @param partition Name of the partition.\n   * @param value Number of tokens to transfer.\n   */\n  function _addTokenToPartition(address to, bytes32 partition, uint256 value) internal {\n    if(value != 0) {\n      if (_indexOfPartitionsOf[to][partition] == 0) {\n        _partitionsOf[to].push(partition);\n        _indexOfPartitionsOf[to][partition] = _partitionsOf[to].length;\n      }\n      _balanceOfByPartition[to][partition] = _balanceOfByPartition[to][partition].add(value);\n\n      if (_indexOfTotalPartitions[partition] == 0) {\n        _totalPartitions.push(partition);\n        _indexOfTotalPartitions[partition] = _totalPartitions.length;\n      }\n      _totalSupplyByPartition[partition] = _totalSupplyByPartition[partition].add(value);\n    }\n  }\n  /**\n   * @dev Check if 'value' is multiple of the granularity.\n   * @param value The quantity that want's to be checked.\n   * @return 'true' if 'value' is a multiple of the granularity.\n   */\n  function _isMultiple(uint256 value) internal view returns(bool) {\n    return(value.div(_granularity).mul(_granularity) == value);\n  }\n  /************************************************************************************************/\n\n\n  /****************************************** Hooks ***********************************************/\n  /**\n   * @dev Check for 'ERC1400TokensSender' user extension in ERC1820 registry and call it.\n   * @param partition Name of the partition (bytes32 to be left empty for transfers where partition is not specified).\n   * @param operator Address which triggered the balance decrease (through transfer or redemption).\n   * @param from Token holder.\n   * @param to Token recipient for a transfer and 0x for a redemption.\n   * @param value Number of tokens the token holder balance is decreased by.\n   * @param data Extra information.\n   * @param operatorData Extra information, attached by the operator (if any).\n   */\n  function _callSenderExtension(\n    bytes32 partition,\n    address operator,\n    address from,\n    address to,\n    uint256 value,\n    bytes memory data,\n    bytes memory operatorData\n  )\n    internal\n  {\n    address senderImplementation;\n    senderImplementation = interfaceAddr(from, ERC1400_TOKENS_SENDER);\n    if (senderImplementation != address(0)) {\n      IERC1400TokensSender(senderImplementation).tokensToTransfer(msg.data, partition, operator, from, to, value, data, operatorData);\n    }\n  }\n  /**\n   * @dev Check for 'ERC1400TokensValidator' token extension in ERC1820 registry and call it.\n   * @param partition Name of the partition (bytes32 to be left empty for transfers where partition is not specified).\n   * @param operator Address which triggered the balance decrease (through transfer or redemption).\n   * @param from Token holder.\n   * @param to Token recipient for a transfer and 0x for a redemption.\n   * @param value Number of tokens the token holder balance is decreased by.\n   * @param data Extra information.\n   * @param operatorData Extra information, attached by the operator (if any).\n   */\n  function _callTokenExtension(\n    bytes32 partition,\n    address operator,\n    address from,\n    address to,\n    uint256 value,\n    bytes memory data,\n    bytes memory operatorData\n  )\n    internal\n  {\n    address validatorImplementation;\n    validatorImplementation = interfaceAddr(address(this), ERC1400_TOKENS_VALIDATOR);\n    if (validatorImplementation != address(0)) {\n      IERC1400TokensValidator(validatorImplementation).tokensToValidate(msg.data, partition, operator, from, to, value, data, operatorData);\n    }\n  }\n  /**\n   * @dev Check for 'ERC1400TokensRecipient' user extension in ERC1820 registry and call it.\n   * @param partition Name of the partition (bytes32 to be left empty for transfers where partition is not specified).\n   * @param operator Address which triggered the balance increase (through transfer or issuance).\n   * @param from Token holder for a transfer and 0x for an issuance.\n   * @param to Token recipient.\n   * @param value Number of tokens the recipient balance is increased by.\n   * @param data Extra information, intended for the token holder ('from').\n   * @param operatorData Extra information attached by the operator (if any).\n   */\n  function _callRecipientExtension(\n    bytes32 partition,\n    address operator,\n    address from,\n    address to,\n    uint256 value,\n    bytes memory data,\n    bytes memory operatorData\n  )\n    internal\n    virtual\n  {\n    address recipientImplementation;\n    recipientImplementation = interfaceAddr(to, ERC1400_TOKENS_RECIPIENT);\n\n    if (recipientImplementation != address(0)) {\n      IERC1400TokensRecipient(recipientImplementation).tokensReceived(msg.data, partition, operator, from, to, value, data, operatorData);\n    }\n  }\n  /************************************************************************************************/\n\n\n  /************************************* Operator Information *************************************/\n  /**\n   * @dev Indicate whether the operator address is an operator of the tokenHolder address.\n   * @param operator Address which may be an operator of 'tokenHolder'.\n   * @param tokenHolder Address of a token holder which may have the 'operator' address as an operator.\n   * @return 'true' if 'operator' is an operator of 'tokenHolder' and 'false' otherwise.\n   */\n  function _isOperator(address operator, address tokenHolder) internal view returns (bool) {\n    return (operator == tokenHolder\n      || _authorizedOperator[operator][tokenHolder]\n      || (_isControllable && _isController[operator])\n    );\n  }\n  /**\n   * @dev Indicate whether the operator address is an operator of the tokenHolder\n   * address for the given partition.\n   * @param partition Name of the partition.\n   * @param operator Address which may be an operator of tokenHolder for the given partition.\n   * @param tokenHolder Address of a token holder which may have the operator address as an operator for the given partition.\n   * @return 'true' if 'operator' is an operator of 'tokenHolder' for partition 'partition' and 'false' otherwise.\n   */\n   function _isOperatorForPartition(bytes32 partition, address operator, address tokenHolder) internal view returns (bool) {\n     return (_isOperator(operator, tokenHolder)\n       || _authorizedOperatorByPartition[tokenHolder][partition][operator]\n       || (_isControllable && _isControllerByPartition[partition][operator])\n     );\n   }\n  /************************************************************************************************/\n\n\n  /**************************************** Token Issuance ****************************************/\n  /**\n   * @dev Perform the issuance of tokens.\n   * @param operator Address which triggered the issuance.\n   * @param to Token recipient.\n   * @param value Number of tokens issued.\n   * @param data Information attached to the issuance, and intended for the recipient (to).\n   */\n  function _issue(address operator, address to, uint256 value, bytes memory data)\n    internal\n    isNotMigratedToken  \n  {\n    require(_isMultiple(value), \"50\"); // 0x50\ttransfer failure\n    require(to != address(0), \"57\"); // 0x57\tinvalid receiver\n\n    _totalSupply = _totalSupply.add(value);\n    _balances[to] = _balances[to].add(value);\n\n    emit Issued(operator, to, value, data);\n    emit Transfer(address(0), to, value); // ERC20 retrocompatibility\n  }\n  /**\n   * @dev Issue tokens from a specific partition.\n   * @param toPartition Name of the partition.\n   * @param operator The address performing the issuance.\n   * @param to Token recipient.\n   * @param value Number of tokens to issue.\n   * @param data Information attached to the issuance.\n   */\n  function _issueByPartition(\n    bytes32 toPartition,\n    address operator,\n    address to,\n    uint256 value,\n    bytes memory data\n  )\n    internal\n  {\n    _callTokenExtension(toPartition, operator, address(0), to, value, data, \"\");\n\n    _issue(operator, to, value, data);\n    _addTokenToPartition(to, toPartition, value);\n\n    _callRecipientExtension(toPartition, operator, address(0), to, value, data, \"\");\n\n    emit IssuedByPartition(toPartition, operator, to, value, data, \"\");\n  }\n  /************************************************************************************************/\n\n\n  /*************************************** Token Redemption ***************************************/\n  /**\n   * @dev Perform the token redemption.\n   * @param operator The address performing the redemption.\n   * @param from Token holder whose tokens will be redeemed.\n   * @param value Number of tokens to redeem.\n   * @param data Information attached to the redemption.\n   */\n  function _redeem(address operator, address from, uint256 value, bytes memory data)\n    internal\n    isNotMigratedToken\n  {\n    require(_isMultiple(value), \"50\"); // 0x50\ttransfer failure\n    require(from != address(0), \"56\"); // 0x56\tinvalid sender\n    require(_balances[from] >= value, \"52\"); // 0x52\tinsufficient balance\n\n    _balances[from] = _balances[from].sub(value);\n    _totalSupply = _totalSupply.sub(value);\n\n    emit Redeemed(operator, from, value, data);\n    emit Transfer(from, address(0), value);  // ERC20 retrocompatibility\n  }\n  /**\n   * @dev Redeem tokens of a specific partition.\n   * @param fromPartition Name of the partition.\n   * @param operator The address performing the redemption.\n   * @param from Token holder whose tokens will be redeemed.\n   * @param value Number of tokens to redeem.\n   * @param data Information attached to the redemption.\n   * @param operatorData Information attached to the redemption, by the operator (if any).\n   */\n  function _redeemByPartition(\n    bytes32 fromPartition,\n    address operator,\n    address from,\n    uint256 value,\n    bytes memory data,\n    bytes memory operatorData\n  )\n    internal\n  {\n    require(_balanceOfByPartition[from][fromPartition] >= value, \"52\"); // 0x52\tinsufficient balance\n\n    _callSenderExtension(fromPartition, operator, from, address(0), value, data, operatorData);\n    _callTokenExtension(fromPartition, operator, from, address(0), value, data, operatorData);\n\n    _removeTokenFromPartition(from, fromPartition, value);\n    _redeem(operator, from, value, data);\n\n    emit RedeemedByPartition(fromPartition, operator, from, value, operatorData);\n  }\n  /**\n   * @dev Redeem tokens from a default partitions.\n   * @param operator The address performing the redeem.\n   * @param from Token holder.\n   * @param value Number of tokens to redeem.\n   * @param data Information attached to the redemption.\n   */\n  function _redeemByDefaultPartitions(\n    address operator,\n    address from,\n    uint256 value,\n    bytes memory data\n  )\n    internal\n  {\n    require(_defaultPartitions.length != 0, \"55\"); // 0x55\tfunds locked (lockup period)\n\n    uint256 _remainingValue = value;\n    uint256 _localBalance;\n\n    for (uint i = 0; i < _defaultPartitions.length; i++) {\n      _localBalance = _balanceOfByPartition[from][_defaultPartitions[i]];\n      if(_remainingValue <= _localBalance) {\n        _redeemByPartition(_defaultPartitions[i], operator, from, _remainingValue, data, \"\");\n        _remainingValue = 0;\n        break;\n      } else {\n        _redeemByPartition(_defaultPartitions[i], operator, from, _localBalance, data, \"\");\n        _remainingValue = _remainingValue - _localBalance;\n      }\n    }\n\n    require(_remainingValue == 0, \"52\"); // 0x52\tinsufficient balance\n  }\n  /************************************************************************************************/\n\n\n  /************************************** Transfer Validity ***************************************/\n  /**\n   * @dev Know the reason on success or failure based on the EIP-1066 application-specific status codes.\n   * @param payload Payload of the initial transaction.\n   * @param partition Name of the partition.\n   * @param operator The address performing the transfer.\n   * @param from Token holder.\n   * @param to Token recipient.\n   * @param value Number of tokens to transfer.\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\n   * @param operatorData Information attached to the transfer, by the operator (if any).\n   * @return ESC (Ethereum Status Code) following the EIP-1066 standard.\n   * @return Additional bytes32 parameter that can be used to define\n   * application specific reason codes with additional details (for example the\n   * transfer restriction rule responsible for making the transfer operation invalid).\n   * @return Destination partition.\n   */\n  function _canTransfer(bytes memory payload, bytes32 partition, address operator, address from, address to, uint256 value, bytes memory data, bytes memory operatorData)\n    internal\n    view\n    returns (bytes1, bytes32, bytes32)\n  {\n    address checksImplementation = interfaceAddr(address(this), ERC1400_TOKENS_CHECKER);\n\n    if((checksImplementation != address(0))) {\n      return IERC1400TokensChecker(checksImplementation).canTransferByPartition(payload, partition, operator, from, to, value, data, operatorData);\n    }\n    else {\n      return(hex\"00\", \"\", partition);\n    }\n  }\n  /************************************************************************************************/\n\n\n  /************************************************************************************************/\n  /************************ INTERNAL FUNCTIONS (ADDITIONAL - NOT MANDATORY) ***********************/\n  /************************************************************************************************/\n\n\n  /************************************ Token controllers *****************************************/\n  /**\n   * @dev Set list of token controllers.\n   * @param operators Controller addresses.\n   */\n  function _setControllers(address[] memory operators) internal {\n    for (uint i = 0; i<_controllers.length; i++){\n      _isController[_controllers[i]] = false;\n    }\n    for (uint j = 0; j<operators.length; j++){\n      _isController[operators[j]] = true;\n    }\n    _controllers = operators;\n  }\n  /**\n   * @dev Set list of token partition controllers.\n   * @param partition Name of the partition.\n   * @param operators Controller addresses.\n   */\n   function _setPartitionControllers(bytes32 partition, address[] memory operators) internal {\n     for (uint i = 0; i<_controllersByPartition[partition].length; i++){\n       _isControllerByPartition[partition][_controllersByPartition[partition][i]] = false;\n     }\n     for (uint j = 0; j<operators.length; j++){\n       _isControllerByPartition[partition][operators[j]] = true;\n     }\n     _controllersByPartition[partition] = operators;\n   }\n  /************************************************************************************************/\n\n\n  /************************************** Token extension *****************************************/\n  /**\n   * @dev Set token extension contract address.\n   * The extension contract can for example verify \"ERC1400TokensValidator\" or \"ERC1400TokensChecker\" interfaces.\n   * If the extension is an \"ERC1400TokensValidator\", it will be called everytime a transfer is executed.\n   * @param extension Address of the extension contract.\n   * @param interfaceLabel Interface label of extension contract.\n   * @param removeOldExtensionRoles If set to 'true', the roles of the old extension(minter, controller) will be removed extension.\n   * @param addMinterRoleForExtension If set to 'true', the extension contract will be added as minter.\n   * @param addControllerRoleForExtension If set to 'true', the extension contract will be added as controller.\n   */\n  function _setTokenExtension(address extension, string memory interfaceLabel, bool removeOldExtensionRoles, bool addMinterRoleForExtension, bool addControllerRoleForExtension) internal {\n    address oldExtension = interfaceAddr(address(this), interfaceLabel);\n\n    if (oldExtension != address(0) && removeOldExtensionRoles) {\n      if(isMinter(oldExtension)) {\n        _removeMinter(oldExtension);\n      }\n      _isController[oldExtension] = false;\n    }\n\n    ERC1820Client.setInterfaceImplementation(interfaceLabel, extension);\n    if(addMinterRoleForExtension && !isMinter(extension)) {\n      _addMinter(extension);\n    }\n    if (addControllerRoleForExtension) {\n      _isController[extension] = true;\n    }\n  }\n  /************************************************************************************************/\n\n\n  /************************************* Token migration ******************************************/\n  /**\n   * @dev Migrate contract.\n   *\n   * ===> CAUTION: DEFINITIVE ACTION\n   * \n   * This function shall be called once a new version of the smart contract has been created.\n   * Once this function is called:\n   *  - The address of the new smart contract is set in ERC1820 registry\n   *  - If the choice is definitive, the current smart contract is turned off and can never be used again\n   *\n   * @param newContractAddress Address of the new version of the smart contract.\n   * @param definitive If set to 'true' the contract is turned off definitely.\n   */\n  function _migrate(address newContractAddress, bool definitive) internal {\n    ERC1820Client.setInterfaceImplementation(ERC20_INTERFACE_NAME, newContractAddress);\n    ERC1820Client.setInterfaceImplementation(ERC1400_INTERFACE_NAME, newContractAddress);\n    if(definitive) {\n      _migrated = true;\n    }\n  }\n  /************************************************************************************************/\n\n  /************************************* Domain Aware ******************************************/\n  function domainName() public override view returns (string memory) {\n    return _name;\n  }\n\n  function domainVersion() public override view returns (string memory) {\n    return \"1\";\n  }\n  /************************************************************************************************/\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/capTable/CapTableRegistry.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./../tools/ERC1820Client.sol\";\nimport \"hardhat/console.sol\";\n\ncontract CapTableRegistry is AccessControl, ERC1820Client {\n    address[] internal _capTables;\n    mapping(address => uint256) internal _status; // 0:notUsed 1:qued 2:approved 3:declined 4:removed 5:migrated\n    mapping(address => string) internal _addressToId;\n    mapping(string => address) internal _idToAddress; // id = orgnr\n    mapping(string => address) internal _idToQuedAddress; // Hvem som helst kan queue, så derfor \"tar\" man ikke orgnr når man queuer, men nå som kun fagsystem gjør det går det fint.\n    uint256 internal _activeCapTables;\n    uint256 internal _quedCapTables;\n\n    string internal constant ERC1400_INTERFACE_NAME = \"ERC1400Token\";\n\n    event capTableQued(address indexed capTableAddress, string id);\n    event capTableApproved(address indexed capTableAddress);\n    event capTableRemoved(address indexed capTableAddress);\n    event capTableDeclined(address indexed capTableAddress, bytes32 reason);\n    event capTableMigrate(\n        address indexed from,\n        address indexed to,\n        string indexed id\n    );\n\n    bytes32 public constant FAGSYSTEM = keccak256(\"FAGSYSTEM\");\n    mapping(address => string) internal _fagsystemToDid;\n    mapping(address => address) internal _capTableAddressToFagsystem;\n\n    constructor(address fagsystemAdr, string memory fagsystemDid) {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _whitelistFagsystem(fagsystemAdr, fagsystemDid);\n    }\n\n    function whitelistFagsystem(address adr, string memory did) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _whitelistFagsystem(adr, did);\n    }\n    function _whitelistFagsystem(address adr, string memory did) internal {\n        _fagsystemToDid[adr] = did;\n        grantRole(FAGSYSTEM, adr);\n    }\n\n    function getFagsystemForCapTable(address adr) external view returns ( address) {\n        address fagsystem = _capTableAddressToFagsystem[adr];\n        return hasRole(FAGSYSTEM, fagsystem) ? fagsystem : address(0);\n    }\n\n    function getDidForFagsystem(address adr) external view returns ( string memory) {\n        return hasRole(FAGSYSTEM, adr) ? _fagsystemToDid[adr] : string(\"\");\n    }\n\n    function removeFagsystem(address adr) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        revokeRole(FAGSYSTEM, adr);\n    }\n\n    function que(address adr, string calldata id) external {\n        _queCapTable(adr, id);\n    }\n\n    function approve(address adr) external onlyRole(FAGSYSTEM) {\n        _approveCapTable(adr);\n    }\n\n    function decline(address adr, bytes32 reason) external onlyRole(FAGSYSTEM) {\n        _declineCapTable(adr, reason);\n    }\n\n    function remove(address adr) external onlyRole(FAGSYSTEM) {\n        _removeCapTable(adr);\n    }\n\n    function getActiveCount() external view returns (uint256 activeCapTables) {\n        return _activeCapTables;\n    }\n\n    function getQuedCount() external view returns (uint256 quedCapTables) {\n        return _quedCapTables;\n    }\n\n    function getList() external view returns (address[] memory capTableList) {\n        return _capTables;\n    }\n\n    function getid(address adr) external view returns (string memory id) {\n        return _addressToId[adr];\n    }\n\n    function getStatus(address adr) external view returns (uint256 status) {\n        return _status[adr];\n    }\n\n    function getAddress(string calldata orgnr)\n        external\n        view\n        returns (address capTableAddress)\n    {\n        return _idToAddress[orgnr];\n    }\n\n    function getMigrationAddress(string calldata id) external view returns (address) {\n        return _getMigrationAddress(id);\n    }\n\n    function migrateCaptable(string calldata id) external onlyRole(FAGSYSTEM) {\n        _migrateCapTable(id);\n    }\n\n    function _getMigrationAddress(string calldata id) internal view returns (address) {\n        address currentImplementation = interfaceAddr(\n            _idToAddress[id],\n            ERC1400_INTERFACE_NAME\n        );\n        return currentImplementation;\n    }\n\n    function _queCapTable(address adr, string memory id) internal {\n        require(\n            _status[adr] != 1,\n            \"Qued capTables must be declined before reQue\"\n        );\n        require(_status[adr] != 2, \"Cannot que active capTable\");\n        _capTables.push(adr);\n        _status[adr] = 1;\n        _addressToId[adr] = id;\n        _idToQuedAddress[id] = adr;\n        unchecked { _quedCapTables++; }\n        emit capTableQued(adr, id);\n    }\n\n    function _approveCapTable(address adr) internal {\n        require(_status[adr] == 1, \"Only qued capTables can be approved\");\n        _status[adr] = 2;\n        string memory id = _addressToId[adr];\n        require(_idToAddress[id] == address(0), \"id is allready in use\");\n        _idToAddress[id] = adr;\n        _idToQuedAddress[id] = address(0);\n        unchecked {\n            _quedCapTables--; \n            _activeCapTables++;\n        }\n        _capTableAddressToFagsystem[adr] = msg.sender;\n        address(adr).call(abi.encodeWithSignature(\"updateFagsystem()\"));\n        emit capTableApproved(adr);\n    }\n\n    function _declineCapTable(address adr, bytes32 reason) internal {\n        require(_status[adr] == 1, \"Only qued capTables can be declined\");\n        _status[adr] = 3;\n        unchecked { _quedCapTables--; }\n        string memory id = _addressToId[adr];\n        _idToQuedAddress[id] = address(0);\n        emit capTableDeclined(adr, reason);\n    }\n\n    function _removeCapTable(address adr) internal {\n        require(_status[adr] == 2, \"Only approved capTables can be removed\");\n        _status[adr] = 4;\n        string memory id = _addressToId[adr];\n        _idToAddress[id] = address(0);\n        unchecked { _activeCapTables--; }\n        emit capTableRemoved(adr);\n    }\n\n    function _migrateCapTable(string calldata id) internal {\n        address _address = _idToAddress[id];\n        address _migratedToAddress = _getMigrationAddress(id);\n        require(\n            _status[_address] == 2,\n            \"Only approved capTables can be removed\"\n        );\n        \n        require(\n            _migratedToAddress != _address,\n            \"Captable is not migrated in ERC1820\"\n        );\n        require(\n            _migratedToAddress != address(0),\n            \"Captable is migrated to an empty address\"\n        );\n        _status[_address] = 5;\n        _status[_address] = 2;\n        _idToAddress[id] = _migratedToAddress;\n        emit capTableMigrate(_address, _migratedToAddress, id);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/tools/ERC1820Client.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol\";\n\n\n/// Base client to interact with the registry.\ncontract ERC1820Client {\n    IERC1820Registry constant ERC1820REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n    function setInterfaceImplementation(string memory _interfaceLabel, address _implementation) internal {\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\n        ERC1820REGISTRY.setInterfaceImplementer(address(this), interfaceHash, _implementation);\n    }\n\n    function interfaceAddr(address addr, string memory _interfaceLabel) internal view returns(address) {\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\n        return ERC1820REGISTRY.getInterfaceImplementer(addr, interfaceHash);\n    }\n\n    function delegateManagement(address _newManager) internal {\n        ERC1820REGISTRY.setManager(address(this), _newManager);\n    }\n}"
    },
    "contracts/interface/ERC1820Implementer.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\n/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.8.0;\n\n\ncontract ERC1820Implementer {\n  bytes32 constant ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\"));\n\n  mapping(bytes32 => bool) internal _interfaceHashes;\n\n  function canImplementInterfaceForAddress(bytes32 interfaceHash, address /*addr*/) // Comments to avoid compilation warnings for unused variables.\n    external\n    view\n    returns(bytes32)\n  {\n    if(_interfaceHashes[interfaceHash]) {\n      return ERC1820_ACCEPT_MAGIC;\n    } else {\n      return \"\";\n    }\n  }\n\n  function _setInterface(string memory interfaceLabel) internal {\n    _interfaceHashes[keccak256(abi.encodePacked(interfaceLabel))] = true;\n  }\n\n}\n"
    },
    "contracts/roles/MinterRole.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\n/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.8.0;\n\nimport \"./Roles.sol\";\n\n/**\n * @title MinterRole\n * @dev Minters are responsible for minting new tokens.\n */\nabstract contract MinterRole {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor() {\n        _addMinter(msg.sender);\n    }\n\n    modifier onlyMinter() virtual {\n        require(isMinter(msg.sender));\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function removeMinter(address account) public onlyMinter {\n        _removeMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(msg.sender);\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}"
    },
    "contracts/IERC1400.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\n/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n// ****************** Document Management *******************\nimport \"./interface/IERC1643.sol\";\n\n/**\n * @title IERC1400 security token standard\n * @dev See https://github.com/SecurityTokenStandard/EIP-Spec/blob/master/eip/eip-1400.md\n */\ninterface IERC1400 is IERC20, IERC1643 {\n\n  // ******************* Token Information ********************\n  function balanceOfByPartition(bytes32 partition, address tokenHolder) external view returns (uint256);\n  function partitionsOf(address tokenHolder) external view returns (bytes32[] memory);\n\n  // *********************** Transfers ************************\n  function transferWithData(address to, uint256 value, bytes calldata data) external;\n  function transferFromWithData(address from, address to, uint256 value, bytes calldata data) external;\n\n  // *************** Partition Token Transfers ****************\n  function transferByPartition(bytes32 partition, address to, uint256 value, bytes calldata data) external returns (bytes32);\n  function operatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external returns (bytes32);\n  function allowanceByPartition(bytes32 partition, address owner, address spender) external view returns (uint256);\n\n  // ****************** Controller Operation ******************\n  function isControllable() external view returns (bool);\n  // function controllerTransfer(address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external; // removed because same action can be achieved with \"operatorTransferByPartition\"\n  // function controllerRedeem(address tokenHolder, uint256 value, bytes calldata data, bytes calldata operatorData) external; // removed because same action can be achieved with \"operatorRedeemByPartition\"\n\n  // ****************** Operator Management *******************\n  function authorizeOperator(address operator) external;\n  function revokeOperator(address operator) external;\n  function authorizeOperatorByPartition(bytes32 partition, address operator) external;\n  function revokeOperatorByPartition(bytes32 partition, address operator) external;\n\n  // ****************** Operator Information ******************\n  function isOperator(address operator, address tokenHolder) external view returns (bool);\n  function isOperatorForPartition(bytes32 partition, address operator, address tokenHolder) external view returns (bool);\n\n  // ********************* Token Issuance *********************\n  function isIssuable() external view returns (bool);\n  function issue(address tokenHolder, uint256 value, bytes calldata data) external;\n  function issueByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata data) external;\n\n  // ******************** Token Redemption ********************\n  function redeem(uint256 value, bytes calldata data) external;\n  function redeemFrom(address tokenHolder, uint256 value, bytes calldata data) external;\n  function redeemByPartition(bytes32 partition, uint256 value, bytes calldata data) external;\n  function operatorRedeemByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata operatorData) external;\n\n  // ******************* Transfer Validity ********************\n  // We use different transfer validity functions because those described in the interface don't allow to verify the certificate's validity.\n  // Indeed, verifying the ecrtificate's validity requires to keeps the function's arguments in the exact same order as the transfer function.\n  //\n  // function canTransfer(address to, uint256 value, bytes calldata data) external view returns (byte, bytes32);\n  // function canTransferFrom(address from, address to, uint256 value, bytes calldata data) external view returns (byte, bytes32);\n  // function canTransferByPartition(address from, address to, bytes32 partition, uint256 value, bytes calldata data) external view returns (byte, bytes32, bytes32);    \n\n  // ******************* Controller Events ********************\n  // We don't use this event as we don't use \"controllerTransfer\"\n  //   event ControllerTransfer(\n  //       address controller,\n  //       address indexed from,\n  //       address indexed to,\n  //       uint256 value,\n  //       bytes data,\n  //       bytes operatorData\n  //   );\n  //\n  // We don't use this event as we don't use \"controllerRedeem\"\n  //   event ControllerRedemption(\n  //       address controller,\n  //       address indexed tokenHolder,\n  //       uint256 value,\n  //       bytes data,\n  //       bytes operatorData\n  //   );\n\n  // ******************** Transfer Events *********************\n  event TransferByPartition(\n      bytes32 indexed fromPartition,\n      address operator,\n      address indexed from,\n      address indexed to,\n      uint256 value,\n      bytes data,\n      bytes operatorData\n  );\n\n  event ChangedPartition(\n      bytes32 indexed fromPartition,\n      bytes32 indexed toPartition,\n      uint256 value\n  );\n\n  // ******************** Operator Events *********************\n  event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n  event RevokedOperator(address indexed operator, address indexed tokenHolder);\n  event AuthorizedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\n  event RevokedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\n\n  // ************** Issuance / Redemption Events **************\n  event Issued(address indexed operator, address indexed to, uint256 value, bytes data);\n  event Redeemed(address indexed operator, address indexed from, uint256 value, bytes data);\n  event IssuedByPartition(bytes32 indexed partition, address indexed operator, address indexed to, uint256 value, bytes data, bytes operatorData);\n  event RedeemedByPartition(bytes32 indexed partition, address indexed operator, address indexed from, uint256 value, bytes operatorData);\n\n}\n\n/**\n * Reason codes - ERC-1066\n *\n * To improve the token holder experience, canTransfer MUST return a reason byte code\n * on success or failure based on the ERC-1066 application-specific status codes specified below.\n * An implementation can also return arbitrary data as a bytes32 to provide additional\n * information not captured by the reason code.\n * \n * Code\tReason\n * 0x50\ttransfer failure\n * 0x51\ttransfer success\n * 0x52\tinsufficient balance\n * 0x53\tinsufficient allowance\n * 0x54\ttransfers halted (contract paused)\n * 0x55\tfunds locked (lockup period)\n * 0x56\tinvalid sender\n * 0x57\tinvalid receiver\n * 0x58\tinvalid operator (transfer agent)\n * 0x59\t\n * 0x5a\t\n * 0x5b\t\n * 0x5a\t\n * 0x5b\t\n * 0x5c\t\n * 0x5d\t\n * 0x5e\t\n * 0x5f\ttoken meta or info\n *\n * These codes are being discussed at: https://ethereum-magicians.org/t/erc-1066-ethereum-status-codes-esc/283/24\n */"
    },
    "contracts/extensions/tokenExtensions/IERC1400TokensValidator.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\n/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.8.0;\n\n/**\n * @title IERC1400TokensValidator\n * @dev ERC1400TokensValidator interface\n */\ninterface IERC1400TokensValidator {\n  \n  /**\n   * @dev Verify if a token transfer can be executed or not, on the validator's perspective.\n   * @param token Token address.\n   * @param payload Payload of the initial transaction.\n   * @param partition Name of the partition (left empty for ERC20 transfer).\n   * @param operator Address which triggered the balance decrease (through transfer or redemption).\n   * @param from Token holder.\n   * @param to Token recipient for a transfer and 0x for a redemption.\n   * @param value Number of tokens the token holder balance is decreased by.\n   * @param data Extra information.\n   * @param operatorData Extra information, attached by the operator (if any).\n   * @return 'true' if the token transfer can be validated, 'false' if not.\n   */\n  struct ValidateData {\n    address token;\n    bytes payload;\n    bytes32 partition;\n    address operator;\n    address from;\n    address to;\n    uint value;\n    bytes data;\n    bytes operatorData;\n  }\n\n  function canValidate(ValidateData calldata data) external view returns(bool);\n\n  function tokensToValidate(\n    bytes calldata payload,\n    bytes32 partition,\n    address operator,\n    address from,\n    address to,\n    uint value,\n    bytes calldata data,\n    bytes calldata operatorData\n  ) external;\n\n}\n"
    },
    "contracts/extensions/tokenExtensions/IERC1400TokensChecker.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\n/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.8.0;\n\n/**\n * @title IERC1400TokensChecker\n * @dev IERC1400TokensChecker interface\n */\ninterface IERC1400TokensChecker {\n\n  // function canTransfer(\n  //   bytes calldata payload,\n  //   address operator,\n  //   address from,\n  //   address to,\n  //   uint256 value,\n  //   bytes calldata data,\n  //   bytes calldata operatorData\n  // ) external view returns (byte, bytes32);\n\n  function canTransferByPartition(\n    bytes calldata payload,\n    bytes32 partition,\n    address operator,\n    address from,\n    address to,\n    uint256 value,\n    bytes calldata data,\n    bytes calldata operatorData\n    ) external view returns (bytes1, bytes32, bytes32);\n\n}\n"
    },
    "contracts/extensions/userExtensions/IERC1400TokensSender.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\n/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.8.0;\n\n/**\n * @title IERC1400TokensSender\n * @dev ERC1400TokensSender interface\n */\ninterface IERC1400TokensSender {\n\n  function canTransfer(\n    bytes calldata payload,\n    bytes32 partition,\n    address operator,\n    address from,\n    address to,\n    uint value,\n    bytes calldata data,\n    bytes calldata operatorData\n  ) external view returns(bool);\n\n  function tokensToTransfer(\n    bytes calldata payload,\n    bytes32 partition,\n    address operator,\n    address from,\n    address to,\n    uint value,\n    bytes calldata data,\n    bytes calldata operatorData\n  ) external;\n\n}\n"
    },
    "contracts/extensions/userExtensions/IERC1400TokensRecipient.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\n/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.8.0;\n\n/**\n * @title IERC1400TokensRecipient\n * @dev ERC1400TokensRecipient interface\n */\ninterface IERC1400TokensRecipient {\n\n  function canReceive(\n    bytes calldata payload,\n    bytes32 partition,\n    address operator,\n    address from,\n    address to,\n    uint value,\n    bytes calldata data,\n    bytes calldata operatorData\n  ) external view returns(bool);\n\n  function tokensReceived(\n    bytes calldata payload,\n    bytes32 partition,\n    address operator,\n    address from,\n    address to,\n    uint value,\n    bytes calldata data,\n    bytes calldata operatorData\n  ) external;\n\n}\n"
    },
    "contracts/tools/DomainAware.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\n/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.8.0;\n\nabstract contract DomainAware {\n\n    // Mapping of ChainID to domain separators. This is a very gas efficient way\n    // to not recalculate the domain separator on every call, while still\n    // automatically detecting ChainID changes.\n    mapping(uint256 => bytes32) private domainSeparators;\n\n    constructor() {\n        _updateDomainSeparator();\n    }\n\n    function domainName() public virtual view returns (string memory);\n\n    function domainVersion() public virtual view returns (string memory);\n\n    function generateDomainSeparator() public view returns (bytes32) {\n        uint256 chainID = _chainID();\n\n        // no need for assembly, running very rarely\n        bytes32 domainSeparatorHash = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(domainName())), // ERC-20 Name\n                keccak256(bytes(domainVersion())), // Version\n                chainID,\n                address(this)\n            )\n        );\n\n        return domainSeparatorHash;\n    }\n\n    function domainSeparator() public returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    function _updateDomainSeparator() private returns (bytes32) {\n        uint256 chainID = _chainID();\n\n        bytes32 newDomainSeparator = generateDomainSeparator();\n\n        domainSeparators[chainID] = newDomainSeparator;\n\n        return newDomainSeparator;\n    }\n\n    // Returns the domain separator, updating it if chainID changes\n    function _domainSeparator() private returns (bytes32) {\n        bytes32 currentDomainSeparator = domainSeparators[_chainID()];\n\n        if (currentDomainSeparator != 0x00) {\n            return currentDomainSeparator;\n        }\n\n        return _updateDomainSeparator();\n    }\n\n    function _chainID() internal view returns (uint256) {\n        uint256 chainID;\n        assembly {\n            chainID := chainid()\n        }\n\n        return chainID;\n    }\n}"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC1820Registry.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the global ERC1820 Registry, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n * implementers for interfaces in this registry, as well as query support.\n *\n * Implementers may be shared by multiple accounts, and can also implement more\n * than a single interface for each account. Contracts can implement interfaces\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\n * contract.\n *\n * {IERC165} interfaces can also be queried via the registry.\n *\n * For an in-depth explanation and source code analysis, see the EIP text.\n */\ninterface IERC1820Registry {\n    /**\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n     * account is able to set interface implementers for it.\n     *\n     * By default, each account is its own manager. Passing a value of `0x0` in\n     * `newManager` will reset the manager to this initial state.\n     *\n     * Emits a {ManagerChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     */\n    function setManager(address account, address newManager) external;\n\n    /**\n     * @dev Returns the manager for `account`.\n     *\n     * See {setManager}.\n     */\n    function getManager(address account) external view returns (address);\n\n    /**\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\n     * `interfaceHash`.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     * The zero address can also be used in `implementer` to remove an old one.\n     *\n     * See {interfaceHash} to learn how these are created.\n     *\n     * Emits an {InterfaceImplementerSet} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n     * end in 28 zeroes).\n     * - `implementer` must implement {IERC1820Implementer} and return true when\n     * queried for support, unless `implementer` is the caller. See\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function setInterfaceImplementer(\n        address account,\n        bytes32 _interfaceHash,\n        address implementer\n    ) external;\n\n    /**\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n     * implementer is registered, returns the zero address.\n     *\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n     * zeroes), `account` will be queried for support of it.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     */\n    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);\n\n    /**\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n     * corresponding\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n     */\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n    /**\n     * @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n     * @param account Address of the contract for which to update the cache.\n     * @param interfaceId ERC165 interface for which to update the cache.\n     */\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n    /**\n     * @notice Checks whether a contract implements an ERC165 interface or not.\n     * If the result is not cached a direct lookup on the contract address is performed.\n     * If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n     * {updateERC165Cache} with the contract address.\n     * @param account Address of the contract to check.\n     * @param interfaceId ERC165 interface to check.\n     * @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n    /**\n     * @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n     * @param account Address of the contract to check.\n     * @param interfaceId ERC165 interface to check.\n     * @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n}\n"
    },
    "contracts/roles/Roles.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\n/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.8.0;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}"
    },
    "contracts/interface/IERC1643.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity ^0.8.0;\n\n/// @title IERC1643 Document Management (part of the ERC1400 Security Token Standards)\n/// @dev See https://github.com/SecurityTokenStandard/EIP-Spec\n\ninterface IERC1643 {\n\n    // Document Management\n    function getDocument(bytes32 _name) external view returns (string memory, bytes32, uint256);\n    function setDocument(bytes32 _name, string memory _uri, bytes32 _documentHash) external;\n    function removeDocument(bytes32 _name) external;\n    function getAllDocuments() external view returns (bytes32[] memory);\n\n    // Document Events\n    event DocumentRemoved(bytes32 indexed name, string uri, bytes32 documentHash);\n    event DocumentUpdated(bytes32 indexed name, string uri, bytes32 documentHash);\n\n}"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/capTable/CapTableFactory.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity ^0.8.0;\n\nimport \"./CapTable.sol\";\nimport \"./CapTableRegistry.sol\";\n\ncontract CapTableFactory {\n    CapTableRegistry internal _capTableRegistry;\n    uint256 internal _defaultGranularity;\n    address internal _defaultOwner;\n    bytes32[] internal _defaultPartitions;\n    bytes32 internal _defaultIssueData;\n\n    constructor(\n        address capTableRegistryAddress,\n        address defaultOwner,\n        bytes32 defaultPartition\n    ) {\n        _defaultGranularity = 1;\n        _defaultOwner = defaultOwner;\n        _defaultPartitions.push(defaultPartition);\n        _capTableRegistry = CapTableRegistry(capTableRegistryAddress);\n    }\n\n    function getCapTableRegistryAddress()\n        public\n        view\n        returns (address capTableRegistryAddress)\n    {\n        return address(_capTableRegistry);\n    }\n\n    function createCapTable(\n        string calldata name,\n        string calldata orgnr,\n        address[] calldata to,\n        uint256[] calldata value\n    ) external {\n        bytes32[] memory defaultPartitions = _defaultPartitions;\n        bytes memory defaultIssueData = abi.encodePacked(_defaultIssueData);\n\n        address[] memory controller = new address[](1);\n        controller[0] = msg.sender; // Fagsystem is controller.\n\n        CapTable capTable = new CapTable(\n            name,\n            orgnr,\n            _defaultGranularity,\n            controller,\n            defaultPartitions,\n            address(_capTableRegistry)\n        );\n\n        _capTableRegistry.que(address(capTable), orgnr);\n\n        require(to.length > 0, \"Must issue on deploy\"); // REVIEW: Just a convinience thing for the graph.\n        for (uint256 i = 0; i < to.length; ) {\n            capTable.issueByPartition(\n                _defaultPartitions[0], // Cant accept partitions also as it would trigger stack to deep.\n                to[i],\n                value[i],\n                defaultIssueData\n            );\n\n            unchecked {\n                ++i;\n            } // Avoids safemath to save gas\n        }\n        capTable.addMinter(msg.sender); // Fagsystem is minter\n        capTable.transferOwnership(_defaultOwner); // BR is owner\n    }\n}\n"
    },
    "contracts/tools/Swaps.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\n/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport \"./ERC1820Client.sol\";\nimport \"../interface/ERC1820Implementer.sol\";\n\nimport \"../extensions/userExtensions/IERC1400TokensRecipient.sol\";\nimport \"../interface/IERC20HoldableToken.sol\";\nimport \"../interface/IHoldableERC1400TokenExtension.sol\";\n\nimport \"../IERC1400.sol\";\n\n\n/**\n * @title Swaps\n * @dev Delivery-Vs-Payment contract for investor-to-investor token trades.\n * @dev Intended usage:\n * The purpose of the contract is to allow secure token transfers/exchanges between 2 stakeholders (called holder1 and holder2).\n * From now on, an operation in the Swaps smart contract (transfer/exchange) is called a trade.\n * Depending on the type of trade, one/multiple token transfers will be executed.\n *\n * The simplified workflow is the following:\n * 1) A trade request is created in the Swaps smart contract, it specifies:\n *  - The token holder(s) involved in the trade\n *  - The trade executer (optional)\n *  - An expiration date\n *  - Details on the first token (address, requested amount, standard)\n *  - Details on the second token (address, requested amount, standard)\n *  - Whether the tokens need to be escrowed in the Swaps contract or not\n *  - The current status of the trade (pending / executed / forced / cancelled)\n * 2) The trade is accepted by both token holders\n * 3) [OPTIONAL] The trade is approved by token controllers (only if requested by tokens controllers)\n * 4) The trade is executed (either by the executer in case the executer is specified, or by anyone)\n *\n * STANDARD-AGNOSTIC:\n * The Swaps smart contract is standard-agnostic, it supports ETH, ERC20, ERC721, ERC1400.\n * The advantage of using an ERC1400 token is to leverages its hook property, thus requiring ONE single\n * transaction (operatorTransferByPartition()) to send tokens to the Swaps smart contract instead of TWO\n * with the ERC20 token standard (approve() + transferFrom()).\n *\n * OFF-CHAIN PAYMENT:\n * The contract can be used as escrow contract while waiting for an off-chain payment.\n * Once payment is received off-chain, the token sender realeases the tokens escrowed in\n * the Swaps contract to deliver them to the recipient.\n *\n * ESCROW VS SWAP MODE:\n * In case escrow mode is selected, tokens need to be escrowed in Swaps smart contract\n * before the trade can occur.\n * In case swap mode is selected, tokens are not escrowed in the Swaps. Instead, the Swaps\n * contract is only allowed to transfer tokens ON BEHALF of their owners. When trade is\n * executed, an atomic token swap occurs.\n *\n * EXPIRATION DATE:\n * The trade can be cancelled by both parties in case expiration date is passed.\n *\n * CLAIMS:\n * The executer has the ability to force or cancel the trade.\n * In case of disagreement/missing payment, both parties can contact the \"executer\"\n * of the trade to deposit a claim and solve the issue.\n *\n * MARKETPLACE:\n * The contract can be used as a token marketplace. Indeed, when trades are created\n * without specifying the recipient address, anyone can purchase them by sending\n * the requested payment in exchange.\n *\n * PRICE ORACLES:\n * When price oracles are defined, those can define the price at which trades need to be executed.\n * This feature is particularly useful for assets with NAV (net asset value).\n *\n */\ncontract Swaps is Ownable, ERC1820Client, IERC1400TokensRecipient, ERC1820Implementer {\n  string constant internal DELIVERY_VS_PAYMENT = \"DeliveryVsPayment\";\n  string constant internal ERC1400_TOKENS_RECIPIENT = \"ERC1400TokensRecipient\";\n\n  uint256 constant internal SECONDS_IN_MONTH = 86400 * 30;\n  uint256 constant internal SECONDS_IN_WEEK = 86400 * 7;\n\n  bytes32 constant internal TRADE_PROPOSAL_FLAG = 0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc;\n  bytes32 constant internal TRADE_ACCEPTANCE_FLAG = 0xdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd;\n\n  bytes32 constant internal BYPASS_ACTION_FLAG = 0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;\n\n  bytes32 constant internal ALL_PARTITIONS = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n  enum Standard {OffChain, ETH, ERC20, ERC721, ERC1400}\n\n  enum State {Undefined, Pending, Executed, Forced, Cancelled}\n\n  enum TradeType {Allowance, Hold, Escrow}\n\n  enum Holder {Holder1, Holder2}\n    \n  string internal constant ERC1400_TOKENS_VALIDATOR = \"ERC1400TokensValidator\";\n\n  /**\n  @dev Include token events so they can be parsed by Ethereum clients from the settlement transactions.\n    */\n  // Holdable\n  event ExecutedHold(\n      address indexed token,\n      bytes32 indexed holdId,\n      bytes32 lockPreimage,\n      address recipient\n  );\n  // ERC20\n  event Transfer(address indexed from, address indexed to, uint256 tokens);\n  // ERC1400\n  event TransferByPartition(\n      bytes32 indexed fromPartition,\n      address operator,\n      address indexed from,\n      address indexed to,\n      uint256 value,\n      bytes data,\n      bytes operatorData\n  );\n  event CreateNote(\n      address indexed owner,\n      bytes32 indexed noteHash,\n      bytes metadata\n  );\n  event DestroyNote(address indexed owner, bytes32 indexed noteHash);\n\n  struct UserTradeData {\n    address tokenAddress;\n    uint256 tokenValue;\n    bytes32 tokenId;\n    Standard tokenStandard;\n    bool accepted;\n    bool approved;\n    TradeType tradeType;\n  }\n  \n  /**\n   * @dev Input data for the requestTrade function\n   * @param holder1 Address of the first token holder.\n   * @param holder2 Address of the second token holder.\n   * @param executer Executer of the trade.\n   * @param expirationDate Expiration date of the trade.\n   * @param tokenAddress1 Address of the first token smart contract.\n   * @param tokenValue1 Amount of tokens to send for the first token.\n   * @param tokenId1 ERC721ID/holdId/partition of the first token.\n   * @param tokenStandard1 Standard of the first token (ETH | ERC20 | ERC721 | ERC1400).\n   * @param tokenAddress2 Address of the second token smart contract.\n   * @param tokenValue2 Amount of tokens to send for the second token.\n   * @param tokenId2 ERC721ID/holdId/partition of the second token.\n   * @param tokenStandard2 Standard of the second token (ETH | ERC20 | ERC721 | ERC1400).\n   * @param tradeType Indicates whether or not tokens shall be escrowed in the Swaps contract before the trade.\n   */\n  struct TradeRequestInput {\n    address holder1;\n    address holder2;\n    address executer; // Set to address(0) if no executer is required for the trade\n    uint256 expirationDate;\n    address tokenAddress1;\n    uint256 tokenValue1;\n    bytes32 tokenId1;\n    Standard tokenStandard1;\n    address tokenAddress2; // Set to address(0) if no token is expected in return (for example in case of an off-chain payment)\n    uint256 tokenValue2;\n    bytes32 tokenId2;\n    Standard tokenStandard2;\n    TradeType tradeType1;\n    TradeType tradeType2;\n    uint256 settlementDate;\n  }\n\n  struct Trade {\n    address holder1;\n    address holder2;\n    address executer;\n    uint256 expirationDate;\n    uint256 settlementDate;\n    UserTradeData userTradeData1;\n    UserTradeData userTradeData2;\n    State state;\n  }\n\n  // Index of most recent trade request.\n  uint256 internal _index;\n\n  // Mapping from index to trade requests.\n  mapping(uint256 => Trade) internal _trades;\n\n  // Mapping from token to price oracles.\n  mapping(address => address[]) internal _priceOracles;\n\n  // Mapping from (token, operator) to price oracle status.\n  mapping(address => mapping(address => bool)) internal _isPriceOracle;\n\n  // Mapping from (token1, token2) to price ownership.\n  mapping(address => mapping(address => bool)) internal _priceOwnership;\n\n  // Mapping from (token1, token2, tokenId1, tokenId2) to price.\n  mapping(address => mapping (address => mapping (bytes32 =>  mapping (bytes32 => uint256)))) internal _tokenUnitPricesByPartition;\n\n  // Indicate whether Swaps smart contract is owned or not (for instance by an exchange, etc.).\n  bool internal _ownedContract;\n\n  // Array of trade execcuters.\n  address[] internal _tradeExecuters;\n\n  // Mapping from operator to trade executer status.\n  mapping(address => bool) internal _isTradeExecuter;\n\n  // Mapping from token to token controllers.\n  mapping(address => address[]) internal _tokenControllers;\n\n  // Mapping from (token, operator) to token controller status.\n  mapping(address => mapping(address => bool)) internal _isTokenController;\n\n  // Mapping from token to variable price start date.\n  mapping(address => uint256) internal _variablePriceStartDate;\n\n  /**\n   * @dev Modifier to verify if sender is a token controller.\n   */\n  modifier onlyTokenController(address tokenAddress) {\n    require(\n      msg.sender == Ownable(tokenAddress).owner() ||\n      _isTokenController[tokenAddress][msg.sender],\n      \"Sender is not a token controller.\"\n    );\n    _;\n  }\n\n  /**\n   * @dev Modifier to verify if sender is a price oracle.\n   */\n  modifier onlyPriceOracle(address tokenAddress) {\n    require(_checkPriceOracle(tokenAddress, msg.sender), \"Sender is not a price oracle.\");\n    _;\n  }\n\n  /**\n   * [Swaps CONSTRUCTOR]\n   * @dev Initialize Swaps + register\n   * the contract implementation in ERC1820Registry.\n   */\n  constructor(bool owned) {\n    ERC1820Implementer._setInterface(DELIVERY_VS_PAYMENT);\n    ERC1820Implementer._setInterface(ERC1400_TOKENS_RECIPIENT);\n    setInterfaceImplementation(ERC1400_TOKENS_RECIPIENT, address(this));\n\n    _ownedContract = owned;\n\n    if(_ownedContract) {\n      address[] memory initialTradeExecuters = new address[] (1);\n      initialTradeExecuters[0] = msg.sender;\n      _setTradeExecuters(initialTradeExecuters);\n    }\n  }\n\n  /**\n   * [ERC1400TokensRecipient INTERFACE (1/2)]\n   * @dev Indicate whether or not the Swaps contract can receive the tokens or not. [USED FOR ERC1400 TOKENS ONLY]\n   * @param data Information attached to the token transfer.\n   * @param operatorData Information attached to the Swaps transfer, by the operator.\n   * @return 'true' if the Swaps contract can receive the tokens, 'false' if not.\n   */\n  function canReceive(bytes calldata, bytes32, address, address, address, uint, bytes calldata  data, bytes calldata operatorData) external override view returns(bool) {\n    return(_canReceive(data, operatorData));\n  }\n\n  /**\n   * [ERC1400TokensRecipient INTERFACE (2/2)]\n   * @dev Hook function executed when tokens are sent to the Swaps contract. [USED FOR ERC1400 TOKENS ONLY]\n   * @param partition Name of the partition.\n   * @param from Token holder.\n   * @param to Token recipient.\n   * @param value Number of tokens to transfer.\n   * @param data Information attached to the token transfer.\n   * @param operatorData Information attached to the Swaps transfer, by the operator.\n   */\n  function tokensReceived(bytes calldata, bytes32 partition, address, address from, address to, uint value, bytes memory data, bytes calldata operatorData) external override {\n    require(interfaceAddr(msg.sender, \"ERC1400Token\") == msg.sender, \"55\"); // funds locked (lockup period)\n\n    require(to == address(this), \"50\"); // 0x50\ttransfer failure\n    require(_canReceive(data, operatorData), \"57\"); // 0x57\tinvalid receiver\n\n    bytes32 flag = _getTradeFlag(data);\n    if(flag == TRADE_PROPOSAL_FLAG) {\n      address recipient;\n      address executor;\n      uint256 expirationDate;\n      uint256 settlementDate;\n      assembly {\n        recipient:= mload(add(data, 64))\n        executor:= mload(add(data, 96))\n        expirationDate:= mload(add(data, 128))\n        settlementDate:= mload(add(data, 160))\n      }\n      // Token data: < 1: address > < 2: amount > < 3: id/partition > < 4: standard > < 5: accepted > < 6: approved >\n      UserTradeData memory _tradeData1 = UserTradeData(msg.sender, value, partition, Standard.ERC1400, true, false, TradeType.Escrow);\n      UserTradeData memory _tokenData2 = _getTradeTokenData(data);\n\n      _requestTrade(\n        from,\n        recipient,\n        executor,\n        expirationDate,\n        settlementDate,\n        _tradeData1,\n        _tokenData2\n      );\n\n    } else if (flag == TRADE_ACCEPTANCE_FLAG) {\n      uint256 index;\n      bytes32 preimage = bytes32(0);\n      assembly {\n        index:= mload(add(data, 64))\n      }\n      if (data.length == 96) {\n        //This field is optional\n        //If the data's length does not include the preimage\n        //then return an empty preimage\n        //canReceive accepts both data lengths\n        assembly {\n          preimage:= mload(add(data, 96))\n        }\n      }\n      Trade storage trade = _trades[index];\n\n      UserTradeData memory selectedUserTradeData = (from == trade.holder1) ? trade.userTradeData1 : trade.userTradeData2;\n      require(msg.sender == selectedUserTradeData.tokenAddress, \"Wrong token sent\");\n      require(partition == selectedUserTradeData.tokenId, \"Tokens of the wrong partition sent\");\n      require(Standard.ERC1400 == selectedUserTradeData.tokenStandard, \"Tokens of the wrong standard sent\");\n\n      _acceptTrade(index, from, 0, value, preimage);         \n    }\n  }\n\n  /**\n   * @dev Create a new trade request in the Swaps smart contract.\n   * @param inputData The input for this function\n   */\n  function requestTrade(TradeRequestInput calldata inputData, bytes32 preimage)\n    external\n    payable\n  {\n    _requestTrade(\n      inputData.holder1,\n      inputData.holder2,\n      inputData.executer,\n      inputData.expirationDate,\n      inputData.settlementDate,\n      UserTradeData(inputData.tokenAddress1, inputData.tokenValue1, inputData.tokenId1, inputData.tokenStandard1, false, false, inputData.tradeType1),\n      UserTradeData(inputData.tokenAddress2, inputData.tokenValue2, inputData.tokenId2, inputData.tokenStandard2, false, false, inputData.tradeType2)\n    );\n\n    if(msg.sender == inputData.holder1 || msg.sender == inputData.holder2) {\n      _acceptTrade(_index, msg.sender, msg.value, 0, preimage);\n    }\n  }\n\n  /**\n   * @dev Create a new trade request in the Swaps smart contract.\n   * @param holder1 Address of the first token holder.\n   * @param holder2 Address of the second token holder.\n   * @param executer Executer of the trade.\n   * @param expirationDate Expiration date of the trade.\n   * @param userTradeData1 Encoded pack of variables for token1 (address, amount, id/partition, standard, accepted, approved).\n   * @param userTradeData2 Encoded pack of variables for token2 (address, amount, id/partition, standard, accepted, approved).\n   */\n  function _requestTrade(\n    address holder1,\n    address holder2,\n    address executer, // Set to address(0) if no executer is required for the trade\n    uint256 expirationDate,\n    uint256 settlementDate,\n    UserTradeData memory userTradeData1,\n    UserTradeData memory userTradeData2\n  ) \n    internal\n  {\n    if(userTradeData1.tokenStandard == Standard.ETH) {\n      require(userTradeData1.tradeType == TradeType.Escrow, \"Ether trades need to be of type Escrow\");\n    }\n\n    if(userTradeData2.tokenStandard == Standard.ETH) {\n      require(userTradeData2.tradeType == TradeType.Escrow, \"Ether trades need to be of type Escrow\");\n    }\n\n    if (userTradeData1.tradeType == TradeType.Hold) {\n      require(userTradeData1.tokenStandard == Standard.ERC20 || userTradeData1.tokenStandard == Standard.ERC1400, \"Invalid token standard for hold trade type\");\n      require(userTradeData1.tokenId != bytes32(0), \"No holdId specified\");\n    }\n    \n    if (userTradeData2.tradeType == TradeType.Hold) {\n      require(userTradeData2.tokenStandard == Standard.ERC20 || userTradeData2.tokenStandard == Standard.ERC1400, \"Invalid token standard for hold trade type\");\n      require(userTradeData2.tokenId != bytes32(0), \"No holdId specified\");\n    }\n\n    if(_ownedContract) {\n      require(_isTradeExecuter[executer], \"Trade executer needs to belong to the list of allowed trade executers\");\n    }\n\n    require(holder1 != address(0), \"A trade can not be created with the zero address\");\n    \n    _index++;\n\n    uint256 _expirationDate = (expirationDate > block.timestamp) ? expirationDate : (block.timestamp + SECONDS_IN_MONTH);\n\n    _trades[_index] = Trade({\n      holder1: holder1,\n      holder2: holder2,\n      executer: executer,\n      expirationDate: _expirationDate,\n      settlementDate: settlementDate,\n      userTradeData1: userTradeData1,\n      userTradeData2: userTradeData2,\n      state: State.Pending\n    });\n  }\n\n  /**\n   * @dev Accept a given trade (+ potentially escrow tokens).\n   * @param index Index of the trade to be accepted.\n   */\n  function acceptTrade(uint256 index, bytes32 preimage) external payable {\n    _acceptTrade(index, msg.sender, msg.value, 0, preimage);\n  }\n\n  /**\n   * @dev Accept a given trade (+ potentially escrow tokens).\n   * @param index Index of the trade to be accepted.\n   * @param sender Message sender\n   * @param ethValue Value sent (only used for ETH)\n   * @param erc1400TokenValue Value sent (only used for ERC1400)\n   */\n  function _acceptTrade(uint256 index, address sender, uint256 ethValue, uint256 erc1400TokenValue, bytes32 preimage) internal {\n    Trade storage trade = _trades[index];\n    require(trade.state == State.Pending, \"Trade is not pending\");\n\n    address recipientHolder;\n    if(sender == trade.holder1) {\n      recipientHolder = trade.holder2;\n    } else if(sender == trade.holder2) {\n      recipientHolder = trade.holder1;\n    } else if(trade.holder2 == address(0)) {\n      trade.holder2 = sender;\n      recipientHolder = trade.holder1;\n    } else {\n      revert(\"Only registered holders can accept a trade\");\n    }\n\n    UserTradeData memory selectedUserTradeData = (sender == trade.holder1) ? trade.userTradeData1 : trade.userTradeData2;\n\n    require(!selectedUserTradeData.accepted, \"Trade already accepted by the holder\");\n\n    if(selectedUserTradeData.tradeType == TradeType.Escrow) {\n      if(selectedUserTradeData.tokenStandard == Standard.ETH) {\n        require(ethValue == selectedUserTradeData.tokenValue, \"Amount of ETH is not correct\");\n      } else if(selectedUserTradeData.tokenStandard == Standard.ERC20) {        \n        IERC20(selectedUserTradeData.tokenAddress).transferFrom(sender, address(this), selectedUserTradeData.tokenValue);\n      } else if(selectedUserTradeData.tokenStandard == Standard.ERC721) {\n        IERC721(selectedUserTradeData.tokenAddress).transferFrom(sender, address(this), uint256(selectedUserTradeData.tokenId));\n      } else if((selectedUserTradeData.tokenStandard == Standard.ERC1400) && erc1400TokenValue == 0){\n        IERC1400(selectedUserTradeData.tokenAddress).operatorTransferByPartition(selectedUserTradeData.tokenId, sender, address(this), selectedUserTradeData.tokenValue, abi.encodePacked(BYPASS_ACTION_FLAG), abi.encodePacked(BYPASS_ACTION_FLAG));\n      } else if((selectedUserTradeData.tokenStandard == Standard.ERC1400) && erc1400TokenValue != 0){\n        require(erc1400TokenValue == selectedUserTradeData.tokenValue, \"Amount of ERC1400 tokens is not correct\");\n      }\n    } else if (selectedUserTradeData.tradeType == TradeType.Hold) {\n        require(_holdExists(sender, recipientHolder, selectedUserTradeData), \"Hold needs to be provided in token smart contract first\");\n    } else { // trade.tradeType == TradeType.Allowance\n        require(_allowanceIsProvided(sender, selectedUserTradeData), \"Allowance needs to be provided in token smart contract first\");\n    }\n\n    if(sender == trade.holder1) {\n      trade.userTradeData1.accepted = true;\n    } else {\n      trade.userTradeData2.accepted = true;\n    }\n\n    \n    bool settlementDatePassed = block.timestamp >= trade.settlementDate;\n    bool tradeApproved = getTradeApprovalStatus(index);\n    //Execute both holds of a trade if the following conditions are met\n    //* There is no executer set. Only the executer should execute transactions if one is defined\n    //* Both trade types are holds\n    //* The trade is approved. Token controllers must pre-approve this trade. This is also true if the token has no token controllers\n    //* If both holds exist according to _holdExists\n    //* If the current block timestamp is after the settlement date\n    if (settlementDatePassed && trade.executer == address(0) && trade.userTradeData1.tradeType == TradeType.Hold && trade.userTradeData2.tradeType == TradeType.Hold && tradeApproved) {\n      //we know selectedUserTradeData has a hold that exists, so check the other one\n      UserTradeData memory otherUserTradeData = (sender == trade.holder1) ? trade.userTradeData2 : trade.userTradeData1;\n      if (_holdExists(recipientHolder, sender, otherUserTradeData)) {\n        //If both holds exist, then mark both sides of trade as accepted\n        //Next if will execute trade\n        trade.userTradeData1.accepted = true;\n        trade.userTradeData2.accepted = true;\n      }\n    }\n\n    if(\n      trade.executer == address(0) && getTradeAcceptanceStatus(index) && tradeApproved && settlementDatePassed) {\n      _executeTrade(index, preimage);\n    }\n  }\n  /**\n   * @dev Verify if a trade has been accepted by the token holders.\n   *\n   * The trade needs to be accepted by both parties (token holders) before it gets executed.\n   *\n   * @param index Index of the trade to be accepted.\n   */\n  function getTradeAcceptanceStatus(uint256 index) public view returns(bool) {\n    Trade storage trade = _trades[index];\n\n    if(trade.state == State.Pending) {\n      if(trade.userTradeData1.tradeType == TradeType.Allowance && !_allowanceIsProvided(trade.holder1, trade.userTradeData1)) {\n        return false;\n      }\n      if(trade.userTradeData2.tradeType == TradeType.Allowance && !_allowanceIsProvided(trade.holder2, trade.userTradeData2)) {\n        return false;\n      }\n    }\n\n    return(trade.userTradeData1.accepted && trade.userTradeData2.accepted);\n  }\n\n  /**\n   * @dev Verify if a token allowance has been provided in token smart contract.\n   *\n   * @param sender Address of the sender.\n   * @param userTradeData Encoded pack of variables for the token (address, amount, id/partition, standard, accepted, approved).\n   */\n  function _allowanceIsProvided(address sender, UserTradeData memory userTradeData) internal view returns(bool) {\n    address tokenAddress = userTradeData.tokenAddress;\n    uint256 tokenValue = userTradeData.tokenValue;\n    bytes32 tokenId = userTradeData.tokenId;\n    Standard tokenStandard = userTradeData.tokenStandard;\n\n    if(tokenStandard == Standard.ERC20) {        \n      return(IERC20(tokenAddress).allowance(sender, address(this)) >= tokenValue);\n    } else if(tokenStandard == Standard.ERC721) {\n      return(IERC721(tokenAddress).getApproved(uint256(tokenId)) == address(this));\n    } else if(tokenStandard == Standard.ERC1400){\n      return(IERC1400(tokenAddress).allowanceByPartition(tokenId, sender, address(this)) >= tokenValue);\n    }\n\n    return true;\n  }\n\n  function approveTrade(uint256 index, bool approved) external {\n    approveTradeWithPreimage(index, approved, 0);\n  }\n\n  /**\n   * @dev Approve a trade (if the tokens involved in the trade are controlled)\n   *\n   * This function can only be called by a token controller of one of the tokens involved in the trade.\n   *\n   * Indeed, when a token smart contract is controlled by an owner, the owner can decide to open the\n   * secondary market by:\n   *  - Allowlisting the Swaps smart contract\n   *  - Setting \"token controllers\" in the Swaps smart contract, in order to approve all the trades made with his token\n   *\n   * @param index Index of the trade to be executed.\n   * @param approved 'true' if trade is approved, 'false' if not.\n   */\n  function approveTradeWithPreimage(uint256 index, bool approved, bytes32 preimage) public {\n    Trade storage trade = _trades[index];\n    require(trade.state == State.Pending, \"Trade is not pending\");\n\n    require(_isTokenController[trade.userTradeData1.tokenAddress][msg.sender] || _isTokenController[trade.userTradeData2.tokenAddress][msg.sender], \"Only token controllers of involved tokens can approve a trade\");\n\n    if(_isTokenController[trade.userTradeData1.tokenAddress][msg.sender]) {\n      trade.userTradeData1.approved = approved;\n    }\n    \n    if(_isTokenController[trade.userTradeData2.tokenAddress][msg.sender]) {\n      trade.userTradeData2.approved = approved;\n    }\n\n    if(trade.executer == address(0) && getTradeAcceptanceStatus(index) && getTradeApprovalStatus(index)) {\n      _executeTrade(index, preimage);\n    }\n  }\n\n  /**\n   * @dev Verify if a trade has been approved by the token controllers.\n   *\n   * In case a given token has token controllers, those need to validate the trade before it gets executed.\n   *\n   * @param index Index of the trade to be approved.\n   */\n  function getTradeApprovalStatus(uint256 index) public view returns(bool) {\n    Trade storage trade = _trades[index];\n\n    if(_tokenControllers[trade.userTradeData1.tokenAddress].length != 0 && !trade.userTradeData1.approved) {\n      return false;\n    }\n\n    if(_tokenControllers[trade.userTradeData2.tokenAddress].length != 0 && !trade.userTradeData2.approved) {\n      return false;\n    }\n\n    return true;\n  }\n\n  function executeTrade(uint256 index) external {\n    executeTradeWithPreimage(index, 0);\n  }\n\n  /**\n   * @dev Execute a trade in the Swaps contract if possible (e.g. if tokens have been esccrowed, in case it is required).\n   *\n   * This function can only be called by the executer specified at trade creation.\n   * If no executer is specified, the trade can be launched by anyone.\n   *\n   * @param index Index of the trade to be executed.\n   */\n  function executeTradeWithPreimage(uint256 index, bytes32 preimage) public {\n    Trade storage trade = _trades[index];\n    require(trade.state == State.Pending, \"Trade is not pending\");\n\n    if(trade.executer != address(0)) {\n      require(msg.sender == trade.executer, \"Trade can only be executed by executer defined at trade creation\");\n    }\n\n    require(block.timestamp >= trade.settlementDate, \"Trade can only be executed on or after settlement date\");\n\n    require(getTradeAcceptanceStatus(index), \"Trade has not been accepted by all token holders yet\");\n    \n    require(getTradeApprovalStatus(index), \"Trade has not been approved by all token controllers yet\");\n\n    _executeTrade(index, preimage);\n  }\n\n  /**\n   * @dev Execute a trade in the Swaps contract if possible (e.g. if tokens have been esccrowed, in case it is required).\n   * @param index Index of the trade to be executed.\n   */\n  function _executeTrade(uint256 index, bytes32 preimage) internal {\n    Trade storage trade = _trades[index];\n\n    uint256 price = getPrice(index);\n\n    uint256 tokenValue1 = trade.userTradeData1.tokenValue;\n    uint256 tokenValue2 = trade.userTradeData2.tokenValue;\n\n    if(price == tokenValue2) {\n      _transferUsersTokens(index, Holder.Holder1, tokenValue1, false, preimage);\n      _transferUsersTokens(index, Holder.Holder2, tokenValue2, false, preimage);\n    } else {\n      //Holds cannot move a specific amount of tokens\n      //So require that if the price is less than the value\n      //that the trade is not a hold trade\n      require(price <= tokenValue2 && trade.userTradeData2.tradeType != TradeType.Hold, \"Price is higher than amount escrowed/authorized\");\n      _transferUsersTokens(index, Holder.Holder1, tokenValue1, false, preimage);\n      _transferUsersTokens(index, Holder.Holder2, price, false, preimage);\n      if(trade.userTradeData2.tradeType == TradeType.Escrow) {\n        _transferUsersTokens(index, Holder.Holder2, tokenValue2 - price, true, preimage);\n      }\n    }\n    trade.state = State.Executed;\n\n  }\n\n  function forceTrade(uint256 index) external {\n    forceTradeWithPreimage(index, 0);\n  }\n\n  /**\n   * @dev Force a trade execution in the Swaps contract by transferring tokens back to their target recipients.\n   * @param index Index of the trade to be forced.\n   */\n  function forceTradeWithPreimage(uint256 index, bytes32 preimage) public {\n    Trade storage trade = _trades[index];\n    require(trade.state == State.Pending, \"Trade is not pending\");\n    \n    address tokenAddress1 = trade.userTradeData1.tokenAddress;\n    uint256 tokenValue1 = trade.userTradeData1.tokenValue;\n    bool accepted1 = trade.userTradeData1.accepted;\n\n    address tokenAddress2 = trade.userTradeData2.tokenAddress;\n    uint256 tokenValue2 = trade.userTradeData2.tokenValue;\n    bool accepted2 = trade.userTradeData2.accepted;\n\n    require(!(accepted1 && accepted2), \"executeTrade can be called\");\n    require(_tokenControllers[tokenAddress1].length == 0 && _tokenControllers[tokenAddress2].length == 0, \"Trade can not be forced if tokens have controllers\");\n\n    if(trade.executer != address(0)) {\n      require(msg.sender == trade.executer, \"Sender is not allowed to force trade (0)\");\n    } else if(accepted1) {\n      require(msg.sender == trade.holder1, \"Sender is not allowed to force trade (1)\");\n    } else if(accepted2) {\n      require(msg.sender == trade.holder2, \"Sender is not allowed to force trade (2)\");\n    } else {\n      revert(\"Trade can't be forced as tokens are not available so far\");\n    }\n\n    if(accepted1) {\n      _transferUsersTokens(index, Holder.Holder1, tokenValue1, false, preimage);\n    }\n\n    if(accepted2) {\n      _transferUsersTokens(index, Holder.Holder2, tokenValue2, false, preimage);\n    }\n\n    trade.state = State.Forced;\n  }\n\n  /**\n   * @dev Cancel a trade execution in the Swaps contract by transferring tokens back to their initial owners.\n   * @param index Index of the trade to be cancelled.\n   */\n  function cancelTrade(uint256 index) external {\n    Trade storage trade = _trades[index];\n    require(trade.state == State.Pending, \"Trade is not pending\");\n\n    uint256 tokenValue1 = trade.userTradeData1.tokenValue;\n    bool accepted1 = trade.userTradeData1.accepted;\n\n    uint256 tokenValue2 = trade.userTradeData2.tokenValue;\n    bool accepted2 = trade.userTradeData2.accepted;\n\n    if(accepted1 && accepted2) {\n      require(msg.sender == trade.executer || (block.timestamp >= trade.expirationDate && (msg.sender == trade.holder1 || msg.sender == trade.holder2) ), \"Sender is not allowed to cancel trade (0)\");\n      if(trade.userTradeData1.tradeType == TradeType.Escrow) {\n        _transferUsersTokens(index, Holder.Holder1, tokenValue1, true, bytes32(0));\n      }\n      if(trade.userTradeData2.tradeType == TradeType.Escrow) {\n        _transferUsersTokens(index, Holder.Holder2, tokenValue2, true, bytes32(0));\n      }\n    } else if(accepted1) {\n      require(msg.sender == trade.executer || (block.timestamp >= trade.expirationDate && msg.sender == trade.holder1), \"Sender is not allowed to cancel trade (1)\");\n      if(trade.userTradeData1.tradeType == TradeType.Escrow) {\n        _transferUsersTokens(index, Holder.Holder1, tokenValue1, true, bytes32(0));\n      }\n    } else if(accepted2) {\n      require(msg.sender == trade.executer || (block.timestamp >= trade.expirationDate && msg.sender == trade.holder2), \"Sender is not allowed to cancel trade (2)\");\n      if(trade.userTradeData2.tradeType == TradeType.Escrow) {\n        _transferUsersTokens(index, Holder.Holder2, tokenValue2, true, bytes32(0));\n      }\n    } else {\n      require(msg.sender == trade.executer || msg.sender == trade.holder1 || msg.sender == trade.holder2, \"Sender is not allowed to cancel trade (3)\");\n    }\n\n    trade.state = State.Cancelled;\n  }\n\n  function _transferUsersTokens(uint256 index, Holder holder, uint256 value, bool revertTransfer, bytes32 preimage) internal { \n    Trade storage trade = _trades[index];\n\n    UserTradeData memory senderUserTradeData = (holder == Holder.Holder1) ? trade.userTradeData1 : trade.userTradeData2;\n\n    TradeType tokenTradeType = senderUserTradeData.tradeType;\n\n    if (tokenTradeType == TradeType.Hold) {\n      _executeHoldOnUsersTokens(index, holder, value, revertTransfer, preimage);\n    } else {\n      _executeTransferOnUsersTokens(index, holder, value, revertTransfer);\n    }\n  }\n\n  function _executeHoldOnUsersTokens(uint256 index, Holder holder, uint256, bool, bytes32 preimage) internal { \n    Trade storage trade = _trades[index];\n\n    address sender = (holder == Holder.Holder1) ? trade.holder1 : trade.holder2;\n    address recipient = (holder == Holder.Holder1) ? trade.holder2 : trade.holder1;\n    UserTradeData memory senderUserTradeData = (holder == Holder.Holder1) ? trade.userTradeData1 : trade.userTradeData2;\n\n    require(block.timestamp <= trade.expirationDate, \"Expiration date is past\");\n\n    address tokenAddress = senderUserTradeData.tokenAddress;\n    bytes32 tokenId = senderUserTradeData.tokenId;\n    Standard tokenStandard = senderUserTradeData.tokenStandard;\n\n    require(tokenStandard == Standard.ERC20 || tokenStandard == Standard.ERC1400, \"Token standard must be holdable\");\n\n    require(_holdExists(sender, recipient, senderUserTradeData), \"Hold must exist\");\n\n    _executeHold(tokenAddress, tokenId, tokenStandard, preimage, recipient);\n  }\n\n  /**\n   * @dev Internal function to transfer tokens to their recipient by taking the token standard into account.\n   * @param index Index of the trade the token transfer is execcuted for.\n   * @param holder Sender of the tokens (currently owning the tokens).\n   * @param value Amount of tokens to send.\n   * @param revertTransfer If set to true + trade has been accepted, tokens need to be sent back to their initial owners instead of sent to the target recipient.\n   */\n  function _executeTransferOnUsersTokens(uint256 index, Holder holder, uint256 value, bool revertTransfer) internal {\n    Trade storage trade = _trades[index];\n\n    address sender = (holder == Holder.Holder1) ? trade.holder1 : trade.holder2;\n    address recipient = (holder == Holder.Holder1) ? trade.holder2 : trade.holder1;\n    UserTradeData storage senderUserTradeData = (holder == Holder.Holder1) ? trade.userTradeData1 : trade.userTradeData2;\n\n    address tokenAddress = senderUserTradeData.tokenAddress;\n    bytes32 tokenId = senderUserTradeData.tokenId;\n    Standard tokenStandard = senderUserTradeData.tokenStandard;\n\n    address currentHolder = sender;\n    if(senderUserTradeData.tradeType == TradeType.Escrow) {\n      currentHolder = address(this);\n    }\n\n    if(revertTransfer) {\n      recipient = sender;\n    } else {\n      require(block.timestamp <= trade.expirationDate, \"Expiration date is past\");\n    }\n\n    if(tokenStandard == Standard.ETH) {\n      address payable payableRecipient = payable(recipient);\n      payableRecipient.transfer(value);\n    } else if(tokenStandard == Standard.ERC20) {\n      if(currentHolder == address(this)) {\n        IERC20(tokenAddress).transfer(recipient, value);\n      } else {\n        IERC20(tokenAddress).transferFrom(currentHolder, recipient, value);\n      }\n    } else if(tokenStandard == Standard.ERC721) {\n      IERC721(tokenAddress).transferFrom(currentHolder, recipient, uint256(tokenId));\n    } else if(tokenStandard == Standard.ERC1400) {\n      IERC1400(tokenAddress).operatorTransferByPartition(tokenId, currentHolder, recipient, value, \"\", \"\");\n    }\n\n  }\n\n  function _executeHold(\n    address token,\n    bytes32 tokenHoldId,\n    Standard tokenStandard,\n    bytes32 preimage,\n    address tokenRecipient\n  ) internal {\n    // Token 1\n    if (tokenStandard == Standard.ERC20) {\n      require(token != address(0), \"token can not be a zero address\");\n\n      IERC20HoldableToken(token).executeHold(tokenHoldId, preimage);\n    } else if (tokenStandard == Standard.ERC1400) {\n      require(token != address(0), \"token can not be a zero address\");\n\n      address tokenExtension = interfaceAddr(token, ERC1400_TOKENS_VALIDATOR);\n      require(\n          tokenExtension != address(0),\n          \"token has no holdable token extension\"\n      );\n\n      uint256 holdValue;\n      (,,,,holdValue,,,,) = IHoldableERC1400TokenExtension(tokenExtension).retrieveHoldData(token, tokenHoldId);\n\n      IHoldableERC1400TokenExtension(tokenExtension).executeHold(\n          token,\n          tokenHoldId,\n          holdValue,\n          preimage\n      );\n    } else {\n        revert(\"invalid token standard\");\n    }\n\n    emit ExecutedHold(\n        token,\n        tokenHoldId,\n        preimage,\n        tokenRecipient\n    );\n  }\n\n  function _holdExists(address sender, address recipient, UserTradeData memory userTradeData) internal view returns(bool) {\n    address tokenAddress = userTradeData.tokenAddress;\n    bytes32 holdId = userTradeData.tokenId;\n    Standard tokenStandard = userTradeData.tokenStandard;\n    \n    if(tokenStandard == Standard.ERC1400) {\n      address tokenExtension = interfaceAddr(tokenAddress, ERC1400_TOKENS_VALIDATOR);\n      require(\n          tokenExtension != address(0),\n          \"token has no holdable token extension\"\n      );\n\n      HoldStatusCode holdStatus;\n      address holdSender;\n      address holdRecipient;\n      uint256 holdValue;\n      address notary;\n      bytes32 secretHash;\n      (,holdSender,holdRecipient,notary,holdValue,,secretHash,,holdStatus) = IHoldableERC1400TokenExtension(tokenExtension).retrieveHoldData(tokenAddress, holdId);\n      return holdStatus == HoldStatusCode.Ordered && holdValue == userTradeData.tokenValue && (holdSender == sender || holdSender == address(0)) && holdRecipient == recipient && (secretHash != bytes32(0) || notary == address(this));\n    } else if (tokenStandard == Standard.ERC20) {\n      ERC20HoldData memory data = IERC20HoldableToken(tokenAddress).retrieveHoldData(holdId);\n      return (data.sender == sender || data.sender == address(0)) && data.recipient == recipient && data.amount == userTradeData.tokenValue && data.status == HoldStatusCode.Ordered && (data.secretHash != bytes32(0) || data.notary == address(this));\n    } else {\n      revert(\"Invalid tokenStandard provided\");\n    }\n  }\n\n  /**\n   * @dev Indicate whether or not the Swaps contract can receive the tokens or not.\n   *\n   * By convention, the 32 first bytes of a token transfer to the Swaps smart contract contain a flag.\n   *\n   *  - When tokens are transferred to Swaps contract to propose a new trade. The 'data' field starts with the\n   *  following flag: 0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n   *  In this case the data structure is the the following:\n   *  <tradeFlag (32 bytes)><recipient address (32 bytes)><executer address (32 bytes)><expiration date (32 bytes)><requested token data (4 * 32 bytes)>\n   *\n   *  - When tokens are transferred to Swaps contract to accept an existing trade. The 'data' field starts with the\n   *  following flag: 0xdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd\n   *  In this case the data structure is the the following:\n   *  <tradeFlag (32 bytes)><request index (32 bytes)>\n   *\n   * If the 'data' doesn't start with one of those flags, the Swaps contract won't accept the token transfer.\n   *\n   * @param data Information attached to the Swaps transfer.\n   * @param operatorData Information attached to the Swaps transfer, by the operator.\n   * @return 'true' if the Swaps contract can receive the tokens, 'false' if not.\n   */\n  function _canReceive(bytes memory data, bytes memory operatorData) internal pure returns(bool) {\n    if(operatorData.length == 0) { // The reason for this check is to avoid a certificate gets interpreted as a flag by mistake\n      return false;\n    }\n    \n    bytes32 flag = _getTradeFlag(data);\n    if(data.length == 320 && flag == TRADE_PROPOSAL_FLAG) {\n      return true;\n    } else if ((data.length == 64 || data.length == 96) && flag == TRADE_ACCEPTANCE_FLAG) {\n      return true;\n    } else if (data.length == 32 && flag == BYPASS_ACTION_FLAG) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n    /**\n   * @dev Retrieve the trade flag from the 'data' field.\n   *\n   * By convention, the 32 first bytes of a token transfer to the Swaps smart contract contain a flag.\n   *  - When tokens are transferred to Swaps contract to propose a new trade. The 'data' field starts with the\n   *  following flag: 0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n   *  - When tokens are transferred to Swaps contract to accept an existing trade. The 'data' field starts with the\n   *  following flag: 0xdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd\n   *\n   * @param data Concatenated information about the trade proposal.\n   * @return flag Trade flag.\n   */\n  function _getTradeFlag(bytes memory data) internal pure returns(bytes32 flag) {\n    assembly {\n      flag:= mload(add(data, 32))\n    }\n  }\n\n  /**\n   * By convention, when tokens are transferred to Swaps contract to propose a new trade, the 'data' of a token transfer has the following structure:\n   *  <tradeFlag (32 bytes)><recipient address (32 bytes)><executer address (32 bytes)><expiration date (32 bytes)><requested token data (5 * 32 bytes)>\n   *\n   * The first 32 bytes are the flag 0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n   *\n   * The next 32 bytes contain the trade recipient address (or the zero address if the recipient is not chosen).\n   *\n   * The next 32 bytes contain the trade executer address (or zero if the executer is not chosen).\n   *\n   * The next 32 bytes contain the trade expiration date (or zero if the expiration date is not chosen).\n   *\n   * The next 32 bytes contain the trade requested token address (or the zero address if the recipient is not chosen).\n   * The next 32 bytes contain the trade requested token amount.\n   * The next 32 bytes contain the trade requested token id/partition (used when token standard is ERC721 or ERC1400).\n   * The next 32 bytes contain the trade requested token standard (OffChain, ERC20, ERC721, ERC1400, ETH).\n   * The next 32 bytes contain a boolean precising wether trade has been accepted by token holder or not.\n   * The next 32 bytes contain a boolean precising wether trade has been approved by token controller or not.\n   *\n   * Example input for recipient address '0xb5747835141b46f7C472393B31F8F5A57F74A44f', expiration date '1576348418',\n   * trade executer address '0x32F54098916ceb5f57a117dA9554175Fe25611bA', requested token address '0xC6F0410A667a5BEA528d6bc9efBe10270089Bb11',\n   * requested token amount '5', requested token id/partition '37252', and requested token type 'ERC1400', accepted and approved:\n   * 0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc000000000000000000000000b5747835141b46f7C472393B31F8F5A57F74A44f\n   * 000000000000000000000000000000000000000000000000000000157634841800000000000000000000000032F54098916ceb5f57a117dA9554175Fe25611bA\n   * 000000000000000000000000C6F0410A667a5BEA528d6bc9efBe10270089Bb110000000000000000000000000000000000000000000000000000000000000005\n   * 000000000000000000000000000000000000000000000000000000000037252000000000000000000000000000000000000000000000000000000000000002\n   * 000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000001\n   */\n\n  /**\n   * @dev Retrieve the tokenData from the 'data' field.\n   *\n   * @param data Concatenated information about the trade proposal.\n   * @return tokenData Trade token data < 1: address > < 2: amount > < 3: id/partition > < 4: standard > < 5: accepted > < 6: approved >.\n   */\n  function _getTradeTokenData(bytes memory data) internal pure returns(UserTradeData memory tokenData) {\n    address tokenAddress;\n    uint256 tokenAmount;\n    bytes32 tokenId;\n    Standard tokenStandard;\n    TradeType tradeType;\n    assembly {\n      tokenAddress:= mload(add(data, 192))\n      tokenAmount:= mload(add(data, 224))\n      tokenId:= mload(add(data, 256))\n      tokenStandard:= mload(add(data, 288))\n      tradeType:= mload(add(data, 320))\n    }\n    tokenData = UserTradeData(\n      tokenAddress,\n      tokenAmount,\n      tokenId,\n      tokenStandard,\n      false,\n      false,\n      tradeType\n    );\n  }\n\n  /**\n   * @dev Retrieve the trade index from the 'data' field.\n   *\n   * By convention, when tokens are transferred to Swaps contract to accept an existing trade, the 'data' of a token transfer has the following structure:\n   *  <tradeFlag (32 bytes)><index uint256 (32 bytes)>\n   *\n   * The first 32 bytes are the flag 0xdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd\n   *\n   * The next 32 bytes contain the trade index.\n   *\n   * Example input for trade index #2985:\n   * 0xdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd0000000000000000000000000000000000000000000000000000000000002985\n   *\n   * @param data Concatenated information about the trade validation.\n   * @return index Trade index.\n   */\n\n  /**************************** TRADE EXECUTERS *******************************/\n\n  /**\n   * @dev Renounce ownership of the contract.\n   */\n  function renounceOwnership() public override onlyOwner {\n    Ownable.renounceOwnership();\n    _ownedContract = false;\n  }\n\n  /**\n   * @dev Get the list of trade executers as defined by the Swaps contract.\n   * @return List of addresses of all the trade executers.\n   */\n  function tradeExecuters() external view returns (address[] memory) {\n    return _tradeExecuters;\n  }\n\n  /**\n   * @dev Set list of trade executers for the Swaps contract.\n   * @param operators Trade executers addresses.\n   */\n  function setTradeExecuters(address[] calldata operators) external onlyOwner {\n    require(_ownedContract, \"Swaps contract is not owned\");\n    _setTradeExecuters(operators);\n  }\n\n  /**\n   * @dev Set list of trade executers for the Swaps contract.\n   * @param operators Trade executers addresses.\n   */\n  function _setTradeExecuters(address[] memory operators) internal {\n\n    for (uint i = 0; i<_tradeExecuters.length; i++){\n      _isTradeExecuter[_tradeExecuters[i]] = false;\n    }\n    for (uint j = 0; j<operators.length; j++){\n      _isTradeExecuter[operators[j]] = true;\n    }\n    _tradeExecuters = operators;\n  }\n\n  /************************** TOKEN CONTROLLERS *******************************/\n\n  /**\n   * @dev Get the list of token controllers for a given token.\n   * @param tokenAddress Token address.\n   * @return List of addresses of all the token controllers for a given token.\n   */\n  function tokenControllers(address tokenAddress) external view returns (address[] memory) {\n    return _tokenControllers[tokenAddress];\n  }\n\n  /**\n   * @dev Set list of token controllers for a given token.\n   * @param tokenAddress Token address.\n   * @param operators Operators addresses.\n   */\n  function setTokenControllers(address tokenAddress, address[] calldata operators) external onlyTokenController(tokenAddress) {\n    for (uint i = 0; i<_tokenControllers[tokenAddress].length; i++){\n      _isTokenController[tokenAddress][_tokenControllers[tokenAddress][i]] = false;\n    }\n    for (uint j = 0; j<operators.length; j++){\n      _isTokenController[tokenAddress][operators[j]] = true;\n    }\n    _tokenControllers[tokenAddress] = operators;\n  }\n\n  /************************** TOKEN PRICE ORACLES *******************************/\n\n  /**\n   * @dev Get the list of price oracles for a given token.\n   * @param tokenAddress Token address.\n   * @return List of addresses of all the price oracles for a given token.\n   */\n  function priceOracles(address tokenAddress) external view returns (address[] memory) {\n    return _priceOracles[tokenAddress];\n  }\n\n  /**\n   * @dev Set list of price oracles for a given token.\n   * @param tokenAddress Token address.\n   * @param oracles Oracles addresses.\n   */\n  function setPriceOracles(address tokenAddress, address[] calldata oracles) external onlyPriceOracle(tokenAddress) {\n    for (uint i = 0; i<_priceOracles[tokenAddress].length; i++){\n      _isPriceOracle[tokenAddress][_priceOracles[tokenAddress][i]] = false;\n    }\n    for (uint j = 0; j<oracles.length; j++){\n      _isPriceOracle[tokenAddress][oracles[j]] = true;\n    }\n    _priceOracles[tokenAddress] = oracles;\n  }\n\n  /**\n   * @dev Check if address is oracle of a given token.\n   * @param tokenAddress Token address.\n   * @param oracle Oracle address.\n   * @return 'true' if the address is oracle of the given token.\n   */\n  function _checkPriceOracle(address tokenAddress, address oracle) internal view returns(bool) {\n    return(_isPriceOracle[tokenAddress][oracle] || oracle == Ownable(tokenAddress).owner());\n  }\n\n  /****************************** Swaps PRICES *********************************/\n\n  /**\n   * @dev Get price of the token.\n   * @param tokenAddress1 Address of the token to be priced.\n   * @param tokenAddress2 Address of the token to pay for token1.\n   */\n  function getPriceOwnership(address tokenAddress1, address tokenAddress2) external view returns(bool) {\n    return _priceOwnership[tokenAddress1][tokenAddress2];\n  }\n\n  /**\n   * @dev Take ownership for setting the price of a token.\n   * @param tokenAddress1 Address of the token to be priced.\n   * @param tokenAddress2 Address of the token to pay for token1.\n   */\n  function setPriceOwnership(address tokenAddress1, address tokenAddress2, bool priceOwnership) external onlyPriceOracle(tokenAddress1) {\n    _priceOwnership[tokenAddress1][tokenAddress2] = priceOwnership;\n  }\n\n  /**\n   * @dev Get date after which the token price can potentially be set by an oracle (0 if price can not be set by an oracle).\n   * @param tokenAddress Token address.\n   */\n  function variablePriceStartDate(address tokenAddress) external view returns(uint256) {\n    return _variablePriceStartDate[tokenAddress];\n  }\n\n  /**\n   * @dev Set date after which the token price can potentially be set by an oracle (0 if price can not be set by an oracle).\n   * @param tokenAddress Token address.\n   * @param startDate Date after which token price can potentially be set by an oracle (0 if price can not be set by an oracle).\n   */\n  function setVariablePriceStartDate(address tokenAddress, uint256 startDate) external onlyPriceOracle(tokenAddress) {\n    require((startDate > block.timestamp + SECONDS_IN_WEEK) || startDate == 0, \"Start date needs to be set at least a week before\");\n    _variablePriceStartDate[tokenAddress] = startDate;\n  }\n\n  /**\n   * @dev Get price of the token.\n   * @param tokenAddress1 Address of the token to be priced.\n   * @param tokenAddress2 Address of the token to pay for token1.\n   * @param tokenId1 ID/partition of the token1 (set to 0 bytes32 if price is set for all IDs/partitions).\n   * @param tokenId1 ID/partition of the token2 (set to 0 bytes32 if price is set for all IDs/partitions).\n   */\n  function getTokenPrice(address tokenAddress1, address tokenAddress2, bytes32 tokenId1, bytes32 tokenId2) external view returns(uint256) {\n    return _tokenUnitPricesByPartition[tokenAddress1][tokenAddress2][tokenId1][tokenId2];\n  }\n\n  /**\n   * @dev Set price of a token.\n   * @param tokenAddress1 Address of the token to be priced.\n   * @param tokenAddress2 Address of the token to pay for token1.\n   * @param tokenId1 ID/partition of the token1 (set to 0 bytes32 if price is set for all IDs/partitions).\n   * @param tokenId2 ID/partition of the token2 (set to 0 bytes32 if price is set for all IDs/partitions).\n   * @param newPrice New price of the token.\n   */\n  function setTokenPrice(address tokenAddress1, address tokenAddress2, bytes32 tokenId1, bytes32 tokenId2, uint256 newPrice) external {\n    require(!(_priceOwnership[tokenAddress1][tokenAddress2] && _priceOwnership[tokenAddress2][tokenAddress1]), \"Competition on price ownership\");\n\n    if(_priceOwnership[tokenAddress1][tokenAddress2]) {\n      require(_checkPriceOracle(tokenAddress1, msg.sender), \"Price setter is not an oracle for this token (1)\");\n    } else if(_priceOwnership[tokenAddress2][tokenAddress1]) {\n      require(_checkPriceOracle(tokenAddress2, msg.sender), \"Price setter is not an oracle for this token (2)\");\n    } else {\n      revert(\"No price ownership\");\n    }\n\n    _tokenUnitPricesByPartition[tokenAddress1][tokenAddress2][tokenId1][tokenId2] = newPrice;\n  }\n\n  /**\n   * @dev Get amount of token2 to pay to acquire the token1.\n   * @param index Index of the Swaps request.\n   */\n  function getPrice(uint256 index) public view returns(uint256) {\n    Trade storage trade = _trades[index];\n\n    address tokenAddress1 = trade.userTradeData1.tokenAddress;\n    uint256 tokenValue1 = trade.userTradeData1.tokenValue;\n    bytes32 tokenId1 = trade.userTradeData1.tokenId;\n\n    address tokenAddress2 = trade.userTradeData2.tokenAddress;\n    uint256 tokenValue2 = trade.userTradeData2.tokenValue;\n    bytes32 tokenId2 = trade.userTradeData2.tokenId;\n\n    require(!(_priceOwnership[tokenAddress1][tokenAddress2] && _priceOwnership[tokenAddress2][tokenAddress1]), \"Competition on price ownership\");\n\n    if(_variablePriceStartDate[tokenAddress1] == 0 || block.timestamp < _variablePriceStartDate[tokenAddress1]) {\n      return tokenValue2;\n    }\n\n    if(_priceOwnership[tokenAddress1][tokenAddress2] || _priceOwnership[tokenAddress2][tokenAddress1]) {\n\n      if(_tokenUnitPricesByPartition[tokenAddress1][tokenAddress2][tokenId1][tokenId2] != 0) {\n        return tokenValue1 * (_tokenUnitPricesByPartition[tokenAddress1][tokenAddress2][tokenId1][tokenId2]);\n\n      } else if(_tokenUnitPricesByPartition[tokenAddress2][tokenAddress1][tokenId2][tokenId1] != 0) {\n        return tokenValue1 / (_tokenUnitPricesByPartition[tokenAddress2][tokenAddress1][tokenId2][tokenId1]);\n\n      } else if(_tokenUnitPricesByPartition[tokenAddress1][tokenAddress2][tokenId1][ALL_PARTITIONS] != 0) {\n        return tokenValue1 * (_tokenUnitPricesByPartition[tokenAddress1][tokenAddress2][tokenId1][ALL_PARTITIONS]);\n\n      } else if(_tokenUnitPricesByPartition[tokenAddress2][tokenAddress1][ALL_PARTITIONS][tokenId1] != 0) {\n        return tokenValue1 / (_tokenUnitPricesByPartition[tokenAddress2][tokenAddress1][ALL_PARTITIONS][tokenId1]);\n\n      } else if(_tokenUnitPricesByPartition[tokenAddress1][tokenAddress2][ALL_PARTITIONS][tokenId2] != 0) {\n        return tokenValue1 * (_tokenUnitPricesByPartition[tokenAddress1][tokenAddress2][ALL_PARTITIONS][tokenId2]);\n\n      } else if(_tokenUnitPricesByPartition[tokenAddress2][tokenAddress1][tokenId2][ALL_PARTITIONS] != 0) {\n        return tokenValue1 / (_tokenUnitPricesByPartition[tokenAddress2][tokenAddress1][tokenId2][ALL_PARTITIONS]);\n\n      } else if(_tokenUnitPricesByPartition[tokenAddress1][tokenAddress2][ALL_PARTITIONS][ALL_PARTITIONS] != 0) {\n        return tokenValue1 * (_tokenUnitPricesByPartition[tokenAddress1][tokenAddress2][ALL_PARTITIONS][ALL_PARTITIONS]);\n\n      } else if(_tokenUnitPricesByPartition[tokenAddress2][tokenAddress1][ALL_PARTITIONS][ALL_PARTITIONS] != 0) {\n        return tokenValue1 / (_tokenUnitPricesByPartition[tokenAddress2][tokenAddress1][ALL_PARTITIONS][ALL_PARTITIONS]);\n\n      } else {\n        return tokenValue2;\n      }\n\n    } else {\n      return tokenValue2;\n    }\n  }\n\n  /**************************** VIEW FUNCTIONS *******************************/\n\n  /**\n   * @dev Get the trade.\n   * @param index Index of the trade.\n   * @return Trade.\n   */\n  function getTrade(uint256 index) external view returns(Trade memory) {\n    Trade storage trade = _trades[index];\n    return trade;\n  }\n\n  /**\n   * @dev Get the total number of requests in the Swaps contract.\n   * @return Total number of requests in the Swaps contract.\n   */\n  function getNbTrades() external view returns(uint256) {\n    return _index;\n  }\n }\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/interface/IERC20HoldableToken.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\n/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./HoldStatusCode.sol\";\n\nstruct ERC20HoldData {\n    address sender;\n    address recipient;\n    address notary;\n    uint256 amount;\n    uint256 expirationDateTime;\n    bytes32 secretHash;\n    HoldStatusCode status;\n}\n\n/**\n * @title Holdable ERC20 Token Interface.\n * @dev like approve except the tokens can't be spent by the sender while they are on hold.\n */\ninterface IERC20HoldableToken is IERC20 {\n\n    event NewHold(\n        bytes32 indexed holdId,\n        address indexed recipient,\n        address indexed notary,\n        uint256 amount,\n        uint256 expirationDateTime,\n        bytes32 lockHash\n    );\n    event ExecutedHold(\n        bytes32 indexed holdId,\n        bytes32 lockPreimage,\n        address recipient\n    );\n    event ReleaseHold(bytes32 indexed holdId, address sender);\n\n    /**\n     @notice Called by the sender to hold some tokens for a recipient that the sender can not release back to themself until after the expiration date.\n     @param recipient optional account the tokens will be transferred to on execution. If a zero address, the recipient must be specified on execution of the hold.\n     @param notary account that can execute the hold. Typically the recipient but can be a third party or a smart contact.\n     @param amount of tokens to be transferred to the recipient on execution. Must be a non zero amount.\n     @param expirationDateTime UNIX epoch seconds the held amount can be released back to the sender by the sender. Past dates are allowed.\n     @param lockHash optional keccak256 hash of a lock preimage. An empty hash will not enforce the hash lock when the hold is executed.\n     @return bool Whether the call was successful or not.\n     */\n    function hold(\n        bytes32 holdId,\n        address recipient,\n        address notary,\n        uint256 amount,\n        uint256 expirationDateTime,\n        bytes32 lockHash\n    ) external returns (bool);\n\n    function retrieveHoldData(bytes32 holdId) external view returns (ERC20HoldData memory);\n\n    /**\n     @notice Called by the notary to transfer the held tokens to the set at the hold recipient if there is no hash lock.\n     @param holdId a unique identifier for the hold.\n     */\n    function executeHold(bytes32 holdId) external;\n\n    /**\n     @notice Called by the notary to transfer the held tokens to the recipient that was set at the hold.\n     @param holdId a unique identifier for the hold.\n     @param lockPreimage the image used to generate the lock hash with a keccak256 hash\n     */\n    function executeHold(bytes32 holdId, bytes32 lockPreimage) external;\n\n    /**\n     @notice Called by the notary to transfer the held tokens to the recipient if no recipient was specified at the hold.\n     @param holdId a unique identifier for the hold.\n     @param lockPreimage the image used to generate the lock hash with a keccak256 hash\n     @param recipient the account the tokens will be transferred to on execution.\n     */\n    function executeHold(\n        bytes32 holdId,\n        bytes32 lockPreimage,\n        address recipient\n    ) external;\n\n    /**\n     @notice Called by the notary at any time or the sender after the expiration date to release the held tokens back to the sender.\n     @param holdId a unique identifier for the hold.\n     */\n    function releaseHold(bytes32 holdId) external;\n\n    /**\n     @notice Amount of tokens owned by an account that are held pending execution or release.\n     @param account owner of the tokens\n     */\n    function balanceOnHold(address account) external view returns (uint256);\n\n    /**\n     @notice Total amount of tokens owned by an account including all the held tokens pending execution or release.\n     @param account owner of the tokens\n     */\n    function spendableBalanceOf(address account) external view returns (uint256);\n\n    function totalSupplyOnHold() external view returns (uint256);\n\n    /**\n     @param holdId a unique identifier for the hold.\n     @return hold status code.\n     */\n    function holdStatus(bytes32 holdId) external view returns (HoldStatusCode);\n}\n"
    },
    "contracts/interface/IHoldableERC1400TokenExtension.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity ^0.8.0;\n\nimport \"./HoldStatusCode.sol\";\n\ninterface IHoldableERC1400TokenExtension {\n    function executeHold(\n        address token,\n        bytes32 holdId,\n        uint256 value,\n        bytes32 lockPreimage\n    ) external returns (bool);\n\n    function retrieveHoldData(address token, bytes32 holdId) external view returns (\n        bytes32 partition,\n        address sender,\n        address recipient,\n        address notary,\n        uint256 value,\n        uint256 expiration,\n        bytes32 secretHash,\n        bytes32 secret,\n        HoldStatusCode status\n    );\n}"
    },
    "contracts/interface/HoldStatusCode.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity ^0.8.0;\n\nenum HoldStatusCode {\n    Nonexistent,\n    Ordered,\n    Executed,\n    ExecutedAndKeptOpen,\n    ReleasedByNotary,\n    ReleasedByPayee,\n    ReleasedOnExpiration\n}"
    },
    "contracts/tools/BatchTokenIssuer.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\n/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interface/ERC1820Implementer.sol\";\n\nimport \"../IERC1400.sol\";\n\n/**\n * @notice Interface to the Minterrole contract\n */\ninterface IMinterRole {\n  function isMinter(address account) external view returns (bool);\n}\n\n/**\n * @title BatchTokenIssuer\n * @dev Proxy contract to issue multiple ERC1400/ERC20 tokens in a single transaction.\n */\ncontract BatchTokenIssuer is ERC1820Implementer {\n\n  string constant internal BATCH_ISSUER = \"BatchTokenIssuer\";\n\n  // Mapping from token to token minters.\n  mapping(address => address[]) internal _tokenMinters;\n\n  // Mapping from (token, operator) to token minter status.\n  mapping(address => mapping(address => bool)) internal _isTokenMinter;\n\n  /**\n   * @dev Modifier to verify if sender is a token minter.\n   */\n  modifier onlyTokenMinter(address token) {\n    require(IMinterRole(token).isMinter(msg.sender),\n      \"Sender is not a token minter.\"\n    );\n    _;\n  }\n\n  constructor() public {\n    ERC1820Implementer._setInterface(BATCH_ISSUER);\n  }\n\n  /**\n   * @dev Issue tokens for multiple addresses.\n   * @param token Address of token where the tokens need to be issued.\n   * @param partitions Name of the partitions.\n   * @param tokenHolders Addresses for which we want to issue tokens.\n   * @param values Number of tokens issued.\n   */\n  function batchIssueByPartition(\n    address token,\n    bytes32[] calldata partitions,\n    address[] calldata tokenHolders,\n    uint256[] calldata values\n  )\n    external\n    onlyTokenMinter(token)\n    returns (uint256[] memory)\n  {\n    require(partitions.length == tokenHolders.length, \"partitions and tokenHolders arrays have different lengths\");\n    require(partitions.length == values.length, \"partitions and values arrays have different lengths\");\n    \n    for (uint i = 0; i < partitions.length; i++) {\n        IERC1400(token).issueByPartition(partitions[i], tokenHolders[i], values[i], \"\");\n    }\n  }\n\n}\n"
    },
    "contracts/tools/FundIssuer.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\n/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport \"./ERC1820Client.sol\";\nimport \"../interface/ERC1820Implementer.sol\";\n\nimport \"../extensions/userExtensions/IERC1400TokensRecipient.sol\";\nimport \"../ERC1400.sol\";\n\n/**\n ***************************************************************************************************************\n **************************************** CAUTION: work in progress ********************************************\n ***************************************************************************************************************\n *\n * CAUTION: This contract is a work in progress, tests are not finalized yet!\n *\n ***************************************************************************************************************\n **************************************** CAUTION: work in progress ********************************************\n ***************************************************************************************************************\n */\n\n\n/**\n * @title FundIssuer\n * @dev Fund issuance contract.\n * @dev Intended usage:\n * The purpose of the contract is to perform a fund issuance.\n *\n */\ncontract FundIssuer is ERC1820Client, IERC1400TokensRecipient, ERC1820Implementer {\n  using SafeMath for uint256;\n\n  bytes32 constant internal ORDER_SUBSCRIPTION_FLAG = 0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc;\n  bytes32 constant internal ORDER_PAYMENT_FLAG = 0xdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd;\n\n  bytes32 constant internal BYPASS_ACTION_FLAG = 0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;\n\n  string constant internal FUND_ISSUER = \"FundIssuer\";\n  string constant internal ERC1400_TOKENS_RECIPIENT = \"ERC1400TokensRecipient\";\n\n  enum CycleState {Undefined, Subscription, Valuation, Payment, Settlement, Finalized}\n\n  enum OrderState {Undefined, Subscribed, Paid, PaidSettled, UnpaidSettled, Cancelled, Rejected}\n\n  enum OrderType {Undefined, Value, Amount}\n\n  enum Payment {OffChain, ETH, ERC20, ERC1400}\n\n  enum AssetValue {Unknown, Known}\n\n  struct AssetRules {\n    bool defined;\n    uint256 firstStartTime;\n    uint256 subscriptionPeriodLength;\n    uint256 valuationPeriodLength;\n    uint256 paymentPeriodLength;\n    AssetValue assetValueType;\n    uint256 assetValue;\n    uint256 reverseAssetValue;\n    Payment paymentType;\n    address paymentAddress;\n    bytes32 paymentPartition;\n    address fundAddress;\n    bool subscriptionsOpened;\n  }\n  \n  struct Cycle {\n    address assetAddress;\n    bytes32 assetClass;\n    uint256 startTime;\n    uint256 subscriptionPeriodLength;\n    uint256 valuationPeriodLength;\n    uint256 paymentPeriodLength;\n    AssetValue assetValueType;\n    uint256 assetValue;\n    uint256 reverseAssetValue;\n    Payment paymentType;\n    address paymentAddress;\n    bytes32 paymentPartition;\n    address fundAddress;\n    bool finalized;\n  }\n\n  struct Order {\n    uint256 cycleIndex;\n    address investor;\n    uint256 value;\n    uint256 amount;\n    OrderType orderType;\n    OrderState state;\n  }\n\n  // Mapping from (assetAddress, assetClass) to asset rules.\n  mapping(address => mapping(bytes32 => AssetRules)) internal _assetRules;\n\n  // Index of most recent cycle.\n  uint256 internal _cycleIndex;\n\n  // Mapping from cycle index to cycle.\n  mapping(uint256 => Cycle) internal _cycles;\n\n  // Mapping from (assetAddress, assetClass) to most recent cycle.\n  mapping(address => mapping (bytes32 => uint256)) internal _lastCycleIndex;\n\n  // Index of most recent order.\n  uint256 internal _orderIndex;\n\n  // Mapping from order index to order.\n  mapping(uint256 => Order) internal _orders;\n\n  // Mapping from cycle index to order list.\n  mapping(uint256 => uint256[]) internal _cycleOrders;\n\n  // Mapping from investor address to order list.\n  mapping(address => uint256[]) internal _investorOrders;\n\n  // Mapping from assetAddress to amount of escrowed ETH.\n  mapping(address => uint256) internal _escrowedEth;\n\n  // Mapping from (assetAddress, paymentAddress) to amount of escrowed ERC20.\n  mapping(address => mapping (address => uint256)) internal _escrowedErc20;\n\n  // Mapping from (assetAddress, paymentAddress, paymentPartition) to amount of escrowed ERC1400.\n  mapping(address => mapping (address => mapping (bytes32 => uint256))) internal _escrowedErc1400;\n\n  // Mapping from token to token controllers.\n  mapping(address => address[]) internal _tokenControllers;\n\n  // Mapping from (token, operator) to token controller status.\n  mapping(address => mapping(address => bool)) internal _isTokenController;\n\n  // Mapping from token to price oracles.\n  mapping(address => address[]) internal _priceOracles;\n\n  // Mapping from (token, operator) to price oracle status.\n  mapping(address => mapping(address => bool)) internal _isPriceOracle;\n\n  /**\n   * @dev Modifier to verify if sender is a token controller.\n   */\n  modifier onlyTokenController(address tokenAddress) {\n    require(_tokenController(msg.sender, tokenAddress),\n      \"Sender is not a token controller.\"\n    );\n    _;\n  }\n\n  /**\n   * @dev Modifier to verify if sender is a price oracle.\n   */\n  modifier onlyPriceOracle(address assetAddress) {\n    require(_checkPriceOracle(assetAddress, msg.sender), \"Sender is not a price oracle.\");\n    _;\n  }\n\n  /**\n   * [Swaps CONSTRUCTOR]\n   * @dev Initialize Fund issuance contract + register\n   * the contract implementation in ERC1820Registry.\n   */\n  constructor() public {\n    ERC1820Implementer._setInterface(FUND_ISSUER);\n    ERC1820Implementer._setInterface(ERC1400_TOKENS_RECIPIENT);\n    setInterfaceImplementation(ERC1400_TOKENS_RECIPIENT, address(this));\n  }\n\n /**\n   * [ERC1400TokensRecipient INTERFACE (1/2)]\n   * @dev Indicate whether or not the fund issuance contract can receive the tokens or not. [USED FOR ERC1400 TOKENS ONLY]\n   * @param data Information attached to the token transfer.\n   * @param operatorData Information attached to the Swaps transfer, by the operator.\n   * @return 'true' if the Swaps contract can receive the tokens, 'false' if not.\n   */\n  function canReceive(bytes calldata, bytes32, address, address, address, uint, bytes calldata  data, bytes calldata operatorData) external override view returns(bool) {\n    return(_canReceive(data, operatorData));\n  }\n\n  /**\n   * [ERC1400TokensRecipient INTERFACE (2/2)]\n   * @dev Hook function executed when tokens are sent to the fund issuance contract. [USED FOR ERC1400 TOKENS ONLY]\n   * @param partition Name of the partition.\n   * @param from Token holder.\n   * @param to Token recipient.\n   * @param value Number of tokens to transfer.\n   * @param data Information attached to the token transfer.\n   * @param operatorData Information attached to the Swaps transfer, by the operator.\n   */\n  function tokensReceived(bytes calldata, bytes32 partition, address, address from, address to, uint value, bytes calldata data, bytes calldata operatorData) external override {\n    require(interfaceAddr(msg.sender, \"ERC1400Token\") == msg.sender, \"55\"); // 0x55 funds locked (lockup period)\n\n    require(to == address(this), \"50\"); // 0x50\ttransfer failure\n    require(_canReceive(data, operatorData), \"57\"); // 0x57\tinvalid receiver\n\n    bytes32 flag = _getTransferFlag(data);\n    bytes memory erc1400TokenData = abi.encode(msg.sender, partition, value);\n\n    if (flag == ORDER_SUBSCRIPTION_FLAG) {\n\n      address assetAddress = _getAssetAddress(data);\n      bytes32 assetClass = _getAssetClass(data);\n      bytes memory orderData = _getOrderData(data);\n\n      _subscribe(\n        from,\n        assetAddress,\n        assetClass,\n        orderData,\n        true,\n        erc1400TokenData\n      );\n\n    } else if (flag == ORDER_PAYMENT_FLAG) {\n      uint256 orderIndex = _getOrderIndex(data);\n      Order storage order = _orders[orderIndex];\n      require(from == order.investor, \"Payment sender is not the subscriber\");\n\n      _executePayment(orderIndex, erc1400TokenData, false);         \n    }\n  }\n\n\n  /**\n   * @dev Start a new subscription for a given asset in the fund issuance smart contract.\n   * @param assetAddress Address of the token representing the asset.\n   * @param assetClass Asset class.\n   * @param subscriptionPeriodLength Length of subscription period.\n   * @param valuationPeriodLength Length of valuation period.\n   * @param paymentPeriodLength Length of payment period.\n   * @param paymentType Type of payment (OFFCHAIN | ERC20 | ERC1400).\n   * @param paymentAddress Address of the payment token (only used id paymentType <> OFFCHAIN).\n   * @param paymentPartition Partition of the payment token (only used if paymentType is ERC1400).\n   * @param subscriptionsOpened Set 'true' if subscriptions are opened, 'false' if not.\n   */\n  function setAssetRules(\n    address assetAddress,\n    bytes32 assetClass,\n    uint256 firstStartTime,\n    uint256 subscriptionPeriodLength,\n    uint256 valuationPeriodLength,\n    uint256 paymentPeriodLength,\n    Payment paymentType,\n    address paymentAddress,\n    bytes32 paymentPartition,\n    address fundAddress,\n    bool subscriptionsOpened\n  )\n    external\n    onlyTokenController(assetAddress)\n  {\n    AssetRules storage rules = _assetRules[assetAddress][assetClass];\n\n    require(firstStartTime >= block.timestamp, \"First cycle start can not be prior to now\");\n\n    require(subscriptionPeriodLength != 0 && valuationPeriodLength != 0 && paymentPeriodLength != 0, \"Periods can not be nil\");\n\n    if(rules.defined) {\n      rules.firstStartTime = firstStartTime;\n      rules.subscriptionPeriodLength = subscriptionPeriodLength;\n      rules.valuationPeriodLength = valuationPeriodLength;\n      rules.paymentPeriodLength = paymentPeriodLength;\n      // rules.assetValueType = assetValueType; // Can only be modified by the price oracle\n      // rules.assetValue = assetValue; // Can only be modified by the price oracle\n      // rules.reverseAssetValue = reverseAssetValue; // Can only be modified by the price oracle\n      rules.paymentType = paymentType;\n      rules.paymentAddress = paymentAddress;\n      rules.paymentPartition = paymentPartition;\n      rules.fundAddress = fundAddress;\n      rules.subscriptionsOpened = subscriptionsOpened;\n    } else {\n\n      _assetRules[assetAddress][assetClass] = AssetRules({\n        defined: true,\n        firstStartTime: firstStartTime,\n        subscriptionPeriodLength: subscriptionPeriodLength,\n        valuationPeriodLength: valuationPeriodLength,\n        paymentPeriodLength: paymentPeriodLength,\n        assetValueType: AssetValue.Unknown,\n        assetValue: 0,\n        reverseAssetValue: 0,\n        paymentType: paymentType,\n        paymentAddress: paymentAddress,\n        paymentPartition: paymentPartition,\n        fundAddress: fundAddress,\n        subscriptionsOpened: subscriptionsOpened\n      });\n    }\n\n  }\n\n  /**\n   * @dev Set asset value rules for a given asset.\n   * @param assetAddress Address of the token representing the asset.\n   * @param assetClass Asset class.\n   * @param assetValueType Asset value type.\n   * @param assetValue Asset value.\n   * @param reverseAssetValue Reverse asset value.\n   */\n  function setAssetValueRules(\n    address assetAddress,\n    bytes32 assetClass,\n    AssetValue assetValueType,\n    uint256 assetValue,\n    uint256 reverseAssetValue\n  )\n    external\n    onlyPriceOracle(assetAddress)\n  {\n    AssetRules storage rules = _assetRules[assetAddress][assetClass];\n\n    require(rules.defined, \"Rules not defined for this asset\");\n\n    require(assetValue == 0 || reverseAssetValue == 0, \"Asset value can only be set in one direction\");\n\n    rules.assetValueType = assetValueType;\n    rules.assetValue = assetValue;\n    rules.reverseAssetValue = reverseAssetValue;\n  }\n\n  /**\n   * @dev Start a new subscription for a given asset in the fund issuance smart contract.\n   * @param assetAddress Address of the token representing the asset.\n   * @param assetClass Asset class.\n   * @return Index of new cycle.\n   */\n  function _startNewCycle(\n    address assetAddress,\n    bytes32 assetClass\n  )\n    internal\n    returns(uint256)\n  {\n    AssetRules storage rules = _assetRules[assetAddress][assetClass];\n    require(rules.defined, \"Rules not defined for this asset\");\n    require(rules.subscriptionsOpened, \"Subscriptions not opened for this asset\");\n\n    uint256 lastCycleIndex = _lastCycleIndex[assetAddress][assetClass];\n    Cycle storage lastCycle = _cycles[lastCycleIndex];\n    uint256 previousStartTime = (lastCycle.startTime != 0) ? lastCycle.startTime : rules.firstStartTime;\n\n    _cycleIndex = _cycleIndex.add(1);\n\n    _cycles[_cycleIndex] = Cycle({\n      assetAddress: assetAddress,\n      assetClass: assetClass,\n      startTime: _getNextStartTime(previousStartTime, rules.subscriptionPeriodLength),\n      subscriptionPeriodLength: rules.subscriptionPeriodLength,\n      valuationPeriodLength: rules.valuationPeriodLength,\n      paymentPeriodLength: rules.paymentPeriodLength,\n      assetValueType: rules.assetValueType,\n      assetValue: rules.assetValue,\n      reverseAssetValue: rules.reverseAssetValue,\n      paymentType: rules.paymentType,\n      paymentAddress: rules.paymentAddress,\n      paymentPartition: rules.paymentPartition,\n      fundAddress: rules.fundAddress,\n      finalized: false\n    });\n\n    _lastCycleIndex[assetAddress][assetClass] = _cycleIndex;\n\n    return _cycleIndex;\n  }\n\n  /**\n   * @dev Returns time of next cycle start.\n   * @param previousStartTime Previous start time.\n   * @param subscriptionPeriod Time between subscription period start and cut-off.\n   * @return Time of next cycle start.\n   */\n  function _getNextStartTime(uint256 previousStartTime, uint256 subscriptionPeriod) internal view returns(uint256) {\n    if(previousStartTime >= block.timestamp) {\n      return previousStartTime;\n    } else {\n      return block.timestamp.sub((block.timestamp - previousStartTime).mod(subscriptionPeriod));\n    }\n  }\n\n  /**\n   * @dev Subscribe for a given asset, by creating an order.\n   * @param assetAddress Address of the token representing the asset.\n   * @param assetClass Asset class.\n   * @param orderValue Value of assets to purchase (used in case order type is 'value').\n   * @param orderAmount Amount of assets to purchase (used in case order type is 'amount').\n   * @param orderType Order type (value | amount).\n   */\n  function subscribe(\n    address assetAddress,\n    bytes32 assetClass,\n    uint256 orderValue,\n    uint256 orderAmount,\n    OrderType orderType,\n    bool executePaymentAtSubscription\n  )\n    external\n    payable\n    returns(uint256)\n  {\n    bytes memory orderData = abi.encode(orderValue, orderAmount, orderType);\n\n    return _subscribe(\n      msg.sender,\n      assetAddress,\n      assetClass,\n      orderData,\n      executePaymentAtSubscription,\n      new bytes(0)\n    );\n  }\n  \n  /**\n   * @dev Subscribe for a given asset, by creating an order.\n   * @param assetAddress Address of the token representing the asset.\n   * @param assetClass Asset class.\n   * @param orderData Encoded pack of variables for order (orderValue, orderAmount, orderType).\n   * @param executePaymentAtSubscription 'true' if payment shall be executed at subscription, 'false' if not.\n   * @param erc1400TokenData Encoded pack of variables for erc1400 token (paymentAddress, paymentPartition, paymentValue).\n   */\n  function _subscribe(\n    address investor,\n    address assetAddress,\n    bytes32 assetClass,\n    bytes memory orderData,\n    bool executePaymentAtSubscription,\n    bytes memory erc1400TokenData\n  )\n    internal\n    returns(uint256)\n  {\n    uint256 lastIndex = _lastCycleIndex[assetAddress][assetClass];\n    CycleState currentState = _getCycleState(lastIndex);\n\n    if(currentState != CycleState.Subscription) {\n      lastIndex = _startNewCycle(assetAddress, assetClass);\n    }\n\n    require(_getCycleState(lastIndex) == CycleState.Subscription, \"Subscription can only be performed during subscription period\");\n\n    (uint256 value, uint256 amount, OrderType orderType) = abi.decode(orderData, (uint256, uint256, OrderType));\n\n    require(value == 0 || amount == 0, \"Order can not be of type amount and value at the same time\");\n\n    if(orderType == OrderType.Value) {\n      require(value != 0, \"Order value shall not be nil\");\n    } else if(orderType == OrderType.Amount) {\n      require(amount != 0, \"Order amount shall not be nil\");\n    } else {\n      revert(\"Order type needs to be value or amount\");\n    }\n\n    _orderIndex++;\n\n    _orders[_orderIndex] = Order({\n      cycleIndex: lastIndex,\n      investor: investor,\n      value: value,\n      amount: amount,\n      orderType: orderType,\n      state: OrderState.Subscribed\n    });\n\n    _cycleOrders[lastIndex].push(_orderIndex);\n\n    _investorOrders[investor].push(_orderIndex);\n\n    Cycle storage cycle = _cycles[lastIndex];\n    if(cycle.assetValueType == AssetValue.Known && executePaymentAtSubscription) {\n      _executePayment(_orderIndex, erc1400TokenData, false);\n    }\n\n    return _orderIndex;\n  }\n\n  /**\n   * @dev Cancel an order.\n   * @param orderIndex Index of the order to cancel.\n   */\n  function cancelOrder(uint256 orderIndex) external {\n    Order storage order = _orders[orderIndex];\n\n    require(\n      order.state == OrderState.Subscribed ||\n      order.state == OrderState.Paid,\n      \"Only subscribed or paid orders can be cancelled\"\n    ); // This also checks if the order exists. Otherwise, we would have \"order.state == OrderState.Undefined\"\n\n    require(_getCycleState(order.cycleIndex) < CycleState.Valuation, \"Orders can only be cancelled before cut-off\");\n\n    require(msg.sender == order.investor);\n\n    if(order.state == OrderState.Paid) {\n      _releasePayment(orderIndex, order.investor);\n    }\n\n    order.state = OrderState.Cancelled;\n  }\n\n  /**\n   * @dev Reject an order.\n   * @param orderIndex Index of the order to reject.\n   * @param rejected Set to 'true' if order shall be rejected, and set to 'false' if rejection shall be cancelled\n   */\n  function rejectOrder(uint256 orderIndex, bool rejected)\n    external\n  {\n    Order storage order = _orders[orderIndex];\n    \n    require(\n      order.state == OrderState.Subscribed ||\n      order.state == OrderState.Paid ||\n      order.state == OrderState.Rejected\n      ,\n      \"Order rejection can only handled for subscribed or paid orders\"\n    ); // This also checks if the order exists. Otherwise, we would have \"order.state == OrderState.Undefined\"\n\n    require(_getCycleState(order.cycleIndex) < CycleState.Payment , \"Orders can only be rejected before beginning of payment phase\");\n\n    Cycle storage cycle = _cycles[order.cycleIndex];\n\n    require(_tokenController(msg.sender, cycle.assetAddress),\n      \"Sender is not a token controller.\"\n    );\n\n    if(rejected) {\n      if(order.state == OrderState.Paid) {\n      _releasePayment(orderIndex, order.investor);\n      }\n      order.state = OrderState.Rejected;\n    } else {\n      order.state = OrderState.Subscribed;\n    }\n  }\n\n  /**\n   * @dev Set assetValue for a given asset.\n   * @param cycleIndex Index of the cycle where assetValue needs to be set.\n   * @param assetValue Units of cash required for a unit of asset.\n   * @param reverseAssetValue Units of asset required for a unit of cash.\n   */\n  function valuate(\n    uint256 cycleIndex,\n    uint256 assetValue,\n    uint256 reverseAssetValue\n  )\n    external\n  {\n    Cycle storage cycle = _cycles[cycleIndex];\n    CycleState cycleState = _getCycleState(cycleIndex);\n\n    require(cycleState > CycleState.Subscription && cycleState < CycleState.Payment , \"AssetValue can only be set during valuation period\");\n\n    require(cycle.assetValueType == AssetValue.Unknown, \"Asset value can only be set for a cycle of type unkonwn\");\n\n    require(assetValue == 0 || reverseAssetValue == 0, \"Asset value can only be set in one direction\");\n\n    require(_checkPriceOracle(cycle.assetAddress, msg.sender), \"Sender is not a price oracle.\");\n    \n    cycle.assetValue = assetValue;\n    cycle.reverseAssetValue = reverseAssetValue;\n  }\n\n  /**\n   * @dev Execute payment for a given order.\n   * @param orderIndex Index of the order to declare as paid.\n   */\n  function executePaymentAsInvestor(uint256 orderIndex) external payable {\n    Order storage order = _orders[orderIndex];\n\n    require(msg.sender == order.investor);\n\n    _executePayment(orderIndex, new bytes(0), false);\n  }\n\n  /**\n   * @dev Set payment as executed for a given order.\n   * @param orderIndex Index of the order to declare as paid.\n   * @param bypassPayment Bypass payment (in case payment has been performed off-chain)\n   */\n  function executePaymentAsController(uint256 orderIndex, bool bypassPayment) external {\n    Order storage order = _orders[orderIndex];\n    Cycle storage cycle = _cycles[order.cycleIndex];\n\n    require(_tokenController(msg.sender, cycle.assetAddress),\n      \"Sender is not a token controller.\"\n    );\n\n    _executePayment(orderIndex, new bytes(0), bypassPayment);\n  }\n\n  /**\n   * @dev Set payments as executed for a batch of given orders.\n   * @param orderIndexes Indexes of the orders to declare as paid.\n   * @param bypassPayment Bypass payment (in case payment has been performed off-chain)\n   */\n  function batchExecutePaymentsAsController(uint256[] calldata orderIndexes, bool bypassPayment)\n    external\n  {\n    for (uint i = 0; i<orderIndexes.length; i++){\n      Order storage order = _orders[orderIndexes[i]];\n      Cycle storage cycle = _cycles[order.cycleIndex];\n\n      require(_tokenController(msg.sender, cycle.assetAddress),\n        \"Sender is not a token controller.\"\n      );\n\n      _executePayment(orderIndexes[i], new bytes(0), bypassPayment);\n    }\n  }\n\n  /**\n   * @dev Pay for a given order.\n   * @param orderIndex Index of the order to declare as paid.\n   * @param erc1400TokenData Encoded pack of variables for erc1400 token (paymentAddress, paymentPartition, paymentValue).\n   * @param bypassPayment Bypass payment (in case payment has been performed off-chain)\n   */\n  function _executePayment(\n    uint256 orderIndex,\n    bytes memory erc1400TokenData,\n    bool bypassPayment\n  )\n    internal\n  {\n    Order storage order = _orders[orderIndex];\n    Cycle storage cycle = _cycles[order.cycleIndex];\n\n    require(\n      order.state == OrderState.Subscribed ||\n      order.state == OrderState.UnpaidSettled,\n      \"Order is neither in state Subscribed, nor UnpaidSettled\"\n    ); // This also checks if the order exists. Otherwise, we would have \"order.state == OrderState.Undefined\"\n\n    require(!cycle.finalized, \"Cycle is already finalized\");\n\n    if(cycle.assetValueType == AssetValue.Unknown) {\n      require(_getCycleState(order.cycleIndex) >= CycleState.Payment , \"Payment can only be performed after valuation period\");\n    } else {\n      require(_getCycleState(order.cycleIndex) >= CycleState.Subscription , \"Payment can only be performed after start of subscription period\");\n    }\n\n    require(order.orderType == OrderType.Value || order.orderType == OrderType.Amount, \"Invalid order type\");\n\n    (uint256 amount, uint256 value) = _getOrderAmountAndValue(orderIndex);\n    order.amount = amount;\n    order.value = value;\n\n    if(!bypassPayment) {\n      if (cycle.paymentType == Payment.ETH) {\n        require(msg.value == value, \"Amount of ETH is not correct\");\n        _escrowedEth[cycle.assetAddress] += value;\n      } else if (cycle.paymentType == Payment.ERC20) {\n        ERC20(cycle.paymentAddress).transferFrom(msg.sender, address(this), value);\n        _escrowedErc20[cycle.assetAddress][cycle.paymentAddress] += value;\n      } else if(cycle.paymentType == Payment.ERC1400 && erc1400TokenData.length == 0) {\n        ERC1400(cycle.paymentAddress).operatorTransferByPartition(cycle.paymentPartition, msg.sender, address(this), value, abi.encodePacked(BYPASS_ACTION_FLAG), abi.encodePacked(BYPASS_ACTION_FLAG));\n        _escrowedErc1400[cycle.assetAddress][cycle.paymentAddress][cycle.paymentPartition] += value;\n      } else if(cycle.paymentType == Payment.ERC1400 && erc1400TokenData.length != 0) {\n        (address erc1400TokenAddress, bytes32 erc1400TokenPartition, uint256 erc1400PaymentValue) = abi.decode(erc1400TokenData, (address, bytes32, uint256));\n        require(erc1400PaymentValue == value, \"wrong payment value\");\n        require(Payment.ERC1400 == cycle.paymentType, \"ERC1400 payment is not accecpted for this asset\");\n        require(erc1400TokenAddress == cycle.paymentAddress, \"wrong payment token address\");\n        require(erc1400TokenPartition == cycle.paymentPartition, \"wrong payment token partition\");\n        _escrowedErc1400[cycle.assetAddress][cycle.paymentAddress][cycle.paymentPartition] += value;\n      } else {\n        revert(\"off-chain payment needs to be bypassed\");\n      }\n    }\n\n    if(order.state == OrderState.UnpaidSettled) {\n      _releasePayment(orderIndex, cycle.fundAddress);\n      order.state = OrderState.PaidSettled;\n    } else {\n      order.state = OrderState.Paid;\n    }\n  }\n\n  /**\n   * @dev Retrieve order amount and order value calculated based on cycle valuation.\n   * @param orderIndex Index of the order.\n   * @return Order amount.\n   * @return Order value.\n   */\n  function _getOrderAmountAndValue(uint256 orderIndex) internal view returns(uint256, uint256) {\n    Order storage order = _orders[orderIndex];\n    Cycle storage cycle = _cycles[order.cycleIndex];\n\n    uint256 value;\n    uint256 amount;\n    if(order.orderType == OrderType.Value) {\n      value = order.value;\n      if(cycle.assetValue != 0) {\n        amount = value.div(cycle.assetValue);\n      } else {\n        amount = value.mul(cycle.reverseAssetValue);\n      }\n    }\n    \n    if(order.orderType == OrderType.Amount) {\n      amount = order.amount;\n      if(cycle.assetValue != 0) {\n        value = amount.mul(cycle.assetValue);\n      } else {\n        value = amount.div(cycle.reverseAssetValue);\n      }\n    }\n\n    return(amount, value);\n\n  }\n\n  /**\n   * @dev Release payment for a given order.\n   * @param orderIndex Index of the order of the payment to be sent.\n   * @param recipient Address to receive to the payment.\n   */\n  function _releasePayment(uint256 orderIndex, address recipient) internal {\n    Order storage order = _orders[orderIndex];\n    Cycle storage cycle = _cycles[order.cycleIndex];\n\n    if(cycle.paymentType == Payment.ETH) {\n      address payable refundAddress = payable(recipient);\n      refundAddress.transfer(order.value);\n      _escrowedEth[cycle.assetAddress] -= order.value;\n    } else if(cycle.paymentType == Payment.ERC20) {\n      ERC20(cycle.paymentAddress).transfer(recipient, order.value);\n      _escrowedErc20[cycle.assetAddress][cycle.paymentAddress] -= order.value;\n    } else if(cycle.paymentType == Payment.ERC1400) {\n      ERC1400(cycle.paymentAddress).transferByPartition(cycle.paymentPartition, recipient, order.value, abi.encodePacked(BYPASS_ACTION_FLAG));\n      _escrowedErc1400[cycle.assetAddress][cycle.paymentAddress][cycle.paymentPartition] -= order.value;\n    }\n  }\n\n  /**\n   * @dev Settle a given order.\n   * @param orderIndex Index of the order to settle.\n   */\n  function settleOrder(uint256 orderIndex) internal {\n    Order storage order = _orders[orderIndex];\n    Cycle storage cycle = _cycles[order.cycleIndex];\n\n    require(_tokenController(msg.sender, cycle.assetAddress),\n      \"Sender is not a token controller.\"\n    );\n\n    _settleOrder(orderIndex);\n  }\n\n  /**\n   * @dev Settle a batch of given orders.\n   * @param orderIndexes Indexes of the orders to settle.\n   */\n  function batchSettleOrders(uint256[] calldata orderIndexes)\n    external\n  {\n    for (uint i = 0; i<orderIndexes.length; i++){\n      Order storage order = _orders[orderIndexes[i]];\n      Cycle storage cycle = _cycles[order.cycleIndex];\n\n      require(_tokenController(msg.sender, cycle.assetAddress),\n        \"Sender is not a token controller.\"\n      );\n\n      _settleOrder(orderIndexes[i]);\n    }\n  }\n\n  /**\n   * @dev Settle a given order.\n   * @param orderIndex Index of the order to settle.\n   */\n  function _settleOrder(uint256 orderIndex) internal {\n    Order storage order = _orders[orderIndex];\n\n    require(order.state > OrderState.Undefined, \"Order doesnt exist\");\n\n    CycleState currentState = _getCycleState(order.cycleIndex);\n\n    Cycle storage cycle = _cycles[order.cycleIndex];\n\n    if(cycle.assetValueType == AssetValue.Unknown) {\n      require(currentState >= CycleState.Settlement, \"Order settlement can only be performed during settlement period\");\n    } else {\n      require(currentState >= CycleState.Valuation, \"Order settlement can only be performed after the cut-off\");\n    }\n\n    _releasePayment(orderIndex, cycle.fundAddress);\n\n    if(order.state == OrderState.Paid) {\n      ERC1400(cycle.assetAddress).issueByPartition(cycle.assetClass, order.investor, order.amount, \"\");\n      order.state = OrderState.PaidSettled;\n    } else if (order.state == OrderState.Subscribed) {\n      ERC1400(cycle.assetAddress).issueByPartition(cycle.assetClass, address(this), order.amount, \"\");\n      order.state = OrderState.UnpaidSettled;\n    } else {\n      revert(\"Impossible to settle an order that is neither in state Paid, nor Subscribed\");\n    }\n  }\n\n  /**\n   * @dev Finalize a given cycle.\n   * @param cycleIndex Index of the cycle to finalize.\n   */\n  function finalizeCycle(uint256 cycleIndex) external {\n    Cycle storage cycle = _cycles[cycleIndex];\n\n    require(_tokenController(msg.sender, cycle.assetAddress),\n      \"Sender is not a token controller.\"\n    );\n\n    require(!cycle.finalized, \"Cycle is already finalized\");\n\n    (, uint256 totalUnpaidSettled, bool remainingOrdersToSettle) = _getTotalSettledForCycle(cycleIndex);\n\n    if(!remainingOrdersToSettle) {\n      cycle.finalized = true;\n      if(totalUnpaidSettled != 0) {\n        ERC1400(cycle.assetAddress).transferByPartition(cycle.assetClass, cycle.fundAddress, totalUnpaidSettled, \"\");\n      }\n    } else {\n      revert(\"Remaining orders to settle\");\n    }\n  }\n\n  /**\n   * @dev Retrieve sum of paid/unpaid settled orders for a given cycle.\n   *\n   * @param cycleIndex Index of the cycle.\n   * @return Sum of paid settled orders.\n   * @return Sum of unpaid settled orders.\n   * @return 'True' if there are remaining orders to settle, 'false' if not.\n   */\n  function getTotalSettledForCycle(uint256 cycleIndex) external view returns(uint256, uint256, bool) {\n    return _getTotalSettledForCycle(cycleIndex);\n  }\n\n  /**\n   * @dev Retrieve sum of paid/unpaid settled orders for a given cycle.\n   *\n   * @param cycleIndex Index of the cycle.\n   * @return Sum of paid settled orders.\n   * @return Sum of unpaid settled orders.\n   * @return 'True' if there are remaining orders to settle, 'false' if not.\n   */\n  function _getTotalSettledForCycle(uint256 cycleIndex) internal view returns(uint256, uint256, bool) {\n    uint256 totalPaidSettled;\n    uint256 totalUnpaidSettled;\n    bool remainingOrdersToSettle;\n\n    for (uint i = 0; i<_cycleOrders[cycleIndex].length; i++){\n      Order storage order = _orders[_cycleOrders[cycleIndex][i]];\n\n      if(order.state == OrderState.PaidSettled) {\n        totalPaidSettled = totalPaidSettled.add(order.amount);\n      } else if(order.state == OrderState.UnpaidSettled) {\n        totalUnpaidSettled = totalUnpaidSettled.add(order.amount);\n      } else if(\n        order.state != OrderState.Cancelled &&\n        order.state != OrderState.Rejected\n      ) {\n        remainingOrdersToSettle = true;\n      }\n\n    }\n\n    return (totalPaidSettled, totalUnpaidSettled, remainingOrdersToSettle);\n  }\n\n  /**\n   * @dev Retrieve the current state of the cycle.\n   *\n   * @param cycleIndex Index of the cycle.\n   * @return Cycle state.\n   */\n  function getCycleState(uint256 cycleIndex) external view returns(CycleState) {\n    return _getCycleState(cycleIndex);\n  }\n\n  /**\n   * @dev Retrieve the current state of the cycle.\n   *\n   * @param cycleIndex Index of the cycle.\n   * @return Cycle state.\n   */\n  function _getCycleState(uint256 cycleIndex) internal view returns(CycleState) {\n    Cycle storage cycle = _cycles[cycleIndex];\n\n    if(block.timestamp < cycle.startTime || cycle.startTime == 0) {\n      return CycleState.Undefined;\n    } else if(block.timestamp < cycle.startTime + cycle.subscriptionPeriodLength) {\n      return CycleState.Subscription;\n    } else if(block.timestamp < cycle.startTime + cycle.subscriptionPeriodLength + cycle.valuationPeriodLength) {\n      return CycleState.Valuation;\n    } else if(block.timestamp < cycle.startTime + cycle.subscriptionPeriodLength + cycle.valuationPeriodLength + cycle.paymentPeriodLength) {\n      return CycleState.Payment;\n    } else if(!cycle.finalized){\n      return CycleState.Settlement; \n    } else {\n      return CycleState.Finalized;\n    }\n  }\n\n  /**\n   * @dev Check if the sender is a token controller.\n   *\n   * @param sender Transaction sender.\n   * @param assetAddress Address of the token representing the asset.\n   * @return Returns 'true' if sender is a token controller.\n   */\n  function _tokenController(address sender, address assetAddress) internal view returns(bool) {\n    if(sender == Ownable(assetAddress).owner() ||\n      _isTokenController[assetAddress][sender]) {\n      return true;\n    } else {\n      return false;\n    }\n\n  }\n\n  /**\n   * @dev Indicate whether or not the fund issuance contract can receive the tokens.\n   *\n   * By convention, the 32 first bytes of a token transfer to the fund issuance smart contract contain a flag.\n   *\n   *  - When tokens are transferred to fund issuance contract to create a new order, the 'data' field starts with the\n   *  following flag: 0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n   *  In this case the data structure is the the following:\n   *  <transferFlag (32 bytes)><asset address (32 bytes)><asset class (32 bytes)><order data (3 * 32 bytes)>\n   *\n   *  - When tokens are transferred to fund issuance contract to pay for an existing order, the 'data' field starts with the\n   *  following flag: 0xdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd\n   *  In this case the data structure is the the following:\n   *  <transferFlag (32 bytes)><order index (32 bytes)>\n   *\n   * If the 'data' doesn't start with one of those flags, the fund issuance contract won't accept the token transfer.\n   *\n   * @param data Information attached to the token transfer to fund issuance contract.\n   * @param operatorData Information attached to the token transfer to fund issuance contract, by the operator.\n   * @return 'true' if the fund issuance contract can receive the tokens, 'false' if not.\n   */\n  function _canReceive(bytes memory data, bytes memory operatorData) internal pure returns(bool) {\n    if(operatorData.length == 0) { // The reason for this check is to avoid a certificate gets interpreted as a flag by mistake\n      return false;\n    }\n    \n    bytes32 flag = _getTransferFlag(data);\n    if(data.length == 192 && flag == ORDER_SUBSCRIPTION_FLAG) {\n      return true;\n    } else if(data.length == 64 && flag == ORDER_PAYMENT_FLAG) {\n      return true;\n    } else if (data.length == 32 && flag == BYPASS_ACTION_FLAG) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Retrieve the transfer flag from the 'data' field.\n   *\n   * By convention, the 32 first bytes of a token transfer to the fund issuance smart contract contain a flag.\n   *  - When tokens are transferred to fund issuance contract to create a new order, the 'data' field starts with the\n   *  following flag: 0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n   *  - When tokens are transferred to fund issuance contract to pay for an existing order, the 'data' field starts with the\n   *  following flag: 0xdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd\n   *\n   * @param data Concatenated information about the transfer.\n   * @return flag Transfer flag.\n   */\n  function _getTransferFlag(bytes memory data) internal pure returns(bytes32 flag) {\n    assembly {\n      flag:= mload(add(data, 32))\n    }\n  }\n\n  /**\n   * By convention, when tokens are transferred to fund issuance contract to create a new order, the 'data' of a token transfer has the following structure:\n   *  <transferFlag (32 bytes)><asset address (32 bytes)><asset class (32 bytes)><order data (3 * 32 bytes)>\n   *\n   * The first 32 bytes are the flag 0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n   *\n   * The next 32 bytes contain the order index.\n   *\n   * Example input for asset address '0xb5747835141b46f7C472393B31F8F5A57F74A44f',\n   * asset class '37252', order type 'Value', and value 12000\n   * 0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc000000000000000000000000b5747835141b46f7C472393B31F8F5A57F74A44f\n   * 000000000000000000000000000000000000000000000000000000000037252000000000000000000000000000000000000000000000000000000000000001\n   * 000000000000000000000000000000000000000000000000000000000002ee0000000000000000000000000000000000000000000000000000000000000000\n   *\n   */\n  function _getAssetAddress(bytes memory data) internal pure returns(address assetAddress) {\n    assembly {\n      assetAddress:= mload(add(data, 64))\n    }\n  }\n\n  function _getAssetClass(bytes memory data) internal pure returns(bytes32 assetClass) {\n    assembly {\n      assetClass:= mload(add(data, 96))\n    }\n  }\n\n  function _getOrderData(bytes memory data) internal pure returns(bytes memory orderData) {\n    uint256 orderValue;\n    uint256 orderAmount;\n    OrderType orderType;\n    assembly {\n      orderValue:= mload(add(data, 128))\n      orderAmount:= mload(add(data, 160))\n      orderType:= mload(add(data, 192))\n    }\n    orderData = abi.encode(orderValue, orderAmount, orderType);\n  }\n\n  /**\n   * By convention, when tokens are transferred to fund issuance contract to pay for an existing order, the 'data' of a token transfer has the following structure:\n   *  <transferFlag (32 bytes)><order index (32 bytes)>\n   *\n   * The first 32 bytes are the flag 0xdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd\n   *\n   * The next 32 bytes contain the order index.\n   *\n   * Example input for order index 3:\n   * 0xdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd000000000000000000000000000000000000000000000000000000000000003\n   *\n   */\n\n  /**\n   * @dev Retrieve the order index from the 'data' field.\n   *\n   * @param data Concatenated information about the order payment.\n   * @return orderIndex Order index.\n   */\n  function _getOrderIndex(bytes memory data) internal pure returns(uint256 orderIndex) {\n    assembly {\n      orderIndex:= mload(add(data, 64))\n    }\n  }\n\n  /************************** TOKEN CONTROLLERS *******************************/\n\n  /**\n   * @dev Get the list of token controllers for a given token.\n   * @param tokenAddress Token address.\n   * @return List of addresses of all the token controllers for a given token.\n   */\n  function tokenControllers(address tokenAddress) external view returns (address[] memory) {\n    return _tokenControllers[tokenAddress];\n  }\n\n  /**\n   * @dev Set list of token controllers for a given token.\n   * @param tokenAddress Token address.\n   * @param operators Operators addresses.\n   */\n  function setTokenControllers(address tokenAddress, address[] calldata operators) external onlyTokenController(tokenAddress) {\n    _setTokenControllers(tokenAddress, operators);\n  }\n\n  /**\n   * @dev Set list of token controllers for a given token.\n   * @param tokenAddress Token address.\n   * @param operators Operators addresses.\n   */\n  function _setTokenControllers(address tokenAddress, address[] memory operators) internal {\n    for (uint i = 0; i<_tokenControllers[tokenAddress].length; i++){\n      _isTokenController[tokenAddress][_tokenControllers[tokenAddress][i]] = false;\n    }\n    for (uint j = 0; j<operators.length; j++){\n      _isTokenController[tokenAddress][operators[j]] = true;\n    }\n    _tokenControllers[tokenAddress] = operators;\n  }\n\n  /************************** TOKEN PRICE ORACLES *******************************/\n\n  /**\n   * @dev Get the list of price oracles for a given token.\n   * @param tokenAddress Token address.\n   * @return List of addresses of all the price oracles for a given token.\n   */\n  function priceOracles(address tokenAddress) external view returns (address[] memory) {\n    return _priceOracles[tokenAddress];\n  }\n\n  /**\n   * @dev Set list of price oracles for a given token.\n   * @param tokenAddress Token address.\n   * @param oracles Oracles addresses.\n   */\n  function setPriceOracles(address tokenAddress, address[] calldata oracles) external onlyPriceOracle(tokenAddress) {\n    _setPriceOracles(tokenAddress, oracles);\n  }\n\n  /**\n   * @dev Set list of price oracles for a given token.\n   * @param tokenAddress Token address.\n   * @param oracles Oracles addresses.\n   */\n  function _setPriceOracles(address tokenAddress, address[] memory oracles) internal {\n    for (uint i = 0; i<_priceOracles[tokenAddress].length; i++){\n      _isPriceOracle[tokenAddress][_priceOracles[tokenAddress][i]] = false;\n    }\n    for (uint j = 0; j<oracles.length; j++){\n      _isPriceOracle[tokenAddress][oracles[j]] = true;\n    }\n    _priceOracles[tokenAddress] = oracles;\n  }\n\n  /**\n   * @dev Check if address is oracle of a given token.\n   * @param tokenAddress Token address.\n   * @param oracle Oracle address.\n   * @return 'true' if the address is oracle of the given token.\n   */\n  function _checkPriceOracle(address tokenAddress, address oracle) internal view returns(bool) {\n    return(_isPriceOracle[tokenAddress][oracle] || oracle == Ownable(tokenAddress).owner());\n  }\n\n  /**************************** VIEW FUNCTIONS *******************************/\n\n  /**\n   * @dev Get asset rules.\n   * @param assetAddress Address of the asset.\n   * @param assetClass Class of the asset.\n   * @return Asset rules.\n   */\n  function getAssetRules(address assetAddress, bytes32 assetClass)\n    external\n    view\n    returns(uint256, uint256, uint256, uint256, Payment, address, bytes32, address, bool)\n  {\n    AssetRules storage rules = _assetRules[assetAddress][assetClass];\n    return (\n      rules.firstStartTime,\n      rules.subscriptionPeriodLength,\n      rules.valuationPeriodLength,\n      rules.paymentPeriodLength,\n      rules.paymentType,\n      rules.paymentAddress,\n      rules.paymentPartition,\n      rules.fundAddress,\n      rules.subscriptionsOpened\n    );\n\n  }\n\n  /**\n   * @dev Get the cycle asset value rules.\n   * @param assetAddress Address of the asset.\n   * @param assetClass Class of the asset.\n   * @return Asset value rules.\n   */\n  function getAssetValueRules(address assetAddress, bytes32 assetClass) external view returns(AssetValue, uint256, uint256) {\n    AssetRules storage rules = _assetRules[assetAddress][assetClass];\n    return (\n      rules.assetValueType,\n      rules.assetValue,\n      rules.reverseAssetValue\n    );\n  }\n\n  /**\n   * @dev Get total number of cycles in the contract.\n   * @return Number of cycles.\n   */\n  function getNbCycles() external view returns(uint256) {\n    return _cycleIndex;\n  }\n\n  /**\n   * @dev Get the index of the last cycle created for a given asset class.\n   * @param assetAddress Address of the token representing the asset.\n   * @param assetClass Asset class.\n   * @return Cycle index.\n   */\n  function getLastCycleIndex(address assetAddress, bytes32 assetClass) external view returns(uint256) {\n    return _lastCycleIndex[assetAddress][assetClass];\n  }\n\n  /**\n   * @dev Get the cycle.\n   * @param index Index of the cycle.\n   * @return Cycle.\n   */\n  function getCycle(uint256 index) external view returns(address, bytes32, uint256, uint256, uint256, uint256, Payment, address, bytes32, bool) {\n    Cycle storage cycle = _cycles[index];\n    return (\n      cycle.assetAddress,\n      cycle.assetClass,\n      cycle.startTime,\n      cycle.subscriptionPeriodLength,\n      cycle.valuationPeriodLength,\n      cycle.paymentPeriodLength,\n      cycle.paymentType,\n      cycle.paymentAddress,\n      cycle.paymentPartition,\n      cycle.finalized\n    );\n  }\n\n  /**\n   * @dev Get the cycle asset value.\n   * @param index Index of the cycle.\n   * @return Cycle.\n   */\n  function getCycleAssetValue(uint256 index) external view returns(AssetValue, uint256, uint256) {\n    Cycle storage cycle = _cycles[index];\n    return (\n      cycle.assetValueType,\n      cycle.assetValue,\n      cycle.reverseAssetValue\n    );\n  }\n\n  /**\n   * @dev Get total number of orders in the contract.\n   * @return Number of orders.\n   */\n  function getNbOrders() external view returns(uint256) {\n    return _orderIndex;\n  }\n\n  /**\n   * @dev Retrieve an order.\n   * @param index Index of the order.\n   * @return Order.\n   */\n  function getOrder(uint256 index) external view returns(uint256, address, uint256, uint256, OrderType, OrderState) {\n    Order storage order = _orders[index];\n    return (\n      order.cycleIndex,\n      order.investor,\n      order.value,\n      order.amount,\n      order.orderType,\n      order.state\n    );\n  }\n\n  /**\n   * @dev Retrieve order amount and order value calculated based on cycle valuation.\n   * @param orderIndex Index of the order.\n   * @return Order amount.\n   * @return Order value.\n   */\n  function getOrderAmountAndValue(uint256 orderIndex) external view returns(uint256, uint256) {\n    return _getOrderAmountAndValue(orderIndex);\n  }\n\n  /**\n   * @dev Get list of cycle orders.\n   * @param index Index of the cycle.\n   * @return List of cycle orders.\n   */\n  function getCycleOrders(uint256 index) external view returns(uint256[] memory) {\n    return _cycleOrders[index];\n  }\n\n  /**\n   * @dev Get list of investor orders.\n   * @return List of investor orders.\n   */\n  function getInvestorOrders(address investor) external view returns(uint256[] memory) {\n    return _investorOrders[investor];\n  }\n\n }\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/tokens/ERC1400HoldableToken.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1400.sol\";\n\n/**\n * @notice Interface to the extension types\n */\ninterface IExtensionTypes {\n  enum CertificateValidation {\n    None,\n    NonceBased,\n    SaltBased\n  }\n}\n\n/**\n * @notice Interface to the extension contract\n */\nabstract contract Extension is IExtensionTypes {\n  function registerTokenSetup(\n    address token,\n    CertificateValidation certificateActivated,\n    bool allowlistActivated,\n    bool blocklistActivated,\n    bool granularityByPartitionActivated,\n    bool holdsActivated,\n    address[] calldata operators\n  ) external virtual;\n}\n\ncontract ERC1400HoldableToken is ERC1400, IExtensionTypes {\n\n  /**\n   * @dev Initialize ERC1400 + setup the token extension.\n   * @param name Name of the token.\n   * @param symbol Symbol of the token.\n   * @param granularity Granularity of the token.\n   * @param controllers Array of initial controllers.\n   * @param defaultPartitions Partitions chosen by default, when partition is\n   * not specified, like the case ERC20 tranfers.\n   * @param extension Address of token extension.\n   * @param newOwner Address whom contract ownership shall be transferred to.\n   */\n  constructor(\n    string memory name,\n    string memory symbol,\n    uint256 granularity,\n    address[] memory controllers,\n    bytes32[] memory defaultPartitions,\n    address extension,\n    address newOwner\n  )\n    public\n    ERC1400(name, symbol, granularity, controllers, defaultPartitions)\n  {\n    if(extension != address(0)) {\n      Extension(extension).registerTokenSetup(\n        address(this), // token\n        CertificateValidation.None, // certificateActivated\n        true, // allowlistActivated\n        true, // blocklistActivated\n        true, // granularityByPartitionActivated\n        true, // holdsActivated\n        controllers // token controllers\n      );\n\n      _setTokenExtension(extension, ERC1400_TOKENS_VALIDATOR, true, true, true);\n    }\n\n    if(newOwner != address(0)) {\n      transferOwnership(newOwner);\n    }\n  }\n\n}"
    },
    "contracts/mocks/FakeERC1400Mock.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1400.sol\";\n\n/**\n * @notice Interface to the extension contract\n */\nabstract contract ExtensionMock {\n  function addCertificateSigner(\n    address token,\n    address account\n  ) external virtual;\n  function addAllowlistAdmin(\n    address token,\n    address account\n  ) external virtual;\n  function addBlocklistAdmin(\n    address token,\n    address account\n  ) external virtual;\n  function addPauser(\n    address token,\n    address account\n  ) external virtual;\n}\n\ncontract FakeERC1400Mock is ERC1400 {\n\n  constructor(\n    string memory name,\n    string memory symbol,\n    uint256 granularity,\n    address[] memory controllers,\n    bytes32[] memory defaultPartitions,\n    address extension,\n    address mockAddress\n  )\n    public\n    ERC1400(name, symbol, granularity, controllers, defaultPartitions)\n  {\n    if(extension != address(0)) {\n      ExtensionMock(extension).addCertificateSigner(address(this), mockAddress);\n      ExtensionMock(extension).addAllowlistAdmin(address(this), mockAddress);\n      ExtensionMock(extension).addBlocklistAdmin(address(this), mockAddress);\n      ExtensionMock(extension).addPauser(address(this), mockAddress);\n    }\n  }\n\n  /**\n   * Override function to allow calling \"tokensReceived\" hook with wrong recipient (\"to\")\n   */\n  function _callRecipientExtension(\n    bytes32 partition,\n    address operator,\n    address from,\n    address to,\n    uint256 value,\n    bytes memory data,\n    bytes memory operatorData\n  )\n    internal\n    override\n  {\n    address recipientImplementation;\n    recipientImplementation = interfaceAddr(to, ERC1400_TOKENS_RECIPIENT);\n\n    if (recipientImplementation != address(0)) {\n      IERC1400TokensRecipient(recipientImplementation).tokensReceived(msg.data, partition, operator, from, from, value, data, operatorData);\n    }\n  }\n\n  /**\n   * Override function to allow redeeming tokens from address(0)\n   */\n  function transferFromWithData(address from, address to, uint256 value, bytes calldata /*data*/) external override {\n    _transferWithData(from, to, value);\n  }\n\n  /**\n   * Override function to allow redeeming tokens from address(0)\n   */\n  function redeemFrom(address from, uint256 value, bytes calldata data)\n    external override\n  {\n    _redeem(msg.sender, from, value, data);\n  }\n\n}\n"
    },
    "contracts/certificate/ERC1400HoldableCertificateToken.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\n/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.8.0;\n\nimport \"../ERC1400.sol\";\n\n/**\n * @notice Interface to the extension types\n */\ninterface IExtensionTypes {\n  enum CertificateValidation {\n    None,\n    NonceBased,\n    SaltBased\n  }\n}\n\n/**\n * @notice Interface to the extension contract\n */\nabstract contract Extension is IExtensionTypes {\n  function registerTokenSetup(\n    address token,\n    CertificateValidation certificateActivated,\n    bool allowlistActivated,\n    bool blocklistActivated,\n    bool granularityByPartitionActivated,\n    bool holdsActivated,\n    address[] calldata operators\n  ) external virtual;\n\n  function addCertificateSigner(\n    address token,\n    address account\n  ) external virtual;\n}\n\n\n/**\n * @title ERC1400HoldableCertificateNonceToken\n * @dev Holdable ERC1400 with nonce-based certificate controller logic\n */\ncontract ERC1400HoldableCertificateToken is ERC1400, IExtensionTypes {\n\n  /**\n   * @dev Initialize ERC1400 + initialize certificate controller.\n   * @param name Name of the token.\n   * @param symbol Symbol of the token.\n   * @param granularity Granularity of the token.\n   * @param controllers Array of initial controllers.\n   * @param defaultPartitions Partitions chosen by default, when partition is\n   * not specified, like the case ERC20 tranfers.\n   * @param extension Address of token extension.\n   * @param newOwner Address whom contract ownership shall be transferred to.\n   * @param certificateSigner Address of the off-chain service which signs the\n   * conditional ownership certificates required for token transfers, issuance,\n   * redemption (Cf. CertificateController.sol).\n   * @param certificateActivated If set to 'true', the certificate controller\n   * is activated at contract creation.\n   */\n  constructor(\n    string memory name,\n    string memory symbol,\n    uint256 granularity,\n    address[] memory controllers,\n    bytes32[] memory defaultPartitions,\n    address extension,\n    address newOwner,\n    address certificateSigner,\n    CertificateValidation certificateActivated\n  )\n    public\n    ERC1400(name, symbol, granularity, controllers, defaultPartitions)\n  {\n    if(extension != address(0)) {\n      Extension(extension).registerTokenSetup(\n        address(this), // token\n        certificateActivated, // certificateActivated\n        true, // allowlistActivated\n        true, // blocklistActivated\n        true, // granularityByPartitionActivated\n        true, // holdsActivated\n        controllers // token controllers\n      );\n\n      if(certificateSigner != address(0)) {\n        Extension(extension).addCertificateSigner(address(this), certificateSigner);\n      }\n\n      _setTokenExtension(extension, ERC1400_TOKENS_VALIDATOR, true, true, true);\n    }\n\n    if(newOwner != address(0)) {\n      transferOwnership(newOwner);\n    }\n  }\n\n  /************************************** Transfer Validity ***************************************/\n  /**\n   * @dev Know the reason on success or failure based on the EIP-1066 application-specific status codes.\n   * @param partition Name of the partition.\n   * @param to Token recipient.\n   * @param value Number of tokens to transfer.\n   * @param data Information attached to the transfer, by the token holder. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\n   * @return ESC (Ethereum Status Code) following the EIP-1066 standard.\n   * @return Additional bytes32 parameter that can be used to define\n   * application specific reason codes with additional details (for example the\n   * transfer restriction rule responsible for making the transfer operation invalid).\n   * @return Destination partition.\n   */\n  function canTransferByPartition(bytes32 partition, address to, uint256 value, bytes calldata data)\n    external\n    view\n    returns (bytes1, bytes32, bytes32)\n  {\n    return ERC1400._canTransfer(\n      _replaceFunctionSelector(this.transferByPartition.selector, msg.data), // 0xf3d490db: 4 first bytes of keccak256(transferByPartition(bytes32,address,uint256,bytes))\n      partition,\n      msg.sender,\n      msg.sender,\n      to,\n      value,\n      data,\n      \"\"\n    );\n  }\n  /**\n   * @dev Know the reason on success or failure based on the EIP-1066 application-specific status codes.\n   * @param partition Name of the partition.\n   * @param from Token holder.\n   * @param to Token recipient.\n   * @param value Number of tokens to transfer.\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\n   * @param operatorData Information attached to the transfer, by the operator. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\n   * @return ESC (Ethereum Status Code) following the EIP-1066 standard.\n   * @return Additional bytes32 parameter that can be used to define\n   * application specific reason codes with additional details (for example the\n   * transfer restriction rule responsible for making the transfer operation invalid).\n   * @return Destination partition.\n   */\n  function canOperatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData)\n    external\n    view\n    returns (bytes1, bytes32, bytes32)\n  {\n    return ERC1400._canTransfer(\n      _replaceFunctionSelector(this.operatorTransferByPartition.selector, msg.data), // 0x8c0dee9c: 4 first bytes of keccak256(operatorTransferByPartition(bytes32,address,address,uint256,bytes,bytes))\n      partition,\n      msg.sender,\n      from,\n      to,\n      value,\n      data,\n      operatorData\n    );\n  }\n  /**\n   * @dev Replace function selector\n   * @param functionSig Replacement function selector.\n   * @param payload Payload, where function selector needs to be replaced.\n   */\n  function _replaceFunctionSelector(bytes4 functionSig, bytes memory payload) internal pure returns(bytes memory) {\n    bytes memory updatedPayload = new bytes(payload.length);\n    for (uint i = 0; i<4; i++){\n      updatedPayload[i] = functionSig[i];\n    }\n    for (uint j = 4; j<payload.length; j++){\n      updatedPayload[j] = payload[j];\n    }\n    return updatedPayload;\n  }\n  /************************************************************************************************/\n\n}"
    },
    "contracts/extensions/tokenExtensions/ERC1400TokensValidator.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\n/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../tools/Pausable.sol\";\nimport \"../../roles/CertificateSignerRole.sol\";\nimport \"../../roles/AllowlistedRole.sol\";\nimport \"../../roles/BlocklistedRole.sol\";\n\nimport \"../../interface/IHoldableERC1400TokenExtension.sol\";\nimport \"../../tools/ERC1820Client.sol\";\nimport \"../../tools/DomainAware.sol\";\nimport \"../../interface/ERC1820Implementer.sol\";\n\nimport \"../../IERC1400.sol\";\n\nimport \"./IERC1400TokensValidator.sol\";\n\n/**\n * @notice Interface to the Minterrole contract\n */\ninterface IMinterRole {\n  function isMinter(address account) external view returns (bool);\n}\n\n\ncontract ERC1400TokensValidator is IERC1400TokensValidator, Pausable, CertificateSignerRole, AllowlistedRole, BlocklistedRole, ERC1820Client, ERC1820Implementer, IHoldableERC1400TokenExtension {\n  using SafeMath for uint256;\n\n  string constant internal ERC1400_TOKENS_VALIDATOR = \"ERC1400TokensValidator\";\n\n  bytes4 constant internal ERC20_TRANSFER_ID = bytes4(keccak256(\"transfer(address,uint256)\"));\n  bytes4 constant internal ERC20_TRANSFERFROM_ID = bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n\n  bytes32 constant internal ZERO_ID = 0x00000000000000000000000000000000;\n\n  // Mapping from token to token controllers.\n  mapping(address => address[]) internal _tokenControllers;\n\n  // Mapping from (token, operator) to token controller status.\n  mapping(address => mapping(address => bool)) internal _isTokenController;\n\n  // Mapping from token to allowlist activation status.\n  mapping(address => bool) internal _allowlistActivated;\n\n  // Mapping from token to blocklist activation status.\n  mapping(address => bool) internal _blocklistActivated;\n\n  // Mapping from token to certificate activation status.\n  mapping(address => CertificateValidation) internal _certificateActivated;\n\n  enum CertificateValidation {\n    None,\n    NonceBased,\n    SaltBased\n  }\n\n  // Mapping from (token, certificateNonce) to \"used\" status to ensure a certificate can be used only once\n  mapping(address => mapping(address => uint256)) internal _usedCertificateNonce;\n\n  // Mapping from (token, certificateSalt) to \"used\" status to ensure a certificate can be used only once\n  mapping(address => mapping(bytes32 => bool)) internal _usedCertificateSalt;\n\n  // Mapping from token to partition granularity activation status.\n  mapping(address => bool) internal _granularityByPartitionActivated;\n\n  // Mapping from token to holds activation status.\n  mapping(address => bool) internal _holdsActivated;\n\n  struct Hold {\n    bytes32 partition;\n    address sender;\n    address recipient;\n    address notary;\n    uint256 value;\n    uint256 expiration;\n    bytes32 secretHash;\n    bytes32 secret;\n    HoldStatusCode status;\n  }\n\n  // Mapping from (token, partition) to partition granularity.\n  mapping(address => mapping(bytes32 => uint256)) internal _granularityByPartition;\n  \n  // Mapping from (token, holdId) to hold.\n  mapping(address => mapping(bytes32 => Hold)) internal _holds;\n\n  // Mapping from (token, tokenHolder) to balance on hold.\n  mapping(address => mapping(address => uint256)) internal _heldBalance;\n\n  // Mapping from (token, tokenHolder, partition) to balance on hold of corresponding partition.\n  mapping(address => mapping(address => mapping(bytes32 => uint256))) internal _heldBalanceByPartition;\n\n  // Mapping from (token, partition) to global balance on hold of corresponding partition.\n  mapping(address => mapping(bytes32 => uint256)) internal _totalHeldBalanceByPartition;\n\n  // Total balance on hold.\n  mapping(address => uint256) internal _totalHeldBalance;\n\n  // Mapping from hash to hold ID.\n  mapping(bytes32 => bytes32) internal _holdIds;\n\n  event HoldCreated(\n    address indexed token,\n    bytes32 indexed holdId,\n    bytes32 partition,\n    address sender,\n    address recipient,\n    address indexed notary,\n    uint256 value,\n    uint256 expiration,\n    bytes32 secretHash\n  );\n  event HoldReleased(address indexed token, bytes32 holdId, address indexed notary, HoldStatusCode status);\n  event HoldRenewed(address indexed token, bytes32 holdId, address indexed notary, uint256 oldExpiration, uint256 newExpiration);\n  event HoldExecuted(address indexed token, bytes32 holdId, address indexed notary, uint256 heldValue, uint256 transferredValue, bytes32 secret);\n  event HoldExecutedAndKeptOpen(address indexed token, bytes32 holdId, address indexed notary, uint256 heldValue, uint256 transferredValue, bytes32 secret);\n  \n  /**\n   * @dev Modifier to verify if sender is a token controller.\n   */\n  modifier onlyTokenController(address token) {\n    require(\n      msg.sender == token ||\n      msg.sender == Ownable(token).owner() ||\n      _isTokenController[token][msg.sender],\n      \"Sender is not a token controller.\"\n    );\n    _;\n  }\n\n  /**\n   * @dev Modifier to verify if sender is a pauser.\n   */\n  modifier onlyPauser(address token) override {\n    require(\n      msg.sender == token ||\n      msg.sender == Ownable(token).owner() ||\n      _isTokenController[token][msg.sender] ||\n      isPauser(token, msg.sender),\n      \"Sender is not a pauser\"\n    );\n    _;\n  }\n\n  /**\n   * @dev Modifier to verify if sender is a pauser.\n   */\n  modifier onlyCertificateSigner(address token) override {\n    require(\n      msg.sender == token ||\n      msg.sender == Ownable(token).owner() ||\n      _isTokenController[token][msg.sender] ||\n      isCertificateSigner(token, msg.sender),\n      \"Sender is not a certificate signer\"\n    );\n    _;\n  }\n\n  /**\n   * @dev Modifier to verify if sender is an allowlist admin.\n   */\n  modifier onlyAllowlistAdmin(address token) override {\n    require(\n      msg.sender == token ||\n      msg.sender == Ownable(token).owner() ||\n      _isTokenController[token][msg.sender] ||\n      isAllowlistAdmin(token, msg.sender),\n      \"Sender is not an allowlist admin\"\n    );\n    _;\n  }\n\n  /**\n   * @dev Modifier to verify if sender is a blocklist admin.\n   */\n  modifier onlyBlocklistAdmin(address token) override {\n    require(\n      msg.sender == token ||\n      msg.sender == Ownable(token).owner() ||\n      _isTokenController[token][msg.sender] ||\n      isBlocklistAdmin(token, msg.sender),\n      \"Sender is not a blocklist admin\"\n    );\n    _;\n  }\n\n  constructor() {\n    ERC1820Implementer._setInterface(ERC1400_TOKENS_VALIDATOR);\n\n\n  }\n\n  /**\n   * @dev Get the list of token controllers for a given token.\n   * @return Setup of a given token.\n   */\n  function retrieveTokenSetup(address token) external view returns (CertificateValidation, bool, bool, bool, bool, address[] memory) {\n    return (\n      _certificateActivated[token],\n      _allowlistActivated[token],\n      _blocklistActivated[token],\n      _granularityByPartitionActivated[token],\n      _holdsActivated[token],\n      _tokenControllers[token]\n    );\n  }\n\n  /**\n   * @dev Register token setup.\n   */\n  function registerTokenSetup(\n    address token,\n    CertificateValidation certificateActivated,\n    bool allowlistActivated,\n    bool blocklistActivated,\n    bool granularityByPartitionActivated,\n    bool holdsActivated,\n    address[] calldata operators\n  ) external onlyTokenController(token) {\n    _certificateActivated[token] = certificateActivated;\n    _allowlistActivated[token] = allowlistActivated;\n    _blocklistActivated[token] = blocklistActivated;\n    _granularityByPartitionActivated[token] = granularityByPartitionActivated;\n    _holdsActivated[token] = holdsActivated;\n    _setTokenControllers(token, operators);\n  }\n\n  /**\n   * @dev Set list of token controllers for a given token.\n   * @param token Token address.\n   * @param operators Operators addresses.\n   */\n  function _setTokenControllers(address token, address[] memory operators) internal {\n    for (uint i = 0; i<_tokenControllers[token].length; i++){\n      _isTokenController[token][_tokenControllers[token][i]] = false;\n    }\n    for (uint j = 0; j<operators.length; j++){\n      _isTokenController[token][operators[j]] = true;\n    }\n    _tokenControllers[token] = operators;\n  }\n\n  /**\n   * @dev Verify if a token transfer can be executed or not, on the validator's perspective.\n   * @param data The struct containing the validation information.\n   * @return 'true' if the token transfer can be validated, 'false' if not.\n   */\n  function canValidate(IERC1400TokensValidator.ValidateData calldata data) // Comments to avoid compilation warnings for unused variables.\n    external\n    override\n    view \n    returns(bool)\n  {\n    (bool canValidateToken,,) = _canValidateCertificateToken(data.token, data.payload, data.operator, data.operatorData.length != 0 ? data.operatorData : data.data);\n\n    canValidateToken = canValidateToken && _canValidateAllowlistAndBlocklistToken(data.token, data.payload, data.from, data.to);\n    \n    canValidateToken = canValidateToken && !paused(data.token);\n\n    canValidateToken = canValidateToken && _canValidateGranularToken(data.token, data.partition, data.value);\n\n    canValidateToken = canValidateToken && _canValidateHoldableToken(data.token, data.partition, data.operator, data.from, data.to, data.value);\n\n    return canValidateToken;\n  }\n\n  /**\n   * @dev Function called by the token contract before executing a transfer.\n   * @param payload Payload of the initial transaction.\n   * @param partition Name of the partition (left empty for ERC20 transfer).\n   * @param operator Address which triggered the balance decrease (through transfer or redemption).\n   * @param from Token holder.\n   * @param to Token recipient for a transfer and 0x for a redemption.\n   * @param value Number of tokens the token holder balance is decreased by.\n   * @param data Extra information.\n   * @param operatorData Extra information, attached by the operator (if any).\n   */\n  function tokensToValidate(\n    bytes calldata payload,\n    bytes32 partition,\n    address operator,\n    address from,\n    address to,\n    uint value,\n    bytes calldata data,\n    bytes calldata operatorData\n  ) // Comments to avoid compilation warnings for unused variables.\n    external\n    override\n  {\n    //Local scope variables to avoid stack too deep\n    {\n        (bool canValidateCertificateToken, CertificateValidation certificateControl, bytes32 salt) = _canValidateCertificateToken(msg.sender, payload, operator, operatorData.length != 0 ? operatorData : data);\n        require(canValidateCertificateToken, \"54\"); // 0x54\ttransfers halted (contract paused)\n\n        _useCertificateIfActivated(msg.sender, certificateControl, operator, salt);\n    }\n\n    {\n        require(_canValidateAllowlistAndBlocklistToken(msg.sender, payload, from, to), \"54\"); // 0x54\ttransfers halted (contract paused)\n    }\n    \n    {\n        require(!paused(msg.sender), \"54\"); // 0x54\ttransfers halted (contract paused)\n    }\n    \n    {\n        require(_canValidateGranularToken(msg.sender, partition, value), \"50\"); // 0x50\ttransfer failure\n\n        require(_canValidateHoldableToken(msg.sender, partition, operator, from, to, value), \"55\"); // 0x55\tfunds locked (lockup period)\n    }\n    \n    {\n        (, bytes32 holdId) = _retrieveHoldHashId(msg.sender, partition, operator, from, to, value);\n        if (_holdsActivated[msg.sender] && holdId != \"\") {\n          Hold storage executableHold = _holds[msg.sender][holdId];\n          _setHoldToExecuted(\n            msg.sender,\n            executableHold,\n            holdId,\n            value,\n            executableHold.value,\n            \"\"\n          );\n        }\n    }\n  }\n\n  /**\n   * @dev Verify if a token transfer can be executed or not, on the validator's perspective.\n   * @return 'true' if the token transfer can be validated, 'false' if not.\n   * @return hold ID in case a hold can be executed for the given parameters.\n   */\n  function _canValidateCertificateToken(\n    address token,\n    bytes memory payload,\n    address operator,\n    bytes memory certificate\n  )\n    internal\n    view\n    returns(bool, CertificateValidation, bytes32)\n  {\n    if(\n      _certificateActivated[token] > CertificateValidation.None &&\n      _functionSupportsCertificateValidation(payload) &&\n      !isCertificateSigner(token, operator) &&\n      address(this) != operator\n    ) {\n      if(_certificateActivated[token] == CertificateValidation.SaltBased) {\n        (bool valid, bytes32 salt) = _checkSaltBasedCertificate(\n          token,\n          operator,\n          payload,\n          certificate\n        );\n        if(valid) {\n          return (true, CertificateValidation.SaltBased, salt);\n        } else {\n          return (false, CertificateValidation.SaltBased, \"\");\n        }\n        \n      } else { // case when _certificateActivated[token] == CertificateValidation.NonceBased\n        if(\n          _checkNonceBasedCertificate(\n            token,\n            operator,\n            payload,\n            certificate\n          )\n        ) {\n          return (true, CertificateValidation.NonceBased, \"\");\n        } else {\n          return (false, CertificateValidation.NonceBased, \"\");\n        }\n      }\n    }\n\n    return (true, CertificateValidation.None, \"\");\n  }\n\n  /**\n   * @dev Verify if a token transfer can be executed or not, on the validator's perspective.\n   * @return 'true' if the token transfer can be validated, 'false' if not.\n   */\n  function _canValidateAllowlistAndBlocklistToken(\n    address token,\n    bytes memory payload,\n    address from,\n    address to\n  ) // Comments to avoid compilation warnings for unused variables.\n    internal\n    view\n    returns(bool)\n  {\n    if(\n      !_functionSupportsCertificateValidation(payload) ||\n      _certificateActivated[token] == CertificateValidation.None\n    ) {\n      if(_allowlistActivated[token]) {\n        if(from != address(0) && !isAllowlisted(token, from)) {\n          return false;\n        }\n        if(to != address(0) && !isAllowlisted(token, to)) {\n          return false;\n        }\n      }\n      if(_blocklistActivated[token]) {\n        if(from != address(0) && isBlocklisted(token, from)) {\n          return false;\n        }\n        if(to != address(0) && isBlocklisted(token, to)) {\n          return false;\n        }\n      }\n    }\n    \n    return true;\n  }\n\n  /**\n   * @dev Verify if a token transfer can be executed or not, on the validator's perspective.\n   * @return 'true' if the token transfer can be validated, 'false' if not.\n   */\n  function _canValidateGranularToken(\n    address token,\n    bytes32 partition,\n    uint value\n  )\n    internal\n    view\n    returns(bool)\n  {\n    if(_granularityByPartitionActivated[token]) {\n      if(\n        _granularityByPartition[token][partition] > 0 &&\n        !_isMultiple(_granularityByPartition[token][partition], value)\n      ) {\n        return false;\n      } \n    }\n\n    return true;\n  }\n\n  /**\n   * @dev Verify if a token transfer can be executed or not, on the validator's perspective.\n   * @return 'true' if the token transfer can be validated, 'false' if not.\n   */\n  function _canValidateHoldableToken(\n    address token,\n    bytes32 partition,\n    address operator,\n    address from,\n    address to,\n    uint value\n  )\n    internal\n    view\n    returns(bool)\n  {\n    if (_holdsActivated[token] && from != address(0)) {\n      if(operator != from) {\n        (, bytes32 holdId) = _retrieveHoldHashId(token, partition, operator, from, to, value);\n        Hold storage hold = _holds[token][holdId];\n        \n        if (_holdCanBeExecutedAsNotary(hold, operator, value) && value <= IERC1400(token).balanceOfByPartition(partition, from)) {\n          return true;\n        }\n      }\n      \n      if(value > _spendableBalanceOfByPartition(token, partition, from)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * @dev Get granularity for a given partition.\n   * @param token Token address.\n   * @param partition Name of the partition.\n   * @return Granularity of the partition.\n   */\n  function granularityByPartition(address token, bytes32 partition) external view returns (uint256) {\n    return _granularityByPartition[token][partition];\n  }\n  \n  /**\n   * @dev Set partition granularity\n   */\n  function setGranularityByPartition(\n    address token,\n    bytes32 partition,\n    uint256 granularity\n  )\n    external\n    onlyTokenController(token)\n  {\n    _granularityByPartition[token][partition] = granularity;\n  }\n\n  /**\n   * @dev Create a new token pre-hold.\n   */\n  function preHoldFor(\n    address token,\n    bytes32 holdId,\n    address recipient,\n    address notary,\n    bytes32 partition,\n    uint256 value,\n    uint256 timeToExpiration,\n    bytes32 secretHash,\n    bytes calldata certificate\n  )\n    external\n    returns (bool)\n  {\n    return _createHold(\n      token,\n      holdId,\n      address(0),\n      recipient,\n      notary,\n      partition,\n      value,\n      _computeExpiration(timeToExpiration),\n      secretHash,\n      certificate\n    );\n  }\n\n  /**\n   * @dev Create a new token pre-hold with expiration date.\n   */\n  function preHoldForWithExpirationDate(\n    address token,\n    bytes32 holdId,\n    address recipient,\n    address notary,\n    bytes32 partition,\n    uint256 value,\n    uint256 expiration,\n    bytes32 secretHash,\n    bytes calldata certificate\n  )\n    external\n    returns (bool)\n  {\n    _checkExpiration(expiration);\n\n    return _createHold(\n      token,\n      holdId,\n      address(0),\n      recipient,\n      notary,\n      partition,\n      value,\n      expiration,\n      secretHash,\n      certificate\n    );\n  }\n\n  /**\n   * @dev Create a new token hold.\n   */\n  function hold(\n    address token,\n    bytes32 holdId,\n    address recipient,\n    address notary,\n    bytes32 partition,\n    uint256 value,\n    uint256 timeToExpiration,\n    bytes32 secretHash,\n    bytes calldata certificate\n  ) \n    external\n    returns (bool)\n  {\n    return _createHold(\n      token,\n      holdId,\n      msg.sender,\n      recipient,\n      notary,\n      partition,\n      value,\n      _computeExpiration(timeToExpiration),\n      secretHash,\n      certificate\n    );\n  }\n\n  /**\n   * @dev Create a new token hold with expiration date.\n   */\n  function holdWithExpirationDate(\n    address token,\n    bytes32 holdId,\n    address recipient,\n    address notary,\n    bytes32 partition,\n    uint256 value,\n    uint256 expiration,\n    bytes32 secretHash,\n    bytes calldata certificate\n  )\n    external\n    returns (bool)\n  {\n    _checkExpiration(expiration);\n\n    return _createHold(\n      token,\n      holdId,\n      msg.sender,\n      recipient,\n      notary,\n      partition,\n      value,\n      expiration,\n      secretHash,\n      certificate\n    );\n  }\n\n  /**\n   * @dev Create a new token hold on behalf of the token holder.\n   */\n  function holdFrom(\n    address token,\n    bytes32 holdId,\n    address sender,\n    address recipient,\n    address notary,\n    bytes32 partition,\n    uint256 value,\n    uint256 timeToExpiration,\n    bytes32 secretHash,\n    bytes calldata certificate\n  )\n    external\n    returns (bool)\n  {\n    require(sender != address(0), \"Payer address must not be zero address\");\n    return _createHold(\n      token,\n      holdId,\n      sender,\n      recipient,\n      notary,\n      partition,\n      value,\n      _computeExpiration(timeToExpiration),\n      secretHash,\n      certificate\n    );\n  }\n\n  /**\n   * @dev Create a new token hold with expiration date on behalf of the token holder.\n   */\n  function holdFromWithExpirationDate(\n    address token,\n    bytes32 holdId,\n    address sender,\n    address recipient,\n    address notary,\n    bytes32 partition,\n    uint256 value,\n    uint256 expiration,\n    bytes32 secretHash,\n    bytes calldata certificate\n  )\n    external\n    returns (bool)\n  {\n    _checkExpiration(expiration);\n    require(sender != address(0), \"Payer address must not be zero address\");\n\n    return _createHold(\n      token,\n      holdId,\n      sender,\n      recipient,\n      notary,\n      partition,\n      value,\n      expiration,\n      secretHash,\n      certificate\n    );\n  }\n\n  /**\n   * @dev Create a new token hold.\n   */\n  function _createHold(\n    address token,\n    bytes32 holdId,\n    address sender,\n    address recipient,\n    address notary,\n    bytes32 partition,\n    uint256 value,\n    uint256 expiration,\n    bytes32 secretHash,\n    bytes memory certificate\n  ) internal returns (bool)\n  {\n    Hold storage newHold = _holds[token][holdId];\n\n    require(recipient != address(0), \"Payee address must not be zero address\");\n    require(value != 0, \"Value must be greater than zero\");\n    require(newHold.value == 0, \"This holdId already exists\");\n    require(\n      _canHoldOrCanPreHold(token, msg.sender, sender, certificate),\n      \"A hold can only be created with adapted authorizations\"\n    );\n    \n    if (sender != address(0)) { // hold (tokens already exist)\n      require(value <= _spendableBalanceOfByPartition(token, partition, sender), \"Amount of the hold can't be greater than the spendable balance of the sender\");\n    }\n    \n    newHold.partition = partition;\n    newHold.sender = sender;\n    newHold.recipient = recipient;\n    newHold.notary = notary;\n    newHold.value = value;\n    newHold.expiration = expiration;\n    newHold.secretHash = secretHash;\n    newHold.status = HoldStatusCode.Ordered;\n\n    if(sender != address(0)) {\n      // In case tokens already exist, increase held balance\n      _increaseHeldBalance(token, newHold, holdId);\n\n      (bytes32 holdHash,) = _retrieveHoldHashId(\n        token, newHold.partition,\n        newHold.notary,\n        newHold.sender,\n        newHold.recipient,\n        newHold.value\n      );\n\n      _holdIds[holdHash] = holdId;\n    }\n\n    emit HoldCreated(\n      token,\n      holdId,\n      partition,\n      sender,\n      recipient,\n      notary,\n      value,\n      expiration,\n      secretHash\n    );\n\n    return true;\n  }\n\n  /**\n   * @dev Release token hold.\n   */\n  function releaseHold(address token, bytes32 holdId) external returns (bool) {\n    return _releaseHold(token, holdId);\n  }\n\n  /**\n   * @dev Release token hold.\n   */\n  function _releaseHold(address token, bytes32 holdId) internal returns (bool) {\n    Hold storage releasableHold = _holds[token][holdId];\n\n    require(\n        releasableHold.status == HoldStatusCode.Ordered || releasableHold.status == HoldStatusCode.ExecutedAndKeptOpen,\n        \"A hold can only be released in status Ordered or ExecutedAndKeptOpen\"\n    );\n    require(\n        _isExpired(releasableHold.expiration) ||\n        (msg.sender == releasableHold.notary) ||\n        (msg.sender == releasableHold.recipient),\n        \"A not expired hold can only be released by the notary or the payee\"\n    );\n\n    if (_isExpired(releasableHold.expiration)) {\n        releasableHold.status = HoldStatusCode.ReleasedOnExpiration;\n    } else {\n        if (releasableHold.notary == msg.sender) {\n            releasableHold.status = HoldStatusCode.ReleasedByNotary;\n        } else {\n            releasableHold.status = HoldStatusCode.ReleasedByPayee;\n        }\n    }\n\n    if(releasableHold.sender != address(0)) { // In case tokens already exist, decrease held balance\n      _decreaseHeldBalance(token, releasableHold, releasableHold.value);\n\n      (bytes32 holdHash,) = _retrieveHoldHashId(\n        token, releasableHold.partition,\n        releasableHold.notary,\n        releasableHold.sender,\n        releasableHold.recipient,\n        releasableHold.value\n      );\n\n      delete _holdIds[holdHash];\n    }\n\n    emit HoldReleased(token, holdId, releasableHold.notary, releasableHold.status);\n\n    return true;\n  }\n\n  /**\n   * @dev Renew hold.\n   */\n  function renewHold(address token, bytes32 holdId, uint256 timeToExpiration, bytes calldata certificate) external returns (bool) {\n    return _renewHold(token, holdId, _computeExpiration(timeToExpiration), certificate);\n  }\n\n  /**\n   * @dev Renew hold with expiration time.\n   */\n  function renewHoldWithExpirationDate(address token, bytes32 holdId, uint256 expiration, bytes calldata certificate) external returns (bool) {\n    _checkExpiration(expiration);\n\n    return _renewHold(token, holdId, expiration, certificate);\n  }\n\n  /**\n   * @dev Renew hold.\n   */\n  function _renewHold(address token, bytes32 holdId, uint256 expiration, bytes memory certificate) internal returns (bool) {\n    Hold storage renewableHold = _holds[token][holdId];\n\n    require(\n      renewableHold.status == HoldStatusCode.Ordered\n      || renewableHold.status == HoldStatusCode.ExecutedAndKeptOpen,\n      \"A hold can only be renewed in status Ordered or ExecutedAndKeptOpen\"\n    );\n    require(!_isExpired(renewableHold.expiration), \"An expired hold can not be renewed\");\n\n    require(\n      _canHoldOrCanPreHold(token, msg.sender, renewableHold.sender, certificate),\n      \"A hold can only be renewed with adapted authorizations\"\n    );\n    \n    uint256 oldExpiration = renewableHold.expiration;\n    renewableHold.expiration = expiration;\n\n    emit HoldRenewed(\n      token,\n      holdId,\n      renewableHold.notary,\n      oldExpiration,\n      expiration\n    );\n\n    return true;\n  }\n\n  /**\n   * @dev Execute hold.\n   */\n  function executeHold(address token, bytes32 holdId, uint256 value, bytes32 secret) external override returns (bool) {\n    return _executeHold(\n      token,\n      holdId,\n      msg.sender,\n      value,\n      secret,\n      false\n    );\n  }\n\n  /**\n   * @dev Execute hold and keep open.\n   */\n  function executeHoldAndKeepOpen(address token, bytes32 holdId, uint256 value, bytes32 secret) external returns (bool) {\n    return _executeHold(\n      token,\n      holdId,\n      msg.sender,\n      value,\n      secret,\n      true\n    );\n  }\n  \n  /**\n   * @dev Execute hold.\n   */\n  function _executeHold(\n    address token,\n    bytes32 holdId,\n    address operator,\n    uint256 value,\n    bytes32 secret,\n    bool keepOpenIfHoldHasBalance\n  ) internal returns (bool)\n  {\n    Hold storage executableHold = _holds[token][holdId];\n\n    bool canExecuteHold;\n    if(secret != \"\" && _holdCanBeExecutedAsSecretHolder(executableHold, value, secret)) {\n      executableHold.secret = secret;\n      canExecuteHold = true;\n    } else if(_holdCanBeExecutedAsNotary(executableHold, operator, value)) {\n      canExecuteHold = true;\n    }\n\n    if(canExecuteHold) {\n      if (keepOpenIfHoldHasBalance && ((executableHold.value - value) > 0)) {\n        _setHoldToExecutedAndKeptOpen(\n          token,\n          executableHold,\n          holdId,\n          value,\n          value,\n          secret\n        );\n      } else {\n        _setHoldToExecuted(\n          token,\n          executableHold,\n          holdId,\n          value,\n          executableHold.value,\n          secret\n        );\n      }\n\n      if (executableHold.sender == address(0)) { // pre-hold (tokens do not already exist)\n        IERC1400(token).issueByPartition(executableHold.partition, executableHold.recipient, value, \"\");\n      } else { // post-hold (tokens already exist)\n        IERC1400(token).operatorTransferByPartition(executableHold.partition, executableHold.sender, executableHold.recipient, value, \"\", \"\");\n      }\n      \n    } else {\n      revert(\"hold can not be executed\");\n    }\n\n  }\n\n  /**\n   * @dev Set hold to executed.\n   */\n  function _setHoldToExecuted(\n    address token,\n    Hold storage executableHold,\n    bytes32 holdId,\n    uint256 value,\n    uint256 heldBalanceDecrease,\n    bytes32 secret\n  ) internal\n  {\n    if(executableHold.sender != address(0)) { // In case tokens already exist, decrease held balance\n      _decreaseHeldBalance(token, executableHold, heldBalanceDecrease);\n    }\n\n    executableHold.status = HoldStatusCode.Executed;\n\n    emit HoldExecuted(\n      token,\n      holdId,\n      executableHold.notary,\n      executableHold.value,\n      value,\n      secret\n    );\n  }\n\n  /**\n   * @dev Set hold to executed and kept open.\n   */\n  function _setHoldToExecutedAndKeptOpen(\n    address token,\n    Hold storage executableHold,\n    bytes32 holdId,\n    uint256 value,\n    uint256 heldBalanceDecrease,\n    bytes32 secret\n  ) internal\n  {\n    if(executableHold.sender != address(0)) { // In case tokens already exist, decrease held balance\n      _decreaseHeldBalance(token, executableHold, heldBalanceDecrease);\n    } \n\n    executableHold.status = HoldStatusCode.ExecutedAndKeptOpen;\n    executableHold.value = executableHold.value.sub(value);\n\n    emit HoldExecutedAndKeptOpen(\n      token,\n      holdId,\n      executableHold.notary,\n      executableHold.value,\n      value,\n      secret\n    );\n  }\n\n  /**\n   * @dev Increase held balance.\n   */\n  function _increaseHeldBalance(address token, Hold storage executableHold, bytes32 holdId) private {\n    _heldBalance[token][executableHold.sender] = _heldBalance[token][executableHold.sender].add(executableHold.value);\n    _totalHeldBalance[token] = _totalHeldBalance[token].add(executableHold.value);\n\n    _heldBalanceByPartition[token][executableHold.sender][executableHold.partition] = _heldBalanceByPartition[token][executableHold.sender][executableHold.partition].add(executableHold.value);\n    _totalHeldBalanceByPartition[token][executableHold.partition] = _totalHeldBalanceByPartition[token][executableHold.partition].add(executableHold.value);\n  }\n\n  /**\n   * @dev Decrease held balance.\n   */\n  function _decreaseHeldBalance(address token, Hold storage executableHold, uint256 value) private {\n    _heldBalance[token][executableHold.sender] = _heldBalance[token][executableHold.sender].sub(value);\n    _totalHeldBalance[token] = _totalHeldBalance[token].sub(value);\n\n    _heldBalanceByPartition[token][executableHold.sender][executableHold.partition] = _heldBalanceByPartition[token][executableHold.sender][executableHold.partition].sub(value);\n    _totalHeldBalanceByPartition[token][executableHold.partition] = _totalHeldBalanceByPartition[token][executableHold.partition].sub(value);\n  }\n\n  /**\n   * @dev Check secret.\n   */\n  function _checkSecret(Hold storage executableHold, bytes32 secret) internal view returns (bool) {\n    if(executableHold.secretHash == sha256(abi.encodePacked(secret))) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Compute expiration time.\n   */\n  function _computeExpiration(uint256 timeToExpiration) internal view returns (uint256) {\n    uint256 expiration = 0;\n\n    if (timeToExpiration != 0) {\n        expiration = block.timestamp.add(timeToExpiration);\n    }\n\n    return expiration;\n  }\n\n  /**\n   * @dev Check expiration time.\n   */\n  function _checkExpiration(uint256 expiration) private view {\n    require(expiration > block.timestamp || expiration == 0, \"Expiration date must be greater than block timestamp or zero\");\n  }\n\n  /**\n   * @dev Check is expiration date is past.\n   */\n  function _isExpired(uint256 expiration) internal view returns (bool) {\n    return expiration != 0 && (block.timestamp >= expiration);\n  }\n\n  /**\n   * @dev Retrieve hold hash, and ID for given parameters\n   */\n  function _retrieveHoldHashId(address token, bytes32 partition, address notary, address sender, address recipient, uint value) internal view returns (bytes32, bytes32) {\n    // Pack and hash hold parameters\n    bytes32 holdHash = keccak256(abi.encodePacked(\n      token,\n      partition,\n      sender,\n      recipient,\n      notary,\n      value\n    ));\n    bytes32 holdId = _holdIds[holdHash];\n\n    return (holdHash, holdId);\n  }  \n\n  /**\n   * @dev Check if hold can be executed\n   */\n  function _holdCanBeExecuted(Hold storage executableHold, uint value) internal view returns (bool) {\n    if(!(executableHold.status == HoldStatusCode.Ordered || executableHold.status == HoldStatusCode.ExecutedAndKeptOpen)) {\n      return false; // A hold can only be executed in status Ordered or ExecutedAndKeptOpen\n    } else if(value == 0) {\n      return false; // Value must be greater than zero\n    } else if(_isExpired(executableHold.expiration)) {\n      return false; // The hold has already expired\n    } else if(value > executableHold.value) {\n      return false; // The value should be equal or less than the held amount\n    } else {\n      return true;\n    }\n  }\n\n  /**\n   * @dev Check if hold can be executed as secret holder\n   */\n  function _holdCanBeExecutedAsSecretHolder(Hold storage executableHold, uint value, bytes32 secret) internal view returns (bool) {\n    if(\n      _checkSecret(executableHold, secret)\n      && _holdCanBeExecuted(executableHold, value)) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Check if hold can be executed as notary\n   */\n  function _holdCanBeExecutedAsNotary(Hold storage executableHold, address operator, uint value) internal view returns (bool) {\n    if(\n      executableHold.notary == operator\n      && _holdCanBeExecuted(executableHold, value)) {\n      return true;\n    } else {\n      return false;\n    }\n  }  \n\n  /**\n   * @dev Retrieve hold data.\n   */\n  function retrieveHoldData(address token, bytes32 holdId) external override view returns (\n    bytes32 partition,\n    address sender,\n    address recipient,\n    address notary,\n    uint256 value,\n    uint256 expiration,\n    bytes32 secretHash,\n    bytes32 secret,\n    HoldStatusCode status)\n  {\n    Hold storage retrievedHold = _holds[token][holdId];\n    return (\n      retrievedHold.partition,\n      retrievedHold.sender,\n      retrievedHold.recipient,\n      retrievedHold.notary,\n      retrievedHold.value,\n      retrievedHold.expiration,\n      retrievedHold.secretHash,\n      retrievedHold.secret,\n      retrievedHold.status\n    );\n  }\n\n  /**\n   * @dev Total supply on hold.\n   */\n  function totalSupplyOnHold(address token) external view returns (uint256) {\n    return _totalHeldBalance[token];\n  }\n\n  /**\n   * @dev Total supply on hold for a specific partition.\n   */\n  function totalSupplyOnHoldByPartition(address token, bytes32 partition) external view returns (uint256) {\n    return _totalHeldBalanceByPartition[token][partition];\n  }\n\n  /**\n   * @dev Get balance on hold of a tokenholder.\n   */\n  function balanceOnHold(address token, address account) external view returns (uint256) {\n    return _heldBalance[token][account];\n  }\n\n  /**\n   * @dev Get balance on hold of a tokenholder for a specific partition.\n   */\n  function balanceOnHoldByPartition(address token, bytes32 partition, address account) external view returns (uint256) {\n    return _heldBalanceByPartition[token][account][partition];\n  }\n\n  /**\n   * @dev Get spendable balance of a tokenholder.\n   */\n  function spendableBalanceOf(address token, address account) external view returns (uint256) {\n    return _spendableBalanceOf(token, account);\n  }\n\n  /**\n   * @dev Get spendable balance of a tokenholder for a specific partition.\n   */\n  function spendableBalanceOfByPartition(address token, bytes32 partition, address account) external view returns (uint256) {\n    return _spendableBalanceOfByPartition(token, partition, account);\n  }\n\n  /**\n   * @dev Get spendable balance of a tokenholder.\n   */\n  function _spendableBalanceOf(address token, address account) internal view returns (uint256) {\n    return IERC20(token).balanceOf(account) - _heldBalance[token][account];\n  }\n\n  /**\n   * @dev Get spendable balance of a tokenholder for a specific partition.\n   */\n  function _spendableBalanceOfByPartition(address token, bytes32 partition, address account) internal view returns (uint256) {\n    return IERC1400(token).balanceOfByPartition(partition, account) - _heldBalanceByPartition[token][account][partition];\n  }\n\n  /**\n   * @dev Check if hold (or pre-hold) can be created.\n   * @return 'true' if the operator can create pre-holds, 'false' if not.\n   */\n  function _canHoldOrCanPreHold(address token, address operator, address sender, bytes memory certificate) internal returns(bool) { \n    (bool canValidateCertificate, CertificateValidation certificateControl, bytes32 salt) = _canValidateCertificateToken(token, msg.data, operator, certificate);\n    _useCertificateIfActivated(token, certificateControl, operator, salt);\n\n    if (sender != address(0)) { // hold\n      return canValidateCertificate && (_isTokenController[token][operator] || operator == sender);\n    } else { // pre-hold\n      return canValidateCertificate && IMinterRole(token).isMinter(operator); \n    }\n  }\n\n  /**\n   * @dev Check if validator is activated for the function called in the smart contract.\n   * @param payload Payload of the initial transaction.\n   * @return 'true' if the function requires validation, 'false' if not.\n   */\n  function _functionSupportsCertificateValidation(bytes memory payload) internal pure returns(bool) {\n    bytes4 functionSig = _getFunctionSig(payload);\n    if(functionSig == ERC20_TRANSFER_ID || functionSig == ERC20_TRANSFERFROM_ID) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  /**\n   * @dev Use certificate, if validated.\n   * @param token Token address.\n   * @param certificateControl Type of certificate.\n   * @param msgSender Transaction sender (only for nonce-based certificates).\n   * @param salt Salt extracted from the certificate (only for salt-based certificates).\n   */\n  function _useCertificateIfActivated(address token, CertificateValidation certificateControl, address msgSender, bytes32 salt) internal {\n    // Declare certificate as used\n    if (certificateControl == CertificateValidation.NonceBased) {\n      _usedCertificateNonce[token][msgSender] += 1;\n    } else if (certificateControl == CertificateValidation.SaltBased) {\n      _usedCertificateSalt[token][salt] = true;\n    }\n  }\n\n  /**\n   * @dev Extract function signature from payload.\n   * @param payload Payload of the initial transaction.\n   * @return Function signature.\n   */\n  function _getFunctionSig(bytes memory payload) internal pure returns(bytes4) {\n    return (bytes4(payload[0]) | bytes4(payload[1]) >> 8 | bytes4(payload[2]) >> 16 | bytes4(payload[3]) >> 24);\n  }\n\n  /**\n   * @dev Check if 'value' is multiple of 'granularity'.\n   * @param granularity The granularity that want's to be checked.\n   * @param value The quantity that want's to be checked.\n   * @return 'true' if 'value' is a multiple of 'granularity'.\n   */\n  function _isMultiple(uint256 granularity, uint256 value) internal pure returns(bool) {\n    return(value.div(granularity).mul(granularity) == value);\n  }\n\n  /**\n   * @dev Get state of certificate (used or not).\n   * @param token Token address.\n   * @param sender Address whom to check the counter of.\n   * @return uint256 Number of transaction already sent for this token contract.\n   */\n  function usedCertificateNonce(address token, address sender) external view returns (uint256) {\n    return _usedCertificateNonce[token][sender];\n  }\n\n  /**\n   * @dev Checks if a nonce-based certificate is correct\n   * @param certificate Certificate to control\n   */\n  function _checkNonceBasedCertificate(\n    address token,\n    address msgSender,\n    bytes memory payloadWithCertificate,\n    bytes memory certificate\n  )\n    internal\n    view\n    returns(bool)\n  {\n    // Certificate should be 97 bytes long\n    if (certificate.length != 97) {\n      return false;\n    }\n\n    uint256 e;\n    uint8 v;\n\n    // Extract certificate information and expiration time from payload\n    assembly {\n      // Retrieve expirationTime & ECDSA element (v) from certificate which is a 97 long bytes\n      // Certificate encoding format is: <expirationTime (32 bytes)>@<r (32 bytes)>@<s (32 bytes)>@<v (1 byte)>\n      e := mload(add(certificate, 0x20))\n      v := byte(0, mload(add(certificate, 0x80)))\n    }\n\n    // Certificate should not be expired\n    if (e < block.timestamp) {\n      return false;\n    }\n\n    if (v < 27) {\n      v += 27;\n    }\n\n    // Perform ecrecover to ensure message information corresponds to certificate\n    if (v == 27 || v == 28) {\n      // Extract certificate from payload\n      bytes memory payloadWithoutCertificate = new bytes(payloadWithCertificate.length.sub(160));\n      for (uint i = 0; i < payloadWithCertificate.length.sub(160); i++) { // replace 4 bytes corresponding to function selector\n        payloadWithoutCertificate[i] = payloadWithCertificate[i];\n      }\n\n      // Pack and hash\n      bytes memory pack = abi.encodePacked(\n        msgSender,\n        token,\n        payloadWithoutCertificate,\n        e,\n        _usedCertificateNonce[token][msgSender]\n      );\n      bytes32 hash = keccak256(\n        abi.encodePacked(\n          DomainAware(token).generateDomainSeparator(),\n          keccak256(pack)\n        )\n      );\n\n      bytes32 r;\n      bytes32 s;\n      // Extract certificate information and expiration time from payload\n      assembly {\n        // Retrieve ECDSA elements (r, s) from certificate which is a 97 long bytes\n        // Certificate encoding format is: <expirationTime (32 bytes)>@<r (32 bytes)>@<s (32 bytes)>@<v (1 byte)>\n        r := mload(add(certificate, 0x40))\n        s := mload(add(certificate, 0x60))\n      }\n\n      // Check if certificate match expected transactions parameters\n      if (isCertificateSigner(token, ecrecover(hash, v, r, s))) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @dev Get state of certificate (used or not).\n   * @param token Token address.\n   * @param salt First 32 bytes of certificate whose validity is being checked.\n   * @return bool 'true' if certificate is already used, 'false' if not.\n   */\n  function usedCertificateSalt(address token, bytes32 salt) external view returns (bool) {\n    return _usedCertificateSalt[token][salt];\n  }\n\n  /**\n   * @dev Checks if a salt-based certificate is correct\n   * @param certificate Certificate to control\n   */\n  function _checkSaltBasedCertificate(\n    address token,\n    address msgSender,\n    bytes memory payloadWithCertificate,\n    bytes memory certificate\n  )\n    internal\n    view\n    returns(bool, bytes32)\n  {\n    // Certificate should be 129 bytes long\n    if (certificate.length != 129) {\n      return (false, \"\");\n    }\n\n    bytes32 salt;\n    uint256 e;\n    uint8 v;\n\n    // Extract certificate information and expiration time from payload\n    assembly {\n      // Retrieve expirationTime & ECDSA elements from certificate which is a 97 long bytes\n      // Certificate encoding format is: <salt (32 bytes)>@<expirationTime (32 bytes)>@<r (32 bytes)>@<s (32 bytes)>@<v (1 byte)>\n      salt := mload(add(certificate, 0x20))\n      e := mload(add(certificate, 0x40))\n      v := byte(0, mload(add(certificate, 0xa0)))\n    }\n\n    // Certificate should not be expired\n    if (e < block.timestamp) {\n      return (false, \"\");\n    }\n\n    if (v < 27) {\n      v += 27;\n    }\n\n    // Perform ecrecover to ensure message information corresponds to certificate\n    if (v == 27 || v == 28) {\n      // Extract certificate from payload\n      bytes memory payloadWithoutCertificate = new bytes(payloadWithCertificate.length.sub(192));\n      for (uint i = 0; i < payloadWithCertificate.length.sub(192); i++) { // replace 4 bytes corresponding to function selector\n        payloadWithoutCertificate[i] = payloadWithCertificate[i];\n      }\n\n      // Pack and hash\n      bytes memory pack = abi.encodePacked(\n        msgSender,\n        token,\n        payloadWithoutCertificate,\n        e,\n        salt\n      );\n\n      bytes32 hash = keccak256(\n        abi.encodePacked(\n          DomainAware(token).generateDomainSeparator(),\n          keccak256(pack)\n        )\n      );\n\n      bytes32 r;\n      bytes32 s;\n      // Extract certificate information and expiration time from payload\n      assembly {\n        // Retrieve ECDSA elements (r, s) from certificate which is a 97 long bytes\n        // Certificate encoding format is: <expirationTime (32 bytes)>@<r (32 bytes)>@<s (32 bytes)>@<v (1 byte)>\n        r := mload(add(certificate, 0x60))\n        s := mload(add(certificate, 0x80))\n      }\n\n      // Check if certificate match expected transactions parameters\n      if (isCertificateSigner(token, ecrecover(hash, v, r, s)) && !_usedCertificateSalt[token][salt]) {\n        return (true, salt);\n      }\n    }\n    return (false, \"\");\n  }\n}"
    },
    "contracts/tools/Pausable.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity ^0.8.0;\n\nimport \"../roles/PauserRole.sol\";\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is PauserRole {\n    event Paused(address indexed token, address account);\n    event Unpaused(address indexed token, address account);\n\n    // Mapping from token to token paused status.\n    mapping(address => bool) private _paused;\n\n    /**\n     * @return true if the contract is paused, false otherwise.\n     */\n    function paused(address token) public view returns (bool) {\n        return _paused[token];\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused(address token) {\n        require(!_paused[token]);\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused(address token) {\n        require(_paused[token]);\n        _;\n    }\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function pause(address token) public onlyPauser(token) whenNotPaused(token) {\n        _paused[token] = true;\n        emit Paused(token, msg.sender);\n    }\n\n    /**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n    function unpause(address token) public onlyPauser(token) whenPaused(token) {\n        _paused[token] = false;\n        emit Unpaused(token, msg.sender);\n    }\n}\n"
    },
    "contracts/roles/CertificateSignerRole.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\n/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.8.0;\n\nimport \"./Roles.sol\";\n\n\n/**\n * @title CertificateSignerRole\n * @dev Certificate signers are responsible for signing certificates.\n */\nabstract contract CertificateSignerRole {\n    using Roles for Roles.Role;\n\n    event CertificateSignerAdded(address indexed token, address indexed account);\n    event CertificateSignerRemoved(address indexed token, address indexed account);\n\n    // Mapping from token to token certificate signers.\n    mapping(address => Roles.Role) private _certificateSigners;\n\n    modifier onlyCertificateSigner(address token) virtual {\n        require(isCertificateSigner(token, msg.sender));\n        _;\n    }\n\n    function isCertificateSigner(address token, address account) public view returns (bool) {\n        return _certificateSigners[token].has(account);\n    }\n\n    function addCertificateSigner(address token, address account) public onlyCertificateSigner(token) {\n        _addCertificateSigner(token, account);\n    }\n\n    function removeCertificateSigner(address token, address account) public onlyCertificateSigner(token) {\n        _removeCertificateSigner(token, account);\n    }\n\n    function renounceCertificateSigner(address token) public {\n        _removeCertificateSigner(token, msg.sender);\n    }\n\n    function _addCertificateSigner(address token, address account) internal {\n        _certificateSigners[token].add(account);\n        emit CertificateSignerAdded(token, account);\n    }\n\n    function _removeCertificateSigner(address token, address account) internal {\n        _certificateSigners[token].remove(account);\n        emit CertificateSignerRemoved(token, account);\n    }\n}"
    },
    "contracts/roles/AllowlistedRole.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\n/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.8.0;\n\nimport \"./Roles.sol\";\nimport \"./AllowlistAdminRole.sol\";\n\n\n/**\n * @title AllowlistedRole\n * @dev Allowlisted accounts have been forbidden by a AllowlistAdmin to perform certain actions (e.g. participate in a\n * crowdsale). This role is special in that the only accounts that can add it are AllowlistAdmins (who can also remove\n * it), and not Allowlisteds themselves.\n */\nabstract contract AllowlistedRole is AllowlistAdminRole {\n    using Roles for Roles.Role;\n\n    event AllowlistedAdded(address indexed token, address indexed account);\n    event AllowlistedRemoved(address indexed token, address indexed account);\n\n    // Mapping from token to token allowlisteds.\n    mapping(address => Roles.Role) private _allowlisteds;\n\n    modifier onlyNotAllowlisted(address token) {\n        require(!isAllowlisted(token, msg.sender));\n        _;\n    }\n\n    function isAllowlisted(address token, address account) public view returns (bool) {\n        return _allowlisteds[token].has(account);\n    }\n\n    function addAllowlisted(address token, address account) public onlyAllowlistAdmin(token) {\n        _addAllowlisted(token, account);\n    }\n\n    function removeAllowlisted(address token, address account) public onlyAllowlistAdmin(token) {\n        _removeAllowlisted(token, account);\n    }\n\n    function _addAllowlisted(address token, address account) internal {\n        _allowlisteds[token].add(account);\n        emit AllowlistedAdded(token, account);\n    }\n\n    function _removeAllowlisted(address token, address account) internal {\n        _allowlisteds[token].remove(account);\n        emit AllowlistedRemoved(token, account);\n    }\n}\n"
    },
    "contracts/roles/BlocklistedRole.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\n/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.8.0;\n\nimport \"./Roles.sol\";\nimport \"./BlocklistAdminRole.sol\";\n\n\n/**\n * @title BlocklistedRole\n * @dev Blocklisted accounts have been forbidden by a BlocklistAdmin to perform certain actions (e.g. participate in a\n * crowdsale). This role is special in that the only accounts that can add it are BlocklistAdmins (who can also remove\n * it), and not Blocklisteds themselves.\n */\nabstract contract BlocklistedRole is BlocklistAdminRole {\n    using Roles for Roles.Role;\n\n    event BlocklistedAdded(address indexed token, address indexed account);\n    event BlocklistedRemoved(address indexed token, address indexed account);\n\n    // Mapping from token to token blocklisteds.\n    mapping(address => Roles.Role) private _blocklisteds;\n\n    modifier onlyNotBlocklisted(address token) {\n        require(!isBlocklisted(token, msg.sender));\n        _;\n    }\n\n    function isBlocklisted(address token, address account) public view returns (bool) {\n        return _blocklisteds[token].has(account);\n    }\n\n    function addBlocklisted(address token, address account) public onlyBlocklistAdmin(token) {\n        _addBlocklisted(token, account);\n    }\n\n    function removeBlocklisted(address token, address account) public onlyBlocklistAdmin(token) {\n        _removeBlocklisted(token, account);\n    }\n\n    function _addBlocklisted(address token, address account) internal {\n        _blocklisteds[token].add(account);\n        emit BlocklistedAdded(token, account);\n    }\n\n    function _removeBlocklisted(address token, address account) internal {\n        _blocklisteds[token].remove(account);\n        emit BlocklistedRemoved(token, account);\n    }\n}\n"
    },
    "contracts/roles/PauserRole.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\n/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.8.0;\n\nimport \"./Roles.sol\";\n\n\n/**\n * @title PauserRole\n * @dev Pausers are responsible for pausing/unpausing transfers.\n */\nabstract contract PauserRole {\n    using Roles for Roles.Role;\n\n    event PauserAdded(address indexed token, address indexed account);\n    event PauserRemoved(address indexed token, address indexed account);\n\n    // Mapping from token to token pausers.\n    mapping(address => Roles.Role) private _pausers;\n\n    modifier onlyPauser(address token) virtual {\n        require(isPauser(token, msg.sender));\n        _;\n    }\n\n    function isPauser(address token, address account) public view returns (bool) {\n        return _pausers[token].has(account);\n    }\n\n    function addPauser(address token, address account) public onlyPauser(token) {\n        _addPauser(token, account);\n    }\n\n    function removePauser(address token, address account) public onlyPauser(token) {\n        _removePauser(token, account);\n    }\n\n    function renouncePauser(address token) public {\n        _removePauser(token, msg.sender);\n    }\n\n    function _addPauser(address token, address account) internal {\n        _pausers[token].add(account);\n        emit PauserAdded(token, account);\n    }\n\n    function _removePauser(address token, address account) internal {\n        _pausers[token].remove(account);\n        emit PauserRemoved(token, account);\n    }\n}"
    },
    "contracts/roles/AllowlistAdminRole.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\n/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.8.0;\n\nimport \"./Roles.sol\";\n\n\n/**\n * @title AllowlistAdminRole\n * @dev AllowlistAdmins are responsible for assigning and removing Allowlisted accounts.\n */\nabstract contract AllowlistAdminRole {\n    using Roles for Roles.Role;\n\n    event AllowlistAdminAdded(address indexed token, address indexed account);\n    event AllowlistAdminRemoved(address indexed token, address indexed account);\n\n    // Mapping from token to token allowlist admins.\n    mapping(address => Roles.Role) private _allowlistAdmins;\n\n    modifier onlyAllowlistAdmin(address token) virtual {\n        require(isAllowlistAdmin(token, msg.sender));\n        _;\n    }\n\n    function isAllowlistAdmin(address token, address account) public view returns (bool) {\n        return _allowlistAdmins[token].has(account);\n    }\n\n    function addAllowlistAdmin(address token, address account) public onlyAllowlistAdmin(token) {\n        _addAllowlistAdmin(token, account);\n    }\n\n    function removeAllowlistAdmin(address token, address account) public onlyAllowlistAdmin(token) {\n        _removeAllowlistAdmin(token, account);\n    }\n\n    function renounceAllowlistAdmin(address token) public {\n        _removeAllowlistAdmin(token, msg.sender);\n    }\n\n    function _addAllowlistAdmin(address token, address account) internal {\n        _allowlistAdmins[token].add(account);\n        emit AllowlistAdminAdded(token, account);\n    }\n\n    function _removeAllowlistAdmin(address token, address account) internal {\n        _allowlistAdmins[token].remove(account);\n        emit AllowlistAdminRemoved(token, account);\n    }\n}"
    },
    "contracts/roles/BlocklistAdminRole.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\n/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.8.0;\n\nimport \"./Roles.sol\";\n\n\n/**\n * @title BlocklistAdminRole\n * @dev BlocklistAdmins are responsible for assigning and removing Blocklisted accounts.\n */\nabstract contract BlocklistAdminRole {\n    using Roles for Roles.Role;\n\n    event BlocklistAdminAdded(address indexed token, address indexed account);\n    event BlocklistAdminRemoved(address indexed token, address indexed account);\n\n    // Mapping from token to token blocklist admins.\n    mapping(address => Roles.Role) private _blocklistAdmins;\n\n    modifier onlyBlocklistAdmin(address token) virtual {\n        require(isBlocklistAdmin(token, msg.sender));\n        _;\n    }\n\n    function isBlocklistAdmin(address token, address account) public view returns (bool) {\n        return _blocklistAdmins[token].has(account);\n    }\n\n    function addBlocklistAdmin(address token, address account) public onlyBlocklistAdmin(token) {\n        _addBlocklistAdmin(token, account);\n    }\n\n    function removeBlocklistAdmin(address token, address account) public onlyBlocklistAdmin(token) {\n        _removeBlocklistAdmin(token, account);\n    }\n\n    function renounceBlocklistAdmin(address token) public {\n        _removeBlocklistAdmin(token, msg.sender);\n    }\n\n    function _addBlocklistAdmin(address token, address account) internal {\n        _blocklistAdmins[token].add(account);\n        emit BlocklistAdminAdded(token, account);\n    }\n\n    function _removeBlocklistAdmin(address token, address account) internal {\n        _blocklistAdmins[token].remove(account);\n        emit BlocklistAdminRemoved(token, account);\n    }\n}"
    },
    "contracts/mocks/ERC1400TokensValidatorMock.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity ^0.8.0;\n\nimport \"../extensions/tokenExtensions/ERC1400TokensValidator.sol\";\n\n/**\n @notice Interface to the Minterrole contract\n*/\ninterface IMinterMock {\n  function renounceMinter() external;\n}\n\ncontract ERC1400TokensValidatorMock is ERC1400TokensValidator {\n\n  function renounceMinter(address token) external onlyTokenController(token) {\n    IMinterMock(token).renounceMinter();\n  }\n\n}"
    },
    "contracts/extensions/tokenExtensions/ERC1400TokensChecker.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\n/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../tools/ERC1820Client.sol\";\nimport \"../../interface/ERC1820Implementer.sol\";\n\nimport \"../../IERC1400.sol\";\n\nimport \"../userExtensions/IERC1400TokensSender.sol\";\nimport \"../userExtensions/IERC1400TokensRecipient.sol\";\n\nimport \"./IERC1400TokensValidator.sol\";\nimport \"./IERC1400TokensChecker.sol\";\n\ninterface IERC1400Extended {\n    // Not a real interface but added here since 'granularity' doesn't belong to IERC1400\n\n    function granularity() external view returns(uint256);\n}\n\ncontract ERC1400TokensChecker is IERC1400TokensChecker, ERC1820Client, ERC1820Implementer {\n  using SafeMath for uint256;\n\n  string constant internal ERC1400_TOKENS_VALIDATOR = \"ERC1400TokensValidator\";\n  string constant internal ERC1400_TOKENS_CHECKER = \"ERC1400TokensChecker\";\n\n  string constant internal ERC1400_TOKENS_SENDER = \"ERC1400TokensSender\";\n  string constant internal ERC1400_TOKENS_RECIPIENT = \"ERC1400TokensRecipient\";\n\n  constructor() public {\n    ERC1820Implementer._setInterface(ERC1400_TOKENS_CHECKER);\n  }\n\n  /**\n   * @dev Know the reason on success or failure based on the EIP-1066 application-specific status codes.\n   * @param payload Payload of the initial transaction.\n   * @param partition Name of the partition.\n   * @param operator The address performing the transfer.\n   * @param from Token holder.\n   * @param to Token recipient.\n   * @param value Number of tokens to transfer.\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\n   * @param operatorData Information attached to the transfer, by the operator (if any).\n   * @return ESC (Ethereum Status Code) following the EIP-1066 standard.\n   * @return Additional bytes32 parameter that can be used to define\n   * application specific reason codes with additional details (for example the\n   * transfer restriction rule responsible for making the transfer operation invalid).\n   * @return Destination partition.\n   */\n   function canTransferByPartition(bytes calldata payload, bytes32 partition, address operator, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData)\n     external\n     override\n     view\n     returns (bytes1, bytes32, bytes32)\n   {\n     return _canTransferByPartition(payload, partition, operator, from, to, value, data, operatorData);\n   }\n\n  /**\n   * @dev Know the reason on success or failure based on the EIP-1066 application-specific status codes.\n   * @param payload Payload of the initial transaction.\n   * @param partition Name of the partition.\n   * @param operator The address performing the transfer.\n   * @param from Token holder.\n   * @param to Token recipient.\n   * @param value Number of tokens to transfer.\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\n   * @param operatorData Information attached to the transfer, by the operator (if any).\n   * @return ESC (Ethereum Status Code) following the EIP-1066 standard.\n   * @return Additional bytes32 parameter that can be used to define\n   * application specific reason codes with additional details (for example the\n   * transfer restriction rule responsible for making the transfer operation invalid).\n   * @return Destination partition.\n   */\n   function _canTransferByPartition(bytes memory payload, bytes32 partition, address operator, address from, address to, uint256 value, bytes memory data, bytes memory operatorData)\n     internal\n     view\n     returns (bytes1, bytes32, bytes32)\n   {\n     if(!IERC1400(msg.sender).isOperatorForPartition(partition, operator, from))\n       return(hex\"58\", \"\", partition); // 0x58\tinvalid operator (transfer agent)\n\n     if((IERC20(msg.sender).balanceOf(from) < value) || (IERC1400(msg.sender).balanceOfByPartition(partition, from) < value))\n       return(hex\"52\", \"\", partition); // 0x52\tinsufficient balance\n\n     if(to == address(0))\n       return(hex\"57\", \"\", partition); // 0x57\tinvalid receiver\n\n     address hookImplementation;\n     \n     hookImplementation = ERC1820Client.interfaceAddr(from, ERC1400_TOKENS_SENDER);\n     if((hookImplementation != address(0))\n       && !IERC1400TokensSender(hookImplementation).canTransfer(payload, partition, operator, from, to, value, data, operatorData))\n       return(hex\"56\", \"\", partition); // 0x56\tinvalid sender\n\n     hookImplementation = ERC1820Client.interfaceAddr(to, ERC1400_TOKENS_RECIPIENT);\n     if((hookImplementation != address(0))\n       && !IERC1400TokensRecipient(hookImplementation).canReceive(payload, partition, operator, from, to, value, data, operatorData))\n       return(hex\"57\", \"\", partition); // 0x57\tinvalid receiver\n\n     hookImplementation = ERC1820Client.interfaceAddr(msg.sender, ERC1400_TOKENS_VALIDATOR);\n     IERC1400TokensValidator.ValidateData memory vdata = IERC1400TokensValidator.ValidateData(msg.sender, payload, partition, operator, from, to, value, data, operatorData);\n     if((hookImplementation != address(0)) \n       && !IERC1400TokensValidator(hookImplementation).canValidate(vdata))\n       return(hex\"54\", \"\", partition); // 0x54\ttransfers halted (contract paused)\n\n     uint256 granularity = IERC1400Extended(msg.sender).granularity();\n     if(!(value.div(granularity).mul(granularity) == value))\n       return(hex\"50\", \"\", partition); // 0x50\ttransfer failure\n\n     return(hex\"51\", \"\", partition);  // 0x51\ttransfer success\n   }\n\n  /**\n   * @dev Know the reason on success or failure based on the EIP-1066 application-specific status codes.\n   * @return ESC (Ethereum Status Code) following the EIP-1066 standard.\n   * @return Additional bytes32 parameter that can be used to define\n   * application specific reason codes with additional details (for example the\n   * transfer restriction rule responsible for making the transfer operation invalid).\n   */\n  // function canTransfer(bytes calldata /*payload*/, address /*operator*/, address /*from*/, address /*to*/, uint256 /*value*/, bytes calldata /*data*/, bytes calldata /*operatorData*/)\n  //   external\n  //   view\n  //   returns (byte, bytes32)\n  // {\n  //   if(!IERC1400(msg.sender).isOperator(operator, from))\n  //      return(hex\"58\", \"\"); // 0x58\tinvalid operator (transfer agent)\n\n  //   byte esc;\n\n  //   bytes32[] memory defaultPartitions = IERC1400(msg.sender).getDefaultPartitions();\n\n  //   if(defaultPartitions.length == 0) {\n  //     return(hex\"55\", \"\"); // 0x55\tfunds locked (lockup period)\n  //   }\n\n  //   uint256 _remainingValue = value;\n  //   uint256 _localBalance;\n\n  //   for (uint i = 0; i < defaultPartitions.length; i++) {\n  //     _localBalance = IERC1400(msg.sender).balanceOfByPartition(defaultPartitions[i], from);\n  //     if(_remainingValue <= _localBalance) {\n  //       (esc,,) = _canTransferByPartition(payload, defaultPartitions[i], operator, from, to, _remainingValue, data, operatorData);\n  //       _remainingValue = 0;\n  //       break;\n  //     } else if (_localBalance != 0) {\n  //       (esc,,) = _canTransferByPartition(payload, defaultPartitions[i], operator, from, to, _localBalance, data, operatorData);\n  //       _remainingValue = _remainingValue - _localBalance;\n  //     }\n  //     if(esc != hex\"51\") {\n  //       return(esc, \"\");\n  //     }\n  //   }\n\n  //   if(_remainingValue != 0) {\n  //     return(hex\"52\", \"\"); // 0x52\tinsufficient balance\n  //   }\n\n  //   return(hex\"51\", \"\"); // 0x51\ttransfer success\n\n  //   return(hex\"00\", \"\");\n  // }\n\n}"
    },
    "contracts/mocks/ERC1400TokensRecipientMock.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity ^0.8.0;\n\nimport \"../extensions/userExtensions/IERC1400TokensRecipient.sol\";\nimport \"../interface/ERC1820Implementer.sol\";\n\n\ncontract ERC1400TokensRecipientMock is IERC1400TokensRecipient, ERC1820Implementer {\n\n  string constant internal ERC1400_TOKENS_RECIPIENT = \"ERC1400TokensRecipient\";\n\n  constructor() {\n    ERC1820Implementer._setInterface(ERC1400_TOKENS_RECIPIENT);\n  }\n\n  function canReceive(\n    bytes calldata /*payload*/,\n    bytes32 /*partition*/,\n    address /*operator*/,\n    address from,\n    address to,\n    uint value,\n    bytes calldata data,\n    bytes calldata /*operatorData*/\n  ) // Comments to avoid compilation warnings for unused variables.\n    external\n    override\n    view\n    returns(bool)\n  {\n    return(_canReceive(from, to, value, data));\n  }\n\n  function tokensReceived(\n    bytes calldata /*payload*/,\n    bytes32 /*partition*/,\n    address /*operator*/,\n    address from,\n    address to,\n    uint value,\n    bytes calldata data,\n    bytes calldata /*operatorData*/\n  ) // Comments to avoid compilation warnings for unused variables.\n    external\n    override\n  {\n    require(_canReceive(from, to, value, data), \"57\"); // 0x57\tinvalid receiver\n  }\n\n  function _canReceive(\n    address /*from*/,\n    address /*to*/,\n    uint /*value*/,\n    bytes memory data\n  ) // Comments to avoid compilation warnings for unused variables.\n    internal\n    pure\n    returns(bool)\n  {\n    bytes32 receiveRevert = 0x2200000000000000000000000000000000000000000000000000000000000000; // Default recipient hook failure data for the mock only\n    bytes32 data32;\n    assembly {\n        data32 := mload(add(data, 32))\n    }\n    if (data32 == receiveRevert) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n}\n"
    },
    "contracts/mocks/ERC1400TokensSenderMock.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity ^0.8.0;\n\nimport \"../extensions/userExtensions/IERC1400TokensSender.sol\";\nimport \"../interface/ERC1820Implementer.sol\";\n\n\ncontract ERC1400TokensSenderMock is IERC1400TokensSender, ERC1820Implementer {\n\n  string constant internal ERC1400_TOKENS_SENDER = \"ERC1400TokensSender\";\n\n  constructor() {\n    ERC1820Implementer._setInterface(ERC1400_TOKENS_SENDER);\n  }\n\n  function canTransfer(\n    bytes calldata /*payload*/,\n    bytes32 /*partition*/,\n    address /*operator*/,\n    address from,\n    address to,\n    uint value,\n    bytes calldata data,\n    bytes calldata /*operatorData*/\n  ) // Comments to avoid compilation warnings for unused variables.\n    external\n    view\n    override\n    returns(bool)\n  {\n    return(_canTransfer(from, to, value, data));\n  }\n\n  function tokensToTransfer(\n    bytes calldata /*payload*/,\n    bytes32 /*partition*/,\n    address /*operator*/,\n    address from,\n    address to,\n    uint value,\n    bytes calldata data,\n    bytes calldata /*operatorData*/\n  ) // Comments to avoid compilation warnings for unused variables.\n    external\n    override\n  {\n    require(_canTransfer(from, to, value, data), \"56\"); // 0x56\tinvalid sender\n  }\n\n  function _canTransfer(\n    address /*from*/,\n    address /*to*/,\n    uint /*value*/,\n    bytes memory data\n  ) // Comments to avoid compilation warnings for unused variables.\n    internal\n    pure\n    returns(bool)\n  {\n    bytes32 transferRevert = 0x1100000000000000000000000000000000000000000000000000000000000000; // Default sender hook failure data for the mock only\n    bytes32 data32;\n    assembly {\n        data32 := mload(add(data, 32))\n    }\n    if (data32 == transferRevert) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n}"
    },
    "contracts/tools/BatchReader.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\n/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./ERC1820Client.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\n\n\nimport \"../interface/ERC1820Implementer.sol\";\n\nimport \"../IERC1400.sol\";\n\n/**\n * @notice Interface to the extension types\n */\ninterface IExtensionTypes {\n  enum CertificateValidation {\n    None,\n    NonceBased,\n    SaltBased\n  }\n}\n\ninterface IERC1400Extended {\n    // Not a real interface but added here for functions which don't belong to IERC1400\n\n    function owner() external view returns (address);\n\n    function controllers() external view returns (address[] memory);\n\n    function totalPartitions() external view returns (bytes32[] memory);\n\n    function getDefaultPartitions() external view returns (bytes32[] memory);\n\n    function totalSupplyByPartition(bytes32 partition) external view returns (uint256);\n}\n\nabstract contract IERC1400TokensValidatorExtended is IExtensionTypes {\n    // Not a real interface but added here for functions which don't belong to IERC1400TokensValidator\n\n    function retrieveTokenSetup(address token) external virtual view returns (CertificateValidation, bool, bool, bool, bool, address[] memory);\n\n    function spendableBalanceOfByPartition(address token, bytes32 partition, address account) external virtual view returns (uint256);\n\n    function isAllowlisted(address token, address account) public virtual view returns (bool);\n\n    function isBlocklisted(address token, address account) public virtual view returns (bool);\n}\n\n/**\n * @title BatchReader\n * @dev Proxy contract to read multiple information from the smart contract in a single contract call.\n */\ncontract BatchReader is IExtensionTypes, ERC1820Client, ERC1820Implementer {\n    using SafeMath for uint256;\n\n    string internal constant BALANCE_READER = \"BatchReader\";\n\n    string constant internal ERC1400_TOKENS_VALIDATOR = \"ERC1400TokensValidator\";\n\n    // Mapping from token to token extension address\n    mapping(address => address) internal _extension;\n\n    constructor() public {\n        ERC1820Implementer._setInterface(BALANCE_READER);\n    }\n\n    /**\n     * @dev Get batch of token supplies.\n     * @return Batch of token supplies.\n     */\n    function batchTokenSuppliesInfos(address[] calldata tokens) external view returns (uint256[] memory, uint256[] memory, bytes32[] memory, uint256[] memory, uint256[] memory, bytes32[] memory) {\n        uint256[] memory batchTotalSupplies = new uint256[](tokens.length);\n        for (uint256 j = 0; j < tokens.length; j++) {\n            batchTotalSupplies[j] = IERC20(tokens[j]).totalSupply();\n        }\n\n        (uint256[] memory totalPartitionsLengths, bytes32[] memory batchTotalPartitions, uint256[] memory batchPartitionSupplies) = batchTotalPartitions(tokens);\n\n        (uint256[] memory defaultPartitionsLengths, bytes32[] memory batchDefaultPartitions) = batchDefaultPartitions(tokens);\n\n        return (batchTotalSupplies, totalPartitionsLengths, batchTotalPartitions, batchPartitionSupplies, defaultPartitionsLengths, batchDefaultPartitions);\n    }\n\n    /**\n     * @dev Get batch of token roles.\n     * @return Batch of token roles.\n     */\n    function batchTokenRolesInfos(address[] calldata tokens) external view returns (address[] memory, uint256[] memory, address[] memory, uint256[] memory, address[] memory) {\n        (uint256[] memory batchExtensionControllersLength, address[] memory batchExtensionControllers) = batchExtensionControllers(tokens);\n\n        (uint256[] memory batchControllersLength, address[] memory batchControllers) = batchControllers(tokens);\n\n        address[] memory batchOwners = new address[](tokens.length);\n        for (uint256 i = 0; i < tokens.length; i++) {\n            batchOwners[i] = IERC1400Extended(tokens[i]).owner();\n        }\n        return (batchOwners, batchControllersLength, batchControllers, batchExtensionControllersLength, batchExtensionControllers);\n    }\n\n    /**\n     * @dev Get batch of token controllers.\n     * @return Batch of token controllers.\n     */\n    function batchControllers(address[] memory tokens) public view returns (uint256[] memory, address[] memory) {\n        uint256[] memory batchControllersLength = new uint256[](tokens.length);\n        uint256 controllersLength=0;\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            address[] memory controllers = IERC1400Extended(tokens[i]).controllers();\n            batchControllersLength[i] = controllers.length;\n            controllersLength = controllersLength.add(controllers.length);\n        }\n\n        address[] memory batchControllersResponse = new address[](controllersLength);\n\n        uint256 counter = 0;\n        for (uint256 j = 0; j < tokens.length; j++) {\n            address[] memory controllers = IERC1400Extended(tokens[j]).controllers();\n\n            for (uint256 k = 0; k < controllers.length; k++) {\n                batchControllersResponse[counter] = controllers[k];\n                counter++;\n            }\n        }\n\n        return (batchControllersLength, batchControllersResponse);\n    }\n\n    /**\n     * @dev Get batch of token extension controllers.\n     * @return Batch of token extension controllers.\n     */\n    function batchExtensionControllers(address[] memory tokens) public view returns (uint256[] memory, address[] memory) {\n        address[] memory batchTokenExtension = new address[](tokens.length);\n\n        uint256[] memory batchExtensionControllersLength = new uint256[](tokens.length);\n        uint256 extensionControllersLength=0;\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            batchTokenExtension[i] = interfaceAddr(tokens[i], ERC1400_TOKENS_VALIDATOR);\n\n            if (batchTokenExtension[i] != address(0)) {\n                (,,,,,address[] memory extensionControllers) = IERC1400TokensValidatorExtended(batchTokenExtension[i]).retrieveTokenSetup(tokens[i]);\n                batchExtensionControllersLength[i] = extensionControllers.length;\n                extensionControllersLength = extensionControllersLength.add(extensionControllers.length);\n            } else {\n                batchExtensionControllersLength[i] = 0;\n            }\n        }\n\n        address[] memory batchExtensionControllersResponse = new address[](extensionControllersLength);\n\n        uint256 counter = 0;\n        for (uint256 j = 0; j < tokens.length; j++) {\n            if (batchTokenExtension[j] != address(0)) {\n                (,,,,,address[] memory extensionControllers) = IERC1400TokensValidatorExtended(batchTokenExtension[j]).retrieveTokenSetup(tokens[j]);\n\n                for (uint256 k = 0; k < extensionControllers.length; k++) {\n                    batchExtensionControllersResponse[counter] = extensionControllers[k];\n                    counter++;\n                }\n            }\n        }\n\n        return (batchExtensionControllersLength, batchExtensionControllersResponse);\n    }\n\n    /**\n     * @dev Get batch of token extension setup.\n     * @return Batch of token extension setup.\n     */\n    function batchTokenExtensionSetup(address[] calldata tokens) external view returns (address[] memory, CertificateValidation[] memory, bool[] memory, bool[] memory, bool[] memory, bool[] memory) {\n        (address[] memory batchTokenExtension, CertificateValidation[] memory batchCertificateActivated, bool[] memory batchAllowlistActivated, bool[] memory batchBlocklistActivated) = batchTokenExtensionSetup1(tokens);\n\n        (bool[] memory batchGranularityByPartitionActivated, bool[] memory batchHoldsActivated) = batchTokenExtensionSetup2(tokens);\n        return (batchTokenExtension, batchCertificateActivated, batchAllowlistActivated, batchBlocklistActivated, batchGranularityByPartitionActivated, batchHoldsActivated);\n    }\n\n    /**\n     * @dev Get batch of token extension setup (part 1).\n     * @return Batch of token extension setup (part 1).\n     */\n    function batchTokenExtensionSetup1(address[] memory tokens) public view returns (address[] memory, CertificateValidation[] memory, bool[] memory, bool[] memory) {\n        address[] memory batchTokenExtension = new address[](tokens.length);\n        CertificateValidation[] memory batchCertificateActivated = new CertificateValidation[](tokens.length);\n        bool[] memory batchAllowlistActivated = new bool[](tokens.length);\n        bool[] memory batchBlocklistActivated = new bool[](tokens.length);\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            batchTokenExtension[i] = interfaceAddr(tokens[i], ERC1400_TOKENS_VALIDATOR);\n\n            if (batchTokenExtension[i] != address(0)) {\n                (CertificateValidation certificateActivated, bool allowlistActivated, bool blocklistActivated,,,) = IERC1400TokensValidatorExtended(batchTokenExtension[i]).retrieveTokenSetup(tokens[i]);\n                batchCertificateActivated[i] = certificateActivated;\n                batchAllowlistActivated[i] = allowlistActivated;\n                batchBlocklistActivated[i] = blocklistActivated;\n            } else {\n                batchCertificateActivated[i] = CertificateValidation.None;\n                batchAllowlistActivated[i] = false;\n                batchBlocklistActivated[i] = false;\n            }\n        }\n\n        return (batchTokenExtension, batchCertificateActivated, batchAllowlistActivated, batchBlocklistActivated);\n    }\n\n    /**\n     * @dev Get batch of token extension setup (part 2).\n     * @return Batch of token extension setup (part 2).\n     */\n    function batchTokenExtensionSetup2(address[] memory tokens) public view returns (bool[] memory, bool[] memory) {\n        address[] memory batchTokenExtension = new address[](tokens.length);\n        bool[] memory batchGranularityByPartitionActivated = new bool[](tokens.length);\n        bool[] memory batchHoldsActivated = new bool[](tokens.length);\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            batchTokenExtension[i] = interfaceAddr(tokens[i], ERC1400_TOKENS_VALIDATOR);\n\n            if (batchTokenExtension[i] != address(0)) {\n                (,,, bool granularityByPartitionActivated, bool holdsActivated,) = IERC1400TokensValidatorExtended(batchTokenExtension[i]).retrieveTokenSetup(tokens[i]);\n                batchGranularityByPartitionActivated[i] = granularityByPartitionActivated;\n                batchHoldsActivated[i] = holdsActivated;\n            } else {\n                batchGranularityByPartitionActivated[i] = false;\n                batchHoldsActivated[i] = false;\n            }\n        }\n\n        return (batchGranularityByPartitionActivated, batchHoldsActivated);\n    }\n\n    /**\n     * @dev Get batch of ERC1400 balances.\n     * @return Batch of ERC1400 balances.\n     */\n    function batchERC1400Balances(address[] calldata tokens, address[] calldata tokenHolders) external view returns (uint256[] memory, uint256[] memory, uint256[] memory, bytes32[] memory, uint256[] memory, uint256[] memory) {\n        (,, uint256[] memory batchSpendableBalancesOfByPartition) = batchSpendableBalanceOfByPartition(tokens, tokenHolders);\n\n        (uint256[] memory totalPartitionsLengths, bytes32[] memory batchTotalPartitions, uint256[] memory batchBalancesOfByPartition) = batchBalanceOfByPartition(tokens, tokenHolders);\n\n        uint256[] memory batchBalancesOf = batchBalanceOf(tokens, tokenHolders);\n\n        uint256[] memory batchEthBalances = batchEthBalance(tokenHolders);\n\n        return (batchEthBalances, batchBalancesOf, totalPartitionsLengths, batchTotalPartitions, batchBalancesOfByPartition, batchSpendableBalancesOfByPartition);\n    }\n\n    /**\n     * @dev Get batch of ERC20 balances.\n     * @return Batch of ERC20 balances.\n     */\n    function batchERC20Balances(address[] calldata tokens, address[] calldata tokenHolders) external view returns (uint256[] memory, uint256[] memory) {\n        uint256[] memory batchBalancesOf = batchBalanceOf(tokens, tokenHolders);\n\n        uint256[] memory batchEthBalances = batchEthBalance(tokenHolders);\n\n        return (batchEthBalances, batchBalancesOf);\n    }\n\n    /**\n     * @dev Get batch of ETH balances.\n     * @return Batch of token ETH balances.\n     */\n    function batchEthBalance(address[] memory tokenHolders) public view returns (uint256[] memory) {\n        uint256[] memory batchEthBalanceResponse = new uint256[](tokenHolders.length);\n\n        for (uint256 i = 0; i < tokenHolders.length; i++) {\n            batchEthBalanceResponse[i] = tokenHolders[i].balance;\n        }\n\n        return batchEthBalanceResponse;\n    }\n\n    /**\n     * @dev Get batch of ERC721 balances.\n     * @return Batch of ERC721 balances.\n     */\n    function batchERC721Balances(address[] calldata tokens, address[] calldata tokenHolders) external view returns (uint256[] memory, uint256[][][] memory) {\n        uint256[][][] memory batchBalanceOfResponse = new uint256[][][](tokens.length);\n\n        for (uint256 j = 0; j < tokens.length; j++) {\n            IERC721Enumerable token = IERC721Enumerable(tokens[j]);\n            uint256[][] memory batchBalance = new uint256[][](tokenHolders.length);\n            \n            for (uint256 i = 0; i < tokenHolders.length; i++) {\n                address holder = tokenHolders[i];\n                uint256 tokenCount = token.balanceOf(holder);\n\n                uint256[] memory balance = new uint256[](tokenCount);\n\n                for (uint256 k = 0; k < tokenCount; k++) {\n                    balance[k] = token.tokenOfOwnerByIndex(holder, k);\n                }\n\n                batchBalance[i] = balance;\n            }\n\n            batchBalanceOfResponse[j] = batchBalance;\n        }\n\n        uint256[] memory batchEthBalances = batchEthBalance(tokenHolders);\n\n        return (batchEthBalances, batchBalanceOfResponse);\n    }\n\n    /**\n     * @dev Get batch of token balances.\n     * @return Batch of token balances.\n     */\n    function batchBalanceOf(address[] memory tokens, address[] memory tokenHolders) public view returns (uint256[] memory) {\n        uint256[] memory batchBalanceOfResponse = new uint256[](tokenHolders.length * tokens.length);\n\n        for (uint256 i = 0; i < tokenHolders.length; i++) {\n            for (uint256 j = 0; j < tokens.length; j++) {\n                batchBalanceOfResponse[i*tokens.length + j] = IERC20(tokens[j]).balanceOf(tokenHolders[i]);\n            }\n        }\n\n        return batchBalanceOfResponse;\n    }\n\n    /**\n     * @dev Get batch of partition balances.\n     * @return Batch of token partition balances.\n     */\n    function batchBalanceOfByPartition(address[] memory tokens, address[] memory tokenHolders) public view returns (uint256[] memory, bytes32[] memory, uint256[] memory) {\n        (uint256[] memory totalPartitionsLengths, bytes32[] memory batchTotalPartitions,) = batchTotalPartitions(tokens);\n        \n        uint256[] memory batchBalanceOfByPartitionResponse = new uint256[](tokenHolders.length * batchTotalPartitions.length);\n\n        for (uint256 i = 0; i < tokenHolders.length; i++) {\n            uint256 counter = 0;\n            for (uint256 j = 0; j < tokens.length; j++) {\n                for (uint256 k = 0; k < totalPartitionsLengths[j]; k++) {\n                    batchBalanceOfByPartitionResponse[i*batchTotalPartitions.length + counter] = IERC1400(tokens[j]).balanceOfByPartition(batchTotalPartitions[counter], tokenHolders[i]);\n                    counter++;\n                }\n            }\n        }\n\n        return (totalPartitionsLengths, batchTotalPartitions, batchBalanceOfByPartitionResponse);\n    }\n\n    /**\n     * @dev Get batch of spendable partition balances.\n     * @return Batch of token spendable partition balances.\n     */\n    function batchSpendableBalanceOfByPartition(address[] memory tokens, address[] memory tokenHolders) public view returns (uint256[] memory, bytes32[] memory, uint256[] memory) {\n        (uint256[] memory totalPartitionsLengths, bytes32[] memory batchTotalPartitions,) = batchTotalPartitions(tokens);\n        \n        uint256[] memory batchSpendableBalanceOfByPartitionResponse = new uint256[](tokenHolders.length * batchTotalPartitions.length);\n\n        for (uint256 i = 0; i < tokenHolders.length; i++) {\n            uint256 counter = 0;\n            for (uint256 j = 0; j < tokens.length; j++) {\n                address tokenExtension = interfaceAddr(tokens[j], ERC1400_TOKENS_VALIDATOR);\n\n                for (uint256 k = 0; k < totalPartitionsLengths[j]; k++) {\n                    if (tokenExtension != address(0)) {\n                        batchSpendableBalanceOfByPartitionResponse[i*batchTotalPartitions.length + counter] = IERC1400TokensValidatorExtended(tokenExtension).spendableBalanceOfByPartition(tokens[j], batchTotalPartitions[counter], tokenHolders[i]);\n                    } else {\n                        batchSpendableBalanceOfByPartitionResponse[i*batchTotalPartitions.length + counter] = IERC1400(tokens[j]).balanceOfByPartition(batchTotalPartitions[counter], tokenHolders[i]);\n                    }\n                    counter++;\n                }\n            }\n        }\n\n        return (totalPartitionsLengths, batchTotalPartitions, batchSpendableBalanceOfByPartitionResponse);\n    }\n\n    /**\n     * @dev Get batch of token partitions.\n     * @return Batch of token partitions.\n     */\n    function batchTotalPartitions(address[] memory tokens) public view returns (uint256[] memory, bytes32[] memory, uint256[] memory) {\n        uint256[] memory batchTotalPartitionsLength = new uint256[](tokens.length);\n        uint256 totalPartitionsLength=0;\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            bytes32[] memory totalPartitions = IERC1400Extended(tokens[i]).totalPartitions();\n            batchTotalPartitionsLength[i] = totalPartitions.length;\n            totalPartitionsLength = totalPartitionsLength.add(totalPartitions.length);\n        }\n\n        bytes32[] memory batchTotalPartitionsResponse = new bytes32[](totalPartitionsLength);\n        uint256[] memory batchPartitionSupplies = new uint256[](totalPartitionsLength);\n\n        uint256 counter = 0;\n        for (uint256 j = 0; j < tokens.length; j++) {\n            bytes32[] memory totalPartitions = IERC1400Extended(tokens[j]).totalPartitions();\n\n            for (uint256 k = 0; k < totalPartitions.length; k++) {\n                batchTotalPartitionsResponse[counter] = totalPartitions[k];\n                batchPartitionSupplies[counter] = IERC1400Extended(tokens[j]).totalSupplyByPartition(totalPartitions[k]);\n                counter++;\n            }\n        }\n\n        return (batchTotalPartitionsLength, batchTotalPartitionsResponse, batchPartitionSupplies);\n    }\n\n    /**\n     * @dev Get batch of token default partitions.\n     * @return Batch of token default partitions.\n     */\n    function batchDefaultPartitions(address[] memory tokens) public view returns (uint256[] memory, bytes32[] memory) {\n        uint256[] memory batchDefaultPartitionsLength = new uint256[](tokens.length);\n        uint256 defaultPartitionsLength=0;\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            bytes32[] memory defaultPartitions = IERC1400Extended(tokens[i]).getDefaultPartitions();\n            batchDefaultPartitionsLength[i] = defaultPartitions.length;\n            defaultPartitionsLength = defaultPartitionsLength.add(defaultPartitions.length);\n        }\n\n        bytes32[] memory batchDefaultPartitionsResponse = new bytes32[](defaultPartitionsLength);\n\n        uint256 counter = 0;\n        for (uint256 j = 0; j < tokens.length; j++) {\n            bytes32[] memory defaultPartitions = IERC1400Extended(tokens[j]).getDefaultPartitions();\n\n            for (uint256 k = 0; k < defaultPartitions.length; k++) {\n                batchDefaultPartitionsResponse[counter] = defaultPartitions[k];\n                counter++;\n            }\n        }\n\n        return (batchDefaultPartitionsLength, batchDefaultPartitionsResponse);\n    }\n\n    /**\n     * @dev Get batch of validation status.\n     * @return Batch of validation status.\n     */\n    function batchValidations(address[] memory tokens, address[] memory tokenHolders) public view returns (bool[] memory, bool[] memory) {\n        bool[] memory batchAllowlisted = batchAllowlisted(tokens, tokenHolders);\n        bool[] memory batchBlocklisted = batchBlocklisted(tokens, tokenHolders);\n\n        return (batchAllowlisted, batchBlocklisted);\n    }\n\n    /**\n     * @dev Get batch of allowlisted status.\n     * @return Batch of allowlisted status.\n     */\n    function batchAllowlisted(address[] memory tokens, address[] memory tokenHolders) public view returns (bool[] memory) {\n        bool[] memory batchAllowlistedResponse = new bool[](tokenHolders.length * tokens.length);\n\n        for (uint256 i = 0; i < tokenHolders.length; i++) {\n            for (uint256 j = 0; j < tokens.length; j++) {\n                address tokenExtension = interfaceAddr(tokens[j], ERC1400_TOKENS_VALIDATOR);\n                if (tokenExtension != address(0)) {\n                    batchAllowlistedResponse[i*tokens.length + j] = IERC1400TokensValidatorExtended(tokenExtension).isAllowlisted(tokens[j], tokenHolders[i]);\n                } else {\n                    batchAllowlistedResponse[i*tokens.length + j] = false;\n                }\n            }\n        }\n        return batchAllowlistedResponse;\n    }\n\n    /**\n     * @dev Get batch of blocklisted status.\n     * @return Batch of blocklisted status.\n     */\n    function batchBlocklisted(address[] memory tokens, address[] memory tokenHolders) public view returns (bool[] memory) {\n        bool[] memory batchBlocklistedResponse = new bool[](tokenHolders.length * tokens.length);\n\n        for (uint256 i = 0; i < tokenHolders.length; i++) {\n            for (uint256 j = 0; j < tokens.length; j++) {\n                address tokenExtension = interfaceAddr(tokens[j], ERC1400_TOKENS_VALIDATOR);\n                if (tokenExtension != address(0)) {\n                    batchBlocklistedResponse[i*tokens.length + j] = IERC1400TokensValidatorExtended(tokenExtension).isBlocklisted(tokens[j], tokenHolders[i]);\n                } else {\n                    batchBlocklistedResponse[i*tokens.length + j] = false;\n                }\n            }\n        }\n        return batchBlocklistedResponse;\n    }\n\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721URIStorage.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorage is ERC721 {\n    using Strings for uint256;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721URIStorage: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n"
    },
    "contracts/tokens/ERC721Token.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Pausable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"../interface/ERC1820Implementer.sol\";\nimport \"../roles/MinterRole.sol\";\n\ncontract ERC721Token is Ownable, ERC721, ERC721URIStorage, ERC721Enumerable, ERC721Burnable, ERC721Pausable,  MinterRole, ERC1820Implementer, AccessControlEnumerable {\n  string constant internal ERC721_TOKEN = \"ERC721Token\";\n  string internal _baseUri;\n  string internal _contractUri;\n\n  constructor(string memory name, string memory symbol, string memory baseUri, string memory contractUri) ERC721(name, symbol) {\n    ERC1820Implementer._setInterface(ERC721_TOKEN);\n    _baseUri = baseUri;\n    _contractUri = contractUri;\n  }\n\n  /**\n  * @dev Function to mint tokens\n  * @param to The address that will receive the minted tokens.\n  * @param tokenId The token id to mint.\n  * @return A boolean that indicates if the operation was successful.\n  */\n  function mint(address to, uint256 tokenId) public onlyMinter returns (bool) {\n      _mint(to, tokenId);\n      return true;\n  }\n  \n  function mintAndSetTokenURI(address to, uint256 tokenId, string memory uri) public onlyMinter returns (bool) {\n      _mint(to, tokenId);\n      _setTokenURI(tokenId, uri);\n      return true;\n  }\n\n  function tokenURI(uint256 tokenId) public view virtual override(ERC721, ERC721URIStorage) returns (string memory) {\n      return ERC721URIStorage.tokenURI(tokenId);\n  }\n\n  function setTokenURI(uint256 tokenId, string memory uri) public virtual onlyMinter {\n      _setTokenURI(tokenId, uri);\n  }\n\n  function _baseURI() internal view override virtual returns (string memory) {\n      return _baseUri;\n  }\n\n  function _beforeTokenTransfer(\n      address from,\n      address to,\n      uint256 tokenId\n  ) internal virtual override(ERC721, ERC721Enumerable, ERC721Pausable) {\n      super._beforeTokenTransfer(from, to, tokenId);\n  }\n\n  /**\n    * @dev See {IERC165-supportsInterface}.\n    */\n  function supportsInterface(bytes4 interfaceId)\n      public\n      view\n      virtual\n      override(AccessControlEnumerable, ERC721, ERC721Enumerable)\n      returns (bool)\n  {\n      return super.supportsInterface(interfaceId);\n  }\n\n  function _burn(uint256 tokenId) internal virtual override(ERC721, ERC721URIStorage) {\n      ERC721URIStorage._burn(tokenId);\n  }\n\n  function setContractURI(string memory uri) public virtual onlyOwner {\n      _contractUri = uri;\n  }\n\n  function contractURI() public view returns (string memory) {\n    return _contractUri;\n  }\n\n  /************************************* Domain Aware ******************************************/\n/*  function domainName() public override view returns (string memory) {\n    return name();\n  }\n\n  function domainVersion() public override view returns (string memory) {\n    return \"1\";\n  }*/\n  /************************************************************************************************/\n}"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\n */\nabstract contract ERC721Burnable is Context, ERC721 {\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Burnable: caller is not owner nor approved\");\n        _burn(tokenId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC721 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC721Pausable is ERC721, Pausable {\n    /**\n     * @dev See {ERC721-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        require(!paused(), \"ERC721Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerable.sol\";\nimport \"./AccessControl.sol\";\nimport \"../utils/structs/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/tokens/ERC20Token.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol\";\n\nimport \"../interface/ERC1820Implementer.sol\";\nimport \"../roles/MinterRole.sol\";\n\ncontract ERC20Token is Ownable, ERC20Burnable, ERC20Pausable, ERC1820Implementer, MinterRole {\n  string constant internal ERC20_TOKEN = \"ERC20Token\";\n  uint8 immutable internal _decimals;\n\n  constructor(string memory name, string memory symbol, uint8 __decimals) ERC20(name, symbol) {\n    ERC1820Implementer._setInterface(ERC20_TOKEN);\n    _decimals = __decimals;\n  }\n\n  /**\n    * @dev Returns the number of decimals used to get its user representation.\n    * For example, if `decimals` equals `2`, a balance of `505` tokens should\n    * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n    *\n    * Tokens usually opt for a value of 18, imitating the relationship between\n    * Ether and Wei. This is the value {ERC20} uses, unless this function is\n    * overridden;\n    *\n    * NOTE: This information is only used for _display_ purposes: it in\n    * no way affects any of the arithmetic of the contract, including\n    * {IERC20-balanceOf} and {IERC20-transfer}.\n    */\n  function decimals() public view virtual override returns (uint8) {\n      return _decimals;\n  }\n\n    /**\n    * @dev Function to mint tokens\n    * @param to The address that will receive the minted tokens.\n    * @param value The amount of tokens to mint.\n    * @return A boolean that indicates if the operation was successful.\n    */\n  function mint(address to, uint256 value) public onlyMinter returns (bool) {\n      _mint(to, value);\n      return true;\n  }\n  \n  function _beforeTokenTransfer(\n      address from,\n      address to,\n      uint256 amount\n  ) internal override(ERC20Pausable, ERC20) {\n    ERC20Pausable._beforeTokenTransfer(from, to, amount);\n  }\n\n  /************************************* Domain Aware ******************************************/\n/*  function domainName() public override view returns (string memory) {\n    return name();\n  }\n\n  function domainVersion() public override view returns (string memory) {\n    return \"1\";\n  }*/\n  /************************************************************************************************/\n}"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "contracts/dids/EthereumDIDRegistry.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity ^0.8.0;\n// Props to https://github.com/uport-project/ethr-did-registry/pull/33\nimport \"./IERC1271.sol\";\n\n// libraries\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\ncontract EthereumDIDRegistry {\n    bytes4 internal constant _ERC1271_MAGICVALUE = 0x1626ba7e;\n\n    mapping(address => address) public owners;\n    mapping(address => mapping(bytes32 => mapping(address => uint256)))\n        public delegates;\n    mapping(address => uint256) public changed;\n    mapping(address => uint256) public nonce;\n\n    modifier onlyOwner(address identity, address actor) {\n        require(actor == identityOwner(identity));\n        _;\n    }\n\n    event DIDOwnerChanged(\n        address indexed identity,\n        address owner,\n        uint256 previousChange\n    );\n\n    event DIDDelegateChanged(\n        address indexed identity,\n        bytes32 delegateType,\n        address delegate,\n        uint256 validTo,\n        uint256 previousChange\n    );\n\n    event DIDAttributeChanged(\n        address indexed identity,\n        bytes32 name,\n        bytes value,\n        uint256 validTo,\n        uint256 previousChange\n    );\n\n    function identityOwner(address identity) public view returns (address) {\n        address owner = owners[identity];\n        if (owner != address(0x0)) {\n            return owner;\n        }\n        return identity;\n    }\n\n    function checkSignature(\n        address identity,\n        uint8 sigV,\n        bytes32 sigR,\n        bytes32 sigS,\n        bytes32 hash\n    ) internal returns (address) {\n        address signer = ecrecover(hash, sigV, sigR, sigS);\n        require(signer == identityOwner(identity));\n        nonce[signer]++;\n        return signer;\n    }\n\n    /**\n     * @notice Checks if an identity's owner had provided a valid `_signature` for `_hash`.\n     * If the identity's owner is a smart contract, the 'isValidSignature' will be called accourding to ERC1271 interface.\n     *\n     * @param _hash hash of the data signed//Arbitrary length data signed on the behalf of `identity`\n     * @param _signature identity's signature(s) of the data\n     */\n    function checkSignature(\n        address identity,\n        bytes32 _hash,\n        bytes memory _signature\n    ) internal returns (address) {\n        address owner = identityOwner(identity);\n        bool isContract;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            isContract := gt(extcodesize(owner), 0)\n        }\n        if (isContract) {\n            require(\n                _ERC1271_MAGICVALUE ==\n                    ERC1271(owner).isValidSignature(_hash, _signature)\n            );\n            nonce[owner]++;\n            return owner;\n        } else {\n            address signer = ECDSA.recover(_hash, _signature);\n            require(signer == identityOwner(identity));\n            nonce[signer]++;\n            return signer;\n        }\n    }\n\n    function validDelegate(\n        address identity,\n        bytes32 delegateType,\n        address delegate\n    ) public view returns (bool) {\n        uint256 validity = delegates[identity][\n            keccak256(abi.encodePacked(delegateType))\n        ][delegate];\n        return (validity > block.timestamp);\n    }\n\n    function changeOwner(\n        address identity,\n        address actor,\n        address newOwner\n    ) internal onlyOwner(identity, actor) {\n        owners[identity] = newOwner;\n        emit DIDOwnerChanged(identity, newOwner, changed[identity]);\n        changed[identity] = block.number;\n    }\n\n    function changeOwner(address identity, address newOwner) public {\n        changeOwner(identity, msg.sender, newOwner);\n    }\n\n    function changeOwnerSigned(\n        address identity,\n        uint8 sigV,\n        bytes32 sigR,\n        bytes32 sigS,\n        address newOwner\n    ) public {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0x19),\n                bytes1(0),\n                this,\n                nonce[identityOwner(identity)],\n                identity,\n                \"changeOwner\",\n                newOwner\n            )\n        );\n        changeOwner(\n            identity,\n            checkSignature(identity, sigV, sigR, sigS, hash),\n            newOwner\n        );\n    }\n\n    function changeOwnerSigned(\n        address identity,\n        bytes memory signature,\n        address newOwner\n    ) public {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0x19),\n                bytes1(0),\n                this,\n                nonce[identityOwner(identity)],\n                identity,\n                \"changeOwner\",\n                newOwner\n            )\n        );\n        changeOwner(\n            identity,\n            checkSignature(identity, hash, signature),\n            newOwner\n        );\n    }\n\n    function addDelegate(\n        address identity,\n        address actor,\n        bytes32 delegateType,\n        address delegate,\n        uint256 validity\n    ) internal onlyOwner(identity, actor) {\n        delegates[identity][keccak256(abi.encodePacked(delegateType))][\n            delegate\n        ] = block.timestamp + validity;\n        emit DIDDelegateChanged(\n            identity,\n            delegateType,\n            delegate,\n            block.timestamp + validity,\n            changed[identity]\n        );\n        changed[identity] = block.number;\n    }\n\n    function addDelegate(\n        address identity,\n        bytes32 delegateType,\n        address delegate,\n        uint256 validity\n    ) public {\n        addDelegate(identity, msg.sender, delegateType, delegate, validity);\n    }\n\n    function addDelegateSigned(\n        address identity,\n        uint8 sigV,\n        bytes32 sigR,\n        bytes32 sigS,\n        bytes32 delegateType,\n        address delegate,\n        uint256 validity\n    ) public {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0x19),\n                bytes1(0),\n                this,\n                nonce[identityOwner(identity)],\n                identity,\n                \"addDelegate\",\n                delegateType,\n                delegate,\n                validity\n            )\n        );\n        addDelegate(\n            identity,\n            checkSignature(identity, sigV, sigR, sigS, hash),\n            delegateType,\n            delegate,\n            validity\n        );\n    }\n\n    function addDelegateSigned(\n        address identity,\n        bytes memory signature,\n        bytes32 delegateType,\n        address delegate,\n        uint256 validity\n    ) public {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0x19),\n                bytes1(0),\n                this,\n                nonce[identityOwner(identity)],\n                identity,\n                \"addDelegate\",\n                delegateType,\n                delegate,\n                validity\n            )\n        );\n        addDelegate(\n            identity,\n            checkSignature(identity, hash, signature),\n            delegateType,\n            delegate,\n            validity\n        );\n    }\n\n    function revokeDelegate(\n        address identity,\n        address actor,\n        bytes32 delegateType,\n        address delegate\n    ) internal onlyOwner(identity, actor) {\n        delegates[identity][keccak256(abi.encodePacked(delegateType))][\n            delegate\n        ] = block.timestamp;\n        emit DIDDelegateChanged(\n            identity,\n            delegateType,\n            delegate,\n            block.timestamp,\n            changed[identity]\n        );\n        changed[identity] = block.number;\n    }\n\n    function revokeDelegate(\n        address identity,\n        bytes32 delegateType,\n        address delegate\n    ) public {\n        revokeDelegate(identity, msg.sender, delegateType, delegate);\n    }\n\n    function revokeDelegateSigned(\n        address identity,\n        uint8 sigV,\n        bytes32 sigR,\n        bytes32 sigS,\n        bytes32 delegateType,\n        address delegate\n    ) public {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0x19),\n                bytes1(0),\n                this,\n                nonce[identityOwner(identity)],\n                identity,\n                \"revokeDelegate\",\n                delegateType,\n                delegate\n            )\n        );\n        revokeDelegate(\n            identity,\n            checkSignature(identity, sigV, sigR, sigS, hash),\n            delegateType,\n            delegate\n        );\n    }\n\n    function revokeDelegateSigned(\n        address identity,\n        bytes memory signature,\n        bytes32 delegateType,\n        address delegate\n    ) public {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0x19),\n                bytes1(0),\n                this,\n                nonce[identityOwner(identity)],\n                identity,\n                \"revokeDelegate\",\n                delegateType,\n                delegate\n            )\n        );\n        revokeDelegate(\n            identity,\n            checkSignature(identity, hash, signature),\n            delegateType,\n            delegate\n        );\n    }\n\n    function setAttribute(\n        address identity,\n        address actor,\n        bytes32 name,\n        bytes memory value,\n        uint256 validity\n    ) internal onlyOwner(identity, actor) {\n        emit DIDAttributeChanged(\n            identity,\n            name,\n            value,\n            block.timestamp + validity,\n            changed[identity]\n        );\n        changed[identity] = block.number;\n    }\n\n    function setAttribute(\n        address identity,\n        bytes32 name,\n        bytes memory value,\n        uint256 validity\n    ) public {\n        setAttribute(identity, msg.sender, name, value, validity);\n    }\n\n    function setAttributeSigned(\n        address identity,\n        uint8 sigV,\n        bytes32 sigR,\n        bytes32 sigS,\n        bytes32 name,\n        bytes memory value,\n        uint256 validity\n    ) public {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0x19),\n                bytes1(0),\n                this,\n                nonce[identityOwner(identity)],\n                identity,\n                \"setAttribute\",\n                name,\n                value,\n                validity\n            )\n        );\n        setAttribute(\n            identity,\n            checkSignature(identity, sigV, sigR, sigS, hash),\n            name,\n            value,\n            validity\n        );\n    }\n\n    function setAttributeSigned(\n        address identity,\n        bytes memory signature,\n        bytes32 name,\n        bytes memory value,\n        uint256 validity\n    ) public {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0x19),\n                bytes1(0),\n                this,\n                nonce[identityOwner(identity)],\n                identity,\n                \"setAttribute\",\n                name,\n                value,\n                validity\n            )\n        );\n        setAttribute(\n            identity,\n            checkSignature(identity, hash, signature),\n            name,\n            value,\n            validity\n        );\n    }\n\n    function revokeAttribute(\n        address identity,\n        address actor,\n        bytes32 name,\n        bytes memory value\n    ) internal onlyOwner(identity, actor) {\n        emit DIDAttributeChanged(identity, name, value, 0, changed[identity]);\n        changed[identity] = block.number;\n    }\n\n    function revokeAttribute(\n        address identity,\n        bytes32 name,\n        bytes memory value\n    ) public {\n        revokeAttribute(identity, msg.sender, name, value);\n    }\n\n    function revokeAttributeSigned(\n        address identity,\n        uint8 sigV,\n        bytes32 sigR,\n        bytes32 sigS,\n        bytes32 name,\n        bytes memory value\n    ) public {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0x19),\n                bytes1(0),\n                this,\n                nonce[identityOwner(identity)],\n                identity,\n                \"revokeAttribute\",\n                name,\n                value\n            )\n        );\n        revokeAttribute(\n            identity,\n            checkSignature(identity, sigV, sigR, sigS, hash),\n            name,\n            value\n        );\n    }\n\n    function revokeAttributeSigned(\n        address identity,\n        bytes memory signature,\n        bytes32 name,\n        bytes memory value\n    ) public {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0x19),\n                bytes1(0),\n                this,\n                nonce[identityOwner(identity)],\n                identity,\n                \"revokeAttribute\",\n                name,\n                value\n            )\n        );\n        revokeAttribute(\n            identity,\n            checkSignature(identity, hash, signature),\n            name,\n            value\n        );\n    }\n}\n"
    },
    "contracts/dids/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity ^0.8.0;\n\n/**\n * @notice ERC-1271: Standard Signature Validation Method for Contracts\n */\nabstract contract ERC1271 {\n    // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n    bytes4 internal constant MAGICVALUE = 0x1626ba7e;\n\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param _hash Arbitrary length data signed on the behalf of address(this)\n     * @param _signature Signature byte array associated with _hash\n     *\n     * MUST return the bytes4 magic value 0x1626ba7e when function passes.\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n     * MUST allow external calls\n     */\n\n    function isValidSignature(bytes32 _hash, bytes memory _signature)\n        public\n        view\n        virtual\n        returns (bytes4 magicValue);\n}\n"
    },
    "contracts/tokens/ERC20HoldableToken.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\n/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"./ERC20Token.sol\";\nimport \"../interface/IERC20HoldableToken.sol\";\n\n/**\n * @title ERC20HoldableToken\n * @notice A hold is like an approve where held tokens can not be spent by the token holder until after an hold expiration period.\n    The hold can be executed by a notary, which can be the recipient of the tokens, a third party or a smart contract.\n    The notary can execute the hold before or after the expiration period.\n    Additionally, a hash lock at be applied which requires the notary of the hold to present the hash preimage to execute the hold.\n    Held tokens can be released by the notary at any time or by the token holder after the expiration period.\n    A recipient does not have to get set at the time of the hold, which means it will have to be specified when the hold is executed.\n */\ncontract ERC20HoldableToken is ERC20Token, IERC20HoldableToken {\n    using SafeMath for uint256;\n\n    // mapping of accounts to hold data\n    mapping(bytes32 => ERC20HoldData) internal holds;\n    // mapping of accounts and their total amount on hold\n    mapping(address => uint256) internal accountHoldBalances;\n\n    mapping(bytes32 => bytes32) internal _holdHashToId;\n\n    uint256 override public totalSupplyOnHold;\n\n    modifier isHeld(bytes32 holdId) {\n        require(\n            holds[holdId].status == HoldStatusCode.Ordered ||\n            holds[holdId].status == HoldStatusCode.ExecutedAndKeptOpen,\n            \"Hold is not in Ordered status\"\n        );\n        _;\n    }\n\n    constructor(string memory name, string memory symbol, uint8 decimals) ERC20Token(name, symbol, decimals) {}\n\n    function generateHoldId(\n        address recipient,\n        address notary,\n        uint256 amount,\n        uint256 expirationDateTime,\n        bytes32 lockHash\n    ) external pure returns (bytes32 holdId) {\n        holdId = keccak256(\n            abi.encodePacked(\n                recipient,\n                notary,\n                amount,\n                expirationDateTime,\n                lockHash\n            )\n        );\n    }\n\n    /**\n    * @dev Retrieve hold hash, and ID for given parameters\n    */\n    function retrieveHoldHashId(address notary, address sender, address recipient, uint value) public view returns (bytes32, bytes32) {\n        // Pack and hash hold parameters\n        bytes32 holdHash = keccak256(abi.encodePacked(\n            address(this), //Include the token address to indicate domain\n            sender,\n            recipient,\n            notary,\n            value\n        ));\n        bytes32 holdId = _holdHashToId[holdHash];\n\n        return (holdHash, holdId);\n    }  \n\n    /**\n     @notice Called by the sender to hold some tokens for a recipient that the sender can not release back to themself until after the expiration date.\n     @param recipient optional account the tokens will be transferred to on execution. If a zero address, the recipient must be specified on execution of the hold.\n     @param notary account that can execute the hold. Typically the recipient but can be a third party or a smart contact.\n     @param amount of tokens to be transferred to the recipient on execution. Must be a non zero amount.\n     @param expirationDateTime UNIX epoch seconds the held amount can be released back to the sender by the sender. Past dates are allowed.\n     @param lockHash optional keccak256 hash of a lock preimage. An empty hash will not enforce the hash lock when the hold is executed.\n     @return holdId a unique identifier for the hold.\n     */\n    function hold(\n        bytes32 holdId,\n        address recipient,\n        address notary,\n        uint256 amount,\n        uint256 expirationDateTime,\n        bytes32 lockHash\n    ) public override returns (bool) {\n        require(\n            notary != address(0),\n            \"hold: notary must not be a zero address\"\n        );\n        require(amount != 0, \"hold: amount must be greater than zero\");\n        require(\n            this.spendableBalanceOf(msg.sender) >= amount,\n            \"hold: amount exceeds available balance\"\n        );\n\n        (bytes32 holdHash,) = retrieveHoldHashId(\n            notary,\n            _msgSender(),\n            recipient,\n            amount\n        );\n\n        _holdHashToId[holdHash] = holdId;\n\n        require(\n            holds[holdId].status == HoldStatusCode.Nonexistent,\n            \"hold: id already exists\"\n        );\n        holds[holdId] = ERC20HoldData(\n            msg.sender,\n            recipient,\n            notary,\n            amount,\n            expirationDateTime,\n            lockHash,\n            HoldStatusCode.Ordered\n        );\n        accountHoldBalances[msg.sender] = accountHoldBalances[msg.sender].add(\n            amount\n        );\n        totalSupplyOnHold = totalSupplyOnHold.add(amount);\n\n        emit NewHold(\n            holdId,\n            recipient,\n            notary,\n            amount,\n            expirationDateTime,\n            lockHash\n        );\n    }\n\n    function retrieveHoldData(bytes32 holdId) external override view returns (ERC20HoldData memory) {\n        return holds[holdId];\n    }\n\n    /**\n     @notice Called by the notary to transfer the held tokens to the set at the hold recipient if there is no hash lock.\n     @param holdId a unique identifier for the hold.\n     */\n    function executeHold(bytes32 holdId) public override {\n        require(\n            holds[holdId].recipient != address(0),\n            \"executeHold: must pass the recipient on execution as the recipient was not set on hold\"\n        );\n        require(\n            holds[holdId].secretHash == bytes32(0),\n            \"executeHold: need preimage if the hold has a lock hash\"\n        );\n\n        _executeHold(holdId, \"\", holds[holdId].recipient);\n    }\n\n    /**\n     @notice Called by the notary to transfer the held tokens to the recipient that was set at the hold.\n     @param holdId a unique identifier for the hold.\n     @param lockPreimage the image used to generate the lock hash with a sha256 hash\n     */\n    function executeHold(bytes32 holdId, bytes32 lockPreimage) public override {\n        require(\n            holds[holdId].recipient != address(0),\n            \"executeHold: must pass the recipient on execution as the recipient was not set on hold\"\n        );\n        if (holds[holdId].secretHash != bytes32(0)) {\n            require(\n                holds[holdId].secretHash ==\n                    sha256(abi.encodePacked(lockPreimage)),\n                \"executeHold: preimage hash does not match lock hash\"\n            );\n        }\n\n        _executeHold(holdId, lockPreimage, holds[holdId].recipient);\n    }\n\n    /**\n     @notice Called by the notary to transfer the held tokens to the recipient if no recipient was specified at the hold.\n     @param holdId a unique identifier for the hold.\n     @param lockPreimage the image used to generate the lock hash with a keccak256 hash\n     @param recipient the account the tokens will be transferred to on execution.\n     */\n    function executeHold(\n        bytes32 holdId,\n        bytes32 lockPreimage,\n        address recipient\n    ) public override {\n        require(\n            holds[holdId].recipient == address(0),\n            \"executeHold: can not set a recipient on execution as it was set on hold\"\n        );\n        require(\n            recipient != address(0),\n            \"executeHold: recipient must not be a zero address\"\n        );\n        if (holds[holdId].secretHash != bytes32(0)) {\n            require(\n                holds[holdId].secretHash ==\n                    sha256(abi.encodePacked(lockPreimage)),\n                \"executeHold: preimage hash does not match lock hash\"\n            );\n        }\n\n        holds[holdId].recipient = recipient;\n\n        _executeHold(holdId, lockPreimage, recipient);\n    }\n\n    function _executeHold(\n        bytes32 holdId,\n        bytes32 lockPreimage,\n        address recipient\n    ) internal isHeld(holdId) {\n        require(\n            holds[holdId].notary == msg.sender,\n            \"executeHold: caller must be the hold notary\"\n        );\n\n        super._transfer(holds[holdId].sender, recipient, holds[holdId].amount);\n\n        holds[holdId].status = HoldStatusCode.Executed;\n        accountHoldBalances[holds[holdId]\n            .sender] = accountHoldBalances[holds[holdId].sender].sub(\n            holds[holdId].amount\n        );\n        totalSupplyOnHold = totalSupplyOnHold.sub(holds[holdId].amount);\n\n        (bytes32 holdHash,) = retrieveHoldHashId(\n            holds[holdId].notary,\n            holds[holdId].sender,\n            holds[holdId].recipient,\n            holds[holdId].amount\n        );\n\n        delete _holdHashToId[holdHash];\n\n        emit ExecutedHold(holdId, lockPreimage, recipient);\n    }\n\n    /**\n     @notice Called by the notary at any time or the sender after the expiration date to release the held tokens back to the sender.\n     @param holdId a unique identifier for the hold.\n     */\n    function releaseHold(bytes32 holdId) public override isHeld(holdId) {\n        if (holds[holdId].sender == msg.sender) {\n            require(\n                block.timestamp > holds[holdId].expirationDateTime,\n                \"releaseHold: can only release after the expiration date.\"\n            );\n            holds[holdId].status = HoldStatusCode.ReleasedOnExpiration;\n        } else if (holds[holdId].notary != msg.sender) {\n            revert(\"releaseHold: caller must be the hold sender or notary.\");\n        } else {\n            holds[holdId].status = HoldStatusCode.ReleasedByNotary;\n        }\n\n        accountHoldBalances[holds[holdId]\n            .sender] = accountHoldBalances[holds[holdId].sender].sub(\n            holds[holdId].amount\n        );\n        totalSupplyOnHold = totalSupplyOnHold.sub(holds[holdId].amount);\n\n        emit ReleaseHold(holdId, msg.sender);\n    }\n\n    /**\n     @notice Amount of tokens owned by an account that are available for transfer. That is, the gross balance less any held tokens.\n     @param account owner of the tokensß\n     */\n    function balanceOf(address account) public override(ERC20, IERC20) view returns (uint256) {\n        return super.balanceOf(account);\n        \n    }\n\n    /**\n     @notice Amount of tokens owned by an account that are held pending execution or release.\n     @param account owner of the tokens\n     */\n    function balanceOnHold(address account) public override view returns (uint256) {\n        return accountHoldBalances[account];\n    }\n\n    /**\n     @notice Total amount of tokens owned by an account including all the held tokens pending execution or release.\n     @param account owner of the tokens\n     */\n    function spendableBalanceOf(address account) public override view returns (uint256) {\n        return super.balanceOf(account).sub(accountHoldBalances[account]);\n    }\n\n    /**\n     @param holdId a unique identifier for the hold.\n     @return hold status code.\n     */\n    function holdStatus(bytes32 holdId) public override view returns (HoldStatusCode) {\n        return holds[holdId].status;\n    }\n\n    /**\n     @notice ERC20 transfer that checks on hold tokens can not be transferred.\n     */\n    function transfer(address recipient, uint256 amount) public override(ERC20, IERC20) returns (bool) {\n        require(\n            this.spendableBalanceOf(msg.sender) >= amount,\n            \"HoldableToken: amount exceeds available balance\"\n        );\n        return super.transfer(recipient, amount);\n    }\n\n    /**\n     @notice ERC20 transferFrom that checks on hold tokens can not be transferred.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override(ERC20, IERC20) returns (bool) {\n        require(\n            this.spendableBalanceOf(sender) >= amount,\n            \"HoldableToken: amount exceeds available balance\"\n        );\n        return super.transferFrom(sender, recipient, amount);\n    }\n\n    /**\n     @notice ERC20 approve that checks on hold tokens can not be approved for spending by another account.\n     */\n    function approve(address spender, uint256 amount) public override(ERC20, IERC20) returns (bool) {\n        require(\n            this.spendableBalanceOf(msg.sender) >= amount,\n            \"HoldableToken: amount exceeds available balance\"\n        );\n        return super.approve(spender, amount);\n    }\n\n    /**\n     @notice ERC20 burn that checks on hold tokens can not be burnt.\n     */\n    function burn(uint256 amount) public override {\n        require(\n            this.spendableBalanceOf(msg.sender) >= amount,\n            \"HoldableToken: amount exceeds available balance\"\n        );\n        super.burn(amount);\n    }\n\n    /**\n     @notice ERC20 burnFrom that checks on hold tokens can not be burnt.\n     */\n    function burnFrom(address account, uint256 amount) public override {\n        require(\n            this.spendableBalanceOf(msg.sender) >= amount,\n            \"HoldableToken: amount exceeds available balance\"\n        );\n        super.burnFrom(account, amount);\n    }\n}\n"
    },
    "contracts/mocks/MinterRoleMock.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity ^0.8.0;\n\n// MOCK CONTRACT TO REACH FULL COVERAGE BY CALLING \"onlyMinter\" MODIFIER\n\nimport \"../roles/MinterRole.sol\";\n\n\ncontract MinterMock is MinterRole {\n\n  constructor() MinterRole() {}\n\n}"
    },
    "contracts/mocks/BlocklistMock.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity ^0.8.0;\n\n// MOCK CONTRACT TO REACH FULL COVERAGE BY CALLING \"onlyNotBlocklisted\" MODIFIER\n\nimport \"../roles/BlocklistedRole.sol\";\n\n\ncontract BlocklistMock is BlocklistedRole {\n\n  bool _mockActivated;\n\n  constructor(address token) {\n    _addBlocklistAdmin(token, msg.sender);\n  }\n\n  function mockFunction(address token, bool mockActivated) external onlyNotBlocklisted(token) {\n    _mockActivated = mockActivated;\n  }\n\n}"
    },
    "contracts/mocks/AllowlistMock.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity ^0.8.0;\n\n// MOCK CONTRACT TO REACH FULL COVERAGE BY CALLING \"onlyNotAllowlisted\" MODIFIER\n\nimport \"../roles/AllowlistedRole.sol\";\n\n\ncontract AllowlistMock is AllowlistedRole {\n\n  bool _mockActivated;\n\n  constructor(address token) {\n    _addAllowlistAdmin(token, msg.sender);\n  }\n\n  function mockFunction(address token, bool mockActivated) external onlyNotAllowlisted(token) {\n    _mockActivated = mockActivated;\n  }\n\n}"
    },
    "contracts/mocks/CertificateSignerMock.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity ^0.8.0;\n\n// MOCK CONTRACT TO REACH FULL COVERAGE BY CALLING \"onlyNotPausered\" MODIFIER\n\nimport \"../roles/CertificateSignerRole.sol\";\n\n\ncontract CertificateSignerMock is CertificateSignerRole {\n\n  constructor(address token) {\n    _addCertificateSigner(token, msg.sender);\n  }\n\n}"
    },
    "contracts/mocks/PauserMock.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity ^0.8.0;\n\n// MOCK CONTRACT TO REACH FULL COVERAGE BY CALLING \"onlyNotPausered\" MODIFIER\n\nimport \"../roles/PauserRole.sol\";\n\n\ncontract PauserMock is PauserRole {\n\n  bool _mockActivated;\n\n  constructor(address token) {\n    _addPauser(token, msg.sender);\n  }\n\n  function mockFunction(address token, bool mockActivated) external onlyPauser(token) {\n    _mockActivated = mockActivated;\n  }\n\n}"
    },
    "contracts/tools/BatchBalanceReader.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\n/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interface/ERC1820Implementer.sol\";\n\nimport \"../IERC1400.sol\";\n\ninterface IERC1400Extended {\n    // Not a real interface but added here since 'totalSupplyByPartition' doesn't belong to IERC1400\n\n    function totalSupplyByPartition(bytes32 partition)\n        external\n        view\n        returns (uint256);\n}\n\n/**\n * @title BatchBalanceReader\n * @dev Proxy contract to read multiple ERC1400/ERC20 token balances in a single contract call.\n */\ncontract BatchBalanceReader is ERC1820Implementer {\n    string internal constant BALANCE_READER = \"BatchBalanceReader\";\n\n    constructor() public {\n        ERC1820Implementer._setInterface(BALANCE_READER);\n    }\n\n    /**\n     * @dev Get a batch of ERC1400 token balances.\n     * @param tokenHolders Addresses for which the balance is required.\n     * @param tokenAddresses Addresses of tokens where the balances need to be fetched.\n     * @param partitions Name of the partitions.\n     * @return Balances array.\n     */\n    function balancesOfByPartition(\n        address[] calldata tokenHolders,\n        address[] calldata tokenAddresses,\n        bytes32[] calldata partitions\n    ) external view returns (uint256[] memory) {\n        uint256[] memory partitionBalances = new uint256[](\n            tokenAddresses.length * partitions.length * tokenHolders.length\n        );\n        uint256 index;\n        for (uint256 i = 0; i < tokenHolders.length; i++) {\n            for (uint256 j = 0; j < tokenAddresses.length; j++) {\n                for (uint256 k = 0; k < partitions.length; k++) {\n                    index =\n                        i *\n                        (tokenAddresses.length * partitions.length) +\n                        j *\n                        partitions.length +\n                        k;\n                    partitionBalances[index] = IERC1400(tokenAddresses[j])\n                        .balanceOfByPartition(partitions[k], tokenHolders[i]);\n                }\n            }\n        }\n\n        return partitionBalances;\n    }\n\n    /**\n     * @dev Get a batch of ERC20 token balances.\n     * @param tokenHolders Addresses for which the balance is required.\n     * @param tokenAddresses Addresses of tokens where the balances need to be fetched.\n     * @return Balances array.\n     */\n    function balancesOf(\n        address[] calldata tokenHolders,\n        address[] calldata tokenAddresses\n    ) external view returns (uint256[] memory) {\n        uint256[] memory balances = new uint256[](\n            tokenHolders.length * tokenAddresses.length\n        );\n        uint256 index;\n        for (uint256 i = 0; i < tokenHolders.length; i++) {\n            for (uint256 j = 0; j < tokenAddresses.length; j++) {\n                index = i * tokenAddresses.length + j;\n                balances[index] = IERC20(tokenAddresses[j]).balanceOf(\n                    tokenHolders[i]\n                );\n            }\n        }\n        return balances;\n    }\n\n    /**\n     * @dev Get a batch of ERC1400 token total supplies by partitions.\n     * @param partitions Name of the partitions.\n     * @param tokenAddresses Addresses of tokens where the balances need to be fetched.\n     * @return Balances array.\n     */\n    function totalSuppliesByPartition(\n        bytes32[] calldata partitions,\n        address[] calldata tokenAddresses\n    ) external view returns (uint256[] memory) {\n        uint256[] memory partitionSupplies = new uint256[](\n            partitions.length * tokenAddresses.length\n        );\n        uint256 index;\n        for (uint256 i = 0; i < tokenAddresses.length; i++) {\n            for (uint256 j = 0; j < partitions.length; j++) {\n                index = i * partitions.length + j;\n                partitionSupplies[index] = IERC1400Extended(tokenAddresses[i])\n                    .totalSupplyByPartition(partitions[j]);\n            }\n        }\n        return partitionSupplies;\n    }\n\n    /**\n     * @dev Get a batch of ERC20 token total supplies.\n     * @param tokenAddresses Addresses of tokens where the balances need to be fetched.\n     * @return Balances array.\n     */\n    function totalSupplies(address[] calldata tokenAddresses)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory supplies = new uint256[](tokenAddresses.length);\n        for (uint256 i = 0; i < tokenAddresses.length; i++) {\n            supplies[i] = IERC20(tokenAddresses[i]).totalSupply();\n        }\n        return supplies;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}